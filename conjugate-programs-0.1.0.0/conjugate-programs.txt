-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A simple DSL for probabilistic programming with conjugate models.
@package conjugate-programs
@version 0.1.0.0

module Inference.Conjugate

-- | Describes a family of distributions with a fixed form. For example, a
--   <a>Bernoulli</a> distribution is parameterized by a probability
--   <tt>p</tt> and produces binary samples (<tt>True</tt> with probability
--   <tt>p</tt>, <tt>False</tt> with probability <tt>1-p</tt>).
--   
--   Its <a>Distribution</a> instance is: &gt; instance Distribution
--   Bernoulli where &gt; type Params Bernoulli = Double &gt; type Support
--   Bernoulli = Bool &gt; distSample _ = uncurry bernoulli &gt; distLogP _
--   p True = log p &gt; distLogP _ p False = log (1 - p)
class Distribution a where {
    type Params a :: Type;
    type Support a :: Type;
}
distSample :: (Distribution a, PrimMonad m) => a -> Params a -> Prob m (Support a)
distLogP :: Distribution a => a -> Params a -> Support a -> Double

-- | A type-level marker for treating a distribution as a prior.
newtype AsPrior p
AsPrior :: p -> AsPrior p

-- | Marks two distributions as a conjugate pair of prior and likelihood.
--   The property of such a pair is that the posterior has the same form as
--   the prior (including the same <a>Params</a> and <a>Support</a>), and
--   that its parameters can be obtained analytically from the parameters
--   of the prior and a set of observations.
--   
--   The class method <a>updatePrior</a> returns the parameters of the
--   posterior given the prior parameters after a single observation.
class (Distribution p, Distribution l, Support p ~ Params l) => Conjugate p l
priorSingleton :: Conjugate p l => p
updatePrior :: Conjugate p l => l -> Params p -> Support l -> Params p
predLogP :: Conjugate p l => l -> Params p -> Support l -> Double
type family Hyper (a :: k) :: Type
type family Probs (a :: k) :: Type
newtype HyperRep p
HyperRep :: Hyper (AsPrior p) -> HyperRep p
[runHyper] :: HyperRep p -> Hyper (AsPrior p)
newtype ProbsRep p
ProbsRep :: Probs (AsPrior p) -> ProbsRep p
[runProbs] :: ProbsRep p -> Probs (AsPrior p)
class Jeffreys a
jeffreysPrior :: Jeffreys a => Hyper a
class GJeffreys t
gjeffreysPrior :: forall p. GJeffreys t => t p
class Uniform a
uniformPrior :: Uniform a => Hyper a
class GUniform t
guniformPrior :: forall p. GUniform t => t p
class Prior a
sampleProbs :: (Prior a, PrimMonad m) => Hyper a -> Prob m (Probs a)
class GPrior i o
gsampleProbs :: forall m p. (GPrior i o, PrimMonad m) => i p -> Prob m (o p)
type Accessor r p = forall f. Lens' (r f) (f p)
class Monad m => RandomInterpreter m r | m -> r where {
    type SampleCtx m a :: Constraint;
}
sampleValue :: (RandomInterpreter m r, Conjugate p l, SampleCtx m l) => String -> l -> Accessor r p -> m (Support l)
sampleConst :: (RandomInterpreter m r, Distribution d, SampleCtx m d) => String -> d -> Params d -> m (Support d)
permutationPlate :: (RandomInterpreter m r, Ord a) => Int -> m a -> m [a]
newtype Trace (r :: (Type -> Type) -> Type)
Trace :: Seq Dynamic -> Trace (r :: (Type -> Type) -> Type)
[runTrace] :: Trace (r :: (Type -> Type) -> Type) -> Seq Dynamic
observeValue :: (Conjugate p l, Typeable (Support l), Monad m) => String -> l -> Accessor r p -> Support l -> StateT (Trace r) m ()
observeConst :: (Distribution d, Typeable (Support d), Monad m) => String -> d -> Params d -> Support d -> StateT (Trace r) m ()
takeTrace :: Typeable a => Trace r -> Maybe (a, Trace r)
newtype SampleI m r a
SampleI :: ReaderT (r ProbsRep) (Prob m) a -> SampleI m r a
sampleResult :: p ProbsRep -> SampleI m p a -> Gen (PrimState m) -> m a
newtype TraceI m r a
TraceI :: ReaderT (r ProbsRep) (StateT (Trace r) (Prob m)) a -> TraceI m r a
sampleTrace :: r ProbsRep -> TraceI m r a -> Gen (PrimState m) -> m (a, Trace r)
newtype EvalTraceI r a
EvalTraceI :: ReaderT (r ProbsRep) (StateT (Trace r, Double) Maybe) a -> EvalTraceI r a
runTraceLogP :: r ProbsRep -> Trace r -> EvalTraceI r a -> Maybe (a, (Trace r, Double))
evalTraceLogP :: r ProbsRep -> Trace r -> EvalTraceI r a -> Maybe (a, Double)
newtype EvalPredTraceI r a
EvalPredTraceI :: ReaderT (r HyperRep) (StateT (Trace r, Double) Maybe) a -> EvalPredTraceI r a
runTracePredLogP :: r HyperRep -> Trace r -> EvalPredTraceI r a -> Maybe (a, (Trace r, Double))
evalTracePredLogP :: r HyperRep -> Trace r -> EvalPredTraceI r a -> Maybe (a, Double)
newtype UpdatePriorsI r a
UpdatePriorsI :: StateT (Trace r, r HyperRep) Maybe a -> UpdatePriorsI r a
getPosterior :: r HyperRep -> Trace r -> UpdatePriorsI r a -> Maybe (r HyperRep)
newtype ShowTraceI r a
ShowTraceI :: MaybeT (WriterT String (State (Trace r))) a -> ShowTraceI r a
showTraceItem :: forall l r. (Show (Support l), Typeable l, Typeable (Support l)) => String -> ShowTraceI r (Support l)
showTrace :: Trace r -> ShowTraceI r a -> (Maybe a, String)
printTrace :: Trace r -> ShowTraceI r a -> IO ()
newtype TraceTraceI r a
TraceTraceI :: State (Trace r) a -> TraceTraceI r a
traceTraceItem :: forall l r. (Show (Support l), Typeable l, Typeable (Support l)) => String -> TraceTraceI r (Support l)
traceTrace :: Trace r -> TraceTraceI r a -> a
data Beta
Beta :: Beta
data Bernoulli
Bernoulli :: Bernoulli
newtype Binomial
Binomial :: Int -> Binomial
data Categorical n
Categorical :: Categorical n
data Dirichlet n
Dirichlet :: Dirichlet n
data Geometric0
Geometric0 :: Geometric0
data Geometric1
Geometric1 :: Geometric1
instance GHC.Show.Show (Inference.Conjugate.Trace r)
instance GHC.Base.Monad m => GHC.Base.Monad (Inference.Conjugate.SampleI m r)
instance GHC.Base.Monad m => GHC.Base.Applicative (Inference.Conjugate.SampleI m r)
instance GHC.Base.Functor m => GHC.Base.Functor (Inference.Conjugate.SampleI m r)
instance GHC.Base.Monad m => GHC.Base.Monad (Inference.Conjugate.TraceI m r)
instance GHC.Base.Monad m => GHC.Base.Applicative (Inference.Conjugate.TraceI m r)
instance GHC.Base.Functor m => GHC.Base.Functor (Inference.Conjugate.TraceI m r)
instance GHC.Base.Monad (Inference.Conjugate.EvalTraceI r)
instance GHC.Base.Applicative (Inference.Conjugate.EvalTraceI r)
instance GHC.Base.Functor (Inference.Conjugate.EvalTraceI r)
instance GHC.Base.Monad (Inference.Conjugate.EvalPredTraceI r)
instance GHC.Base.Applicative (Inference.Conjugate.EvalPredTraceI r)
instance GHC.Base.Functor (Inference.Conjugate.EvalPredTraceI r)
instance GHC.Base.Monad (Inference.Conjugate.UpdatePriorsI r)
instance GHC.Base.Applicative (Inference.Conjugate.UpdatePriorsI r)
instance GHC.Base.Functor (Inference.Conjugate.UpdatePriorsI r)
instance GHC.Base.Monad (Inference.Conjugate.ShowTraceI r)
instance GHC.Base.Applicative (Inference.Conjugate.ShowTraceI r)
instance GHC.Base.Functor (Inference.Conjugate.ShowTraceI r)
instance GHC.Base.Monad (Inference.Conjugate.TraceTraceI r)
instance GHC.Base.Applicative (Inference.Conjugate.TraceTraceI r)
instance GHC.Base.Functor (Inference.Conjugate.TraceTraceI r)
instance GHC.Generics.Generic Inference.Conjugate.Beta
instance GHC.Show.Show Inference.Conjugate.Beta
instance GHC.Classes.Ord Inference.Conjugate.Beta
instance GHC.Classes.Eq Inference.Conjugate.Beta
instance GHC.Generics.Generic Inference.Conjugate.Bernoulli
instance GHC.Show.Show Inference.Conjugate.Bernoulli
instance GHC.Classes.Ord Inference.Conjugate.Bernoulli
instance GHC.Classes.Eq Inference.Conjugate.Bernoulli
instance GHC.Generics.Generic Inference.Conjugate.Binomial
instance GHC.Show.Show Inference.Conjugate.Binomial
instance GHC.Classes.Ord Inference.Conjugate.Binomial
instance GHC.Classes.Eq Inference.Conjugate.Binomial
instance GHC.Generics.Generic (Inference.Conjugate.Categorical n)
instance GHC.Show.Show (Inference.Conjugate.Categorical n)
instance GHC.Classes.Ord (Inference.Conjugate.Categorical n)
instance GHC.Classes.Eq (Inference.Conjugate.Categorical n)
instance GHC.Generics.Generic (Inference.Conjugate.Dirichlet n)
instance GHC.Show.Show (Inference.Conjugate.Dirichlet n)
instance GHC.Classes.Ord (Inference.Conjugate.Dirichlet n)
instance GHC.Classes.Eq (Inference.Conjugate.Dirichlet n)
instance GHC.Generics.Generic Inference.Conjugate.Geometric0
instance GHC.Show.Show Inference.Conjugate.Geometric0
instance GHC.Classes.Ord Inference.Conjugate.Geometric0
instance GHC.Classes.Eq Inference.Conjugate.Geometric0
instance GHC.Generics.Generic Inference.Conjugate.Geometric1
instance GHC.Show.Show Inference.Conjugate.Geometric1
instance GHC.Classes.Ord Inference.Conjugate.Geometric1
instance GHC.Classes.Eq Inference.Conjugate.Geometric1
instance GHC.Show.Show (Inference.Conjugate.Hyper (Inference.Conjugate.AsPrior p)) => GHC.Show.Show (Inference.Conjugate.HyperRep p)
instance GHC.Show.Show (Inference.Conjugate.Probs (Inference.Conjugate.AsPrior p)) => GHC.Show.Show (Inference.Conjugate.ProbsRep p)
instance Inference.Conjugate.Distribution Inference.Conjugate.Geometric1
instance Inference.Conjugate.Conjugate Inference.Conjugate.Beta Inference.Conjugate.Geometric1
instance Inference.Conjugate.Distribution Inference.Conjugate.Geometric0
instance Inference.Conjugate.Conjugate Inference.Conjugate.Beta Inference.Conjugate.Geometric0
instance Inference.Conjugate.Distribution (Inference.Conjugate.Dirichlet n)
instance GHC.TypeNats.KnownNat n => Inference.Conjugate.Jeffreys (Inference.Conjugate.AsPrior (Inference.Conjugate.Dirichlet n))
instance GHC.TypeNats.KnownNat n => Inference.Conjugate.Uniform (Inference.Conjugate.AsPrior (Inference.Conjugate.Dirichlet n))
instance Inference.Conjugate.Prior (Inference.Conjugate.AsPrior (Inference.Conjugate.Dirichlet n))
instance Inference.Conjugate.Conjugate (Inference.Conjugate.Dirichlet n) (Inference.Conjugate.Categorical n)
instance Inference.Conjugate.Distribution (Inference.Conjugate.Categorical n)
instance Inference.Conjugate.Distribution Inference.Conjugate.Binomial
instance Inference.Conjugate.Conjugate Inference.Conjugate.Beta Inference.Conjugate.Binomial
instance Inference.Conjugate.Distribution Inference.Conjugate.Bernoulli
instance Inference.Conjugate.Conjugate Inference.Conjugate.Beta Inference.Conjugate.Bernoulli
instance Inference.Conjugate.Distribution Inference.Conjugate.Beta
instance Inference.Conjugate.Jeffreys (Inference.Conjugate.AsPrior Inference.Conjugate.Beta)
instance Inference.Conjugate.Uniform (Inference.Conjugate.AsPrior Inference.Conjugate.Beta)
instance Inference.Conjugate.Prior (Inference.Conjugate.AsPrior Inference.Conjugate.Beta)
instance Inference.Conjugate.RandomInterpreter (Inference.Conjugate.TraceTraceI r) r
instance Inference.Conjugate.RandomInterpreter (Inference.Conjugate.ShowTraceI r) r
instance Inference.Conjugate.RandomInterpreter (Inference.Conjugate.UpdatePriorsI r) r
instance Inference.Conjugate.RandomInterpreter (Inference.Conjugate.EvalPredTraceI r) r
instance Inference.Conjugate.RandomInterpreter (Inference.Conjugate.EvalTraceI r) r
instance Control.Monad.Primitive.PrimMonad m => Inference.Conjugate.RandomInterpreter (Inference.Conjugate.TraceI m r) r
instance Control.Monad.Primitive.PrimMonad m => Inference.Conjugate.RandomInterpreter (Inference.Conjugate.SampleI m r) r
instance Inference.Conjugate.GPrior GHC.Generics.V1 GHC.Generics.V1
instance Inference.Conjugate.GPrior GHC.Generics.U1 GHC.Generics.U1
instance Inference.Conjugate.Prior (Inference.Conjugate.AsPrior p) => Inference.Conjugate.GPrior (GHC.Generics.K1 i (Inference.Conjugate.HyperRep p)) (GHC.Generics.K1 i (Inference.Conjugate.ProbsRep p))
instance (Inference.Conjugate.Prior k2, k2 Inference.Conjugate.HyperRep GHC.Types.~ Inference.Conjugate.Hyper k2, k2 Inference.Conjugate.ProbsRep GHC.Types.~ Inference.Conjugate.Probs k2) => Inference.Conjugate.GPrior (GHC.Generics.K1 i (k2 Inference.Conjugate.HyperRep)) (GHC.Generics.K1 i (k2 Inference.Conjugate.ProbsRep))
instance forall k (ti :: k -> *) (to :: k -> *) i (c :: GHC.Generics.Meta) i' (c' :: GHC.Generics.Meta). Inference.Conjugate.GPrior ti to => Inference.Conjugate.GPrior (GHC.Generics.M1 i c ti) (GHC.Generics.M1 i' c' to)
instance forall k (ia :: k -> *) (oa :: k -> *) (ib :: k -> *) (ob :: k -> *). (Inference.Conjugate.GPrior ia oa, Inference.Conjugate.GPrior ib ob) => Inference.Conjugate.GPrior (ia GHC.Generics.:*: ib) (oa GHC.Generics.:*: ob)
instance forall k (ia :: k -> *) (oa :: k -> *) (ib :: k -> *) (ob :: k -> *). (Inference.Conjugate.GPrior ia oa, Inference.Conjugate.GPrior ib ob) => Inference.Conjugate.GPrior (ia GHC.Generics.:+: ib) (oa GHC.Generics.:+: ob)
instance (GHC.Generics.Generic (a Inference.Conjugate.HyperRep), GHC.Generics.Generic (a Inference.Conjugate.ProbsRep), Inference.Conjugate.GPrior (GHC.Generics.Rep (a Inference.Conjugate.HyperRep)) (GHC.Generics.Rep (a Inference.Conjugate.ProbsRep))) => Inference.Conjugate.Prior a
instance Inference.Conjugate.GUniform GHC.Generics.V1
instance Inference.Conjugate.GUniform GHC.Generics.U1
instance Inference.Conjugate.Uniform (Inference.Conjugate.AsPrior p) => Inference.Conjugate.GUniform (GHC.Generics.K1 i (Inference.Conjugate.HyperRep p))
instance (Inference.Conjugate.Uniform k2, k2 Inference.Conjugate.HyperRep GHC.Types.~ Inference.Conjugate.Hyper k2) => Inference.Conjugate.GUniform (GHC.Generics.K1 i (k2 Inference.Conjugate.HyperRep))
instance Inference.Conjugate.GUniform t => Inference.Conjugate.GUniform (GHC.Generics.M1 i c t)
instance forall k (ta :: k -> *) (tb :: k -> *). (Inference.Conjugate.GUniform ta, Inference.Conjugate.GUniform tb) => Inference.Conjugate.GUniform (ta GHC.Generics.:*: tb)
instance (GHC.Generics.Generic (t Inference.Conjugate.HyperRep), Inference.Conjugate.GUniform (GHC.Generics.Rep (t Inference.Conjugate.HyperRep))) => Inference.Conjugate.Uniform t
instance Inference.Conjugate.GJeffreys GHC.Generics.V1
instance Inference.Conjugate.GJeffreys GHC.Generics.U1
instance Inference.Conjugate.Jeffreys (Inference.Conjugate.AsPrior p) => Inference.Conjugate.GJeffreys (GHC.Generics.K1 i (Inference.Conjugate.HyperRep p))
instance (Inference.Conjugate.Jeffreys k2, k2 Inference.Conjugate.HyperRep GHC.Types.~ Inference.Conjugate.Hyper k2) => Inference.Conjugate.GJeffreys (GHC.Generics.K1 i (k2 Inference.Conjugate.HyperRep))
instance Inference.Conjugate.GJeffreys t => Inference.Conjugate.GJeffreys (GHC.Generics.M1 i c t)
instance forall k (ta :: k -> *) (tb :: k -> *). (Inference.Conjugate.GJeffreys ta, Inference.Conjugate.GJeffreys tb) => Inference.Conjugate.GJeffreys (ta GHC.Generics.:*: tb)
instance (GHC.Generics.Generic (t Inference.Conjugate.HyperRep), Inference.Conjugate.GJeffreys (GHC.Generics.Rep (t Inference.Conjugate.HyperRep))) => Inference.Conjugate.Jeffreys t
