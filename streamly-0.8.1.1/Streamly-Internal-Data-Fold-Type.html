<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Streamly.Internal.Data.Fold.Type</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">streamly-0.8.1.1: Dataflow programming and declarative concurrency</span><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Fold.Type.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2019 Composewell Technologies<br />(c) 2013 Gabriel Gonzalez</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Fold.Type</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Types</a></li><li><a href="#g:2">Constructors</a></li><li><a href="#g:3">Folds</a></li><li><a href="#g:4">Combinators</a><ul><li><a href="#g:5">Mapping output</a></li><li><a href="#g:6">Mapping Input</a></li><li><a href="#g:7">Filtering</a></li><li><a href="#g:8">Trimming</a></li><li><a href="#g:9">Serial Append</a></li><li><a href="#g:10">Parallel Distribution</a></li><li><a href="#g:11">Parallel Alternative</a></li><li><a href="#g:12">Splitting</a></li><li><a href="#g:13">Nesting</a></li></ul></li><li><a href="#g:14">Running A Fold</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><h1>Stream Consumers</h1><p>We can classify stream consumers in the following categories in order of
 increasing complexity and power:</p><h2>Accumulators</h2><p>These are the simplest folds that never fail and never terminate, they
 accumulate the input values forever and can always accept new inputs (never
 terminate) and always have a valid result value.  A
 <code><a href="Streamly-Internal-Data-Fold.html#v:sum" title="Streamly.Internal.Data.Fold">sum</a></code> operation is an example of an accumulator.
 Traditional Haskell left folds like <code><a href="../base-4.16.4.0/Data-List.html#v:foldl" title="Data.List">foldl</a></code> are accumulators.</p><p>We can distribute an input stream to two or more accumulators using a <code>tee</code>
 style composition.  Accumulators cannot be applied on a stream one after the
 other, which we call a <code>serial</code> append style composition of folds. This is
 because accumulators never terminate, since the first accumulator in a
 series will never terminate, the next one will never get to run.</p><h2>Terminating Folds</h2><p>Terminating folds are accumulators that can terminate. Once a fold
 terminates it no longer accepts any more inputs.  Terminating folds can be
 used in a <code>serial</code> append style composition where one fold can be applied
 after the other on an input stream. We can apply a terminating fold
 repeatedly on an input stream, splitting the stream and consuming it in
 fragments.  Terminating folds never fail, therefore, they do not need
 backtracking.</p><p>The <code><a href="Streamly-Internal-Data-Fold.html#v:take" title="Streamly.Internal.Data.Fold">take</a></code> operation is an example of a
 terminating fold  It terminates after consuming <code>n</code> items. Coupled with an
 accumulator (e.g. sum) it can be used to split and process the stream into
 chunks of fixed size.</p><h2>Terminating Folds with Leftovers</h2><p>The next upgrade after terminating folds is terminating folds with leftover
 inputs.  Consider the example of <code>takeWhile</code> operation, it needs to inspect
 an element for termination decision. However, it does not consume the
 element on which it terminates. To implement <code>takeWhile</code> a terminating fold
 will have to implement a way to return unconsumed input to the fold driver.</p><p>Single element leftover case is the most common and its easy to implement it
 in terminating folds using a <code>Done1</code> constructor in the <code><a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a></code> type which
 indicates that the last element was not consumed by the fold. The following
 additional operations can be implemented as terminating folds if we do that.</p><pre>takeWhile
groupBy
wordBy
</pre><p>However, it creates several complications.  The <code><a href="Streamly-Internal-Data-Fold-Type.html#v:many" title="Streamly.Internal.Data.Fold.Type">many</a></code> combinator  requires
 a <code>Partial1</code> (<code><a href="Streamly-Internal-Data-Fold-Type.html#v:Partial" title="Streamly.Internal.Data.Fold.Type">Partial</a></code> with leftover) to handle a <code>Done1</code> from the top
 level fold, for efficient implementation.  If the collecting fold in &quot;many&quot;
 returns a <code>Partial1</code> or <code>Done1</code> then what to do with all the elements that
 have been consumed?</p><p>Similarly, in distribute, if one fold consumes a value and others say its a
 leftover then what do we do?  Folds like &quot;many&quot; require the leftover to be
 fed to it again. So in a distribute operation those folds which gave a
 leftover will have to be fed the leftover while the folds that consumed will
 have to be fed the next input.  This is very complicated to implement. We
 have the same issue in backtracking parsers being used in a distribute
 operation.</p><p>To avoid these issues we want to enforce by typing that the collecting folds
 can never return a leftover. So we need a fold type without <code>Done1</code> or
 <code>Partial1</code>. This leads us to design folds to never return a leftover and the
 use cases of single leftover are transferred to parsers where we have
 general backtracking mechanism and single leftover is just a special case of
 backtracking.</p><p>This means: takeWhile, groupBy, wordBy would be implemented as parsers.
 &quot;take 0&quot; can implemented as a fold if we make initial return <code>Step</code> type.
 &quot;takeInterval&quot; can be implemented without <code>Done1</code>.</p><h2>Parsers</h2><p>The next upgrade after terminating folds with a leftover are parsers.
 Parsers are terminating folds that can fail and backtrack. Parsers can be
 composed using an <code>alternative</code> style composition where they can backtrack
 and apply another parser if one parser fails.
 <code><a href="Streamly-Internal-Data-Parser.html#v:satisfy" title="Streamly.Internal.Data.Parser">satisfy</a></code> is a simple example of a parser, it
 would succeed if the condition is satisfied and it would fail otherwise, on
 failure an alternative parser can be used on the same input.</p><h1>Types for Stream Consumers</h1><p>In streamly, there is no separate type for accumulators. Terminating folds
 are a superset of accumulators and to avoid too many types we represent both
 using the same type, <code><a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a></code>.</p><p>We do not club the leftovers functionality with terminating folds because of
 the reasons explained earlier. Instead combinators that require leftovers
 are implemented as the <code><a href="Streamly-Internal-Data-Parser.html#v:Parser" title="Streamly.Internal.Data.Parser">Parser</a></code> type.  This is
 a sweet spot to balance ease of use, type safety and performance.  Using
 separate Accumulator and terminating fold types would encode more
 information in types but it would make ease of use, implementation,
 maintenance effort worse. Combining Accumulator, terminating folds and
 Parser into a single <code><a href="Streamly-Internal-Data-Parser.html#v:Parser" title="Streamly.Internal.Data.Parser">Parser</a></code> type would make
 ease of use even better but type safety and performance worse.</p><p>One of the design requirements that we have placed for better ease of use
 and code reuse is that <code><a href="Streamly-Internal-Data-Parser.html#v:Parser" title="Streamly.Internal.Data.Parser">Parser</a></code> type should be
 a strict superset of the <code><a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a></code> type i.e. it can do everything that a <code><a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a></code>
 can do and more. Therefore, folds can be easily upgraded to parsers and we
 can use parser combinators on folds as well when needed.</p><h1>Fold Design</h1><p>A fold is represented by a collection of &quot;initial&quot;, &quot;step&quot; and &quot;extract&quot;
 functions. The &quot;initial&quot; action generates the initial state of the fold. The
 state is internal to the fold and maintains the accumulated output. The
 &quot;step&quot; function is invoked using the current state and the next input value
 and results in a <code>Partial</code> or <code>Done</code>. A <code>Partial</code> returns the next intermediate
 state of the fold, a <code>Done</code> indicates that the fold has terminated and
 returns the final value of the accumulator.</p><p>Every <code>Partial</code> indicates that a new accumulated output is available.  The
 accumulated output can be extracted from the state at any point using
 &quot;extract&quot;. &quot;extract&quot; can never fail. A fold returns a valid output even
 without any input i.e. even if you call &quot;extract&quot; on &quot;initial&quot; state it
 provides an output. This is not true for parsers.</p><p>In general, &quot;extract&quot; is used in two cases:</p><ul><li>When the fold is used as a scan <code>extract</code> is called on the intermediate
 state every time it is yielded by the fold, the resulting value is yielded
 as a stream.</li><li>When the fold is used as a regular fold, <code>extract</code> is called once when
 we are done feeding input to the fold.</li></ul><h1>Alternate Designs</h1><p>An alternate and simpler design would be to return the intermediate output
 via <code>Partial</code> along with the state, instead of using &quot;extract&quot; on the yielded
 state and remove the extract function altogether.</p><p>This may even facilitate more efficient implementation.  Extract from the
 intermediate state after each yield may be more costly compared to the fold
 step itself yielding the output. The fold may have more efficient ways to
 retrieve the output rather than stuffing it in the state and using extract
 on the state.</p><p>However, removing extract altogether may lead to less optimal code in some
 cases because the driver of the fold needs to thread around the intermediate
 output to return it if the stream stops before the fold could <code>Done</code>.  When
 using this approach, the <code>parseMany (FL.take filesize)</code> benchmark shows a
 2x worse performance even after ensuring everything fuses.  So we keep the
 &quot;extract&quot; approach to ensure better perf in all cases.</p><p>But we could still yield both state and the output in <code>Partial</code>, the output
 can be used for the scan use case, instead of using extract. Extract would
 then be used only for the case when the stream stops before the fold
 completes.</p><h1>Accumulators and Terminating Folds</h1><p>Folds in this module can be classified in two categories viz. accumulators
 and terminating folds. Accumulators do not have a terminating condition,
 they run forever and consume the entire stream, for example the <code><a href="../base-4.16.4.0/Data-List.html#v:length" title="Data.List">length</a></code>
 fold. Terminating folds have a terminating condition and can terminate
 without consuming the entire stream, for example, the <code><a href="../base-4.16.4.0/GHC-List.html#v:head" title="GHC.List">head</a></code> fold.</p><h1>Monoids</h1><p>Monoids allow generalized, modular folding.  The accumulators in this module
 can be expressed using <code><a href="../base-4.16.4.0/Data-Monoid.html#v:mconcat" title="Data.Monoid">mconcat</a></code> and a suitable <code><a href="../base-4.16.4.0/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a></code>.  Instead of
 writing folds we can write Monoids and turn them into folds.</p><h1>Performance Notes</h1><p><code><a href="Streamly.html#v:Prelude" title="Streamly">Prelude</a></code> module provides fold functions to directly fold streams
 e.g.  Streamly.Prelude/<code><a href="Streamly-Prelude.html#v:sum" title="Streamly.Prelude">sum</a></code> serves the same purpose as
 Fold/<code><a href="../base-4.16.4.0/Data-List.html#v:sum" title="Data.List">sum</a></code>.  However, the functions in Streamly.Prelude cannot be
 efficiently combined together e.g. we cannot drive the input stream through
 <code>sum</code> and <code>length</code> fold functions simultaneously.  Using the <code><a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a></code> type we
 can efficiently split the stream across multiple folds because it allows the
 compiler to perform stream fusion optimizations.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:Step">Step</a> s b<ul class="subs"><li>= <a href="#v:Partial">Partial</a> !s</li><li>| <a href="#v:Done">Done</a> !b</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:Fold">Fold</a> m a b = <span class="keyword">forall</span> s. <a href="#v:Fold">Fold</a> (s -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> s b)) (m (<a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> s b)) (s -&gt; m b)</li><li class="src short"><a href="#v:foldl-39-">foldl'</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b</li><li class="src short"><a href="#v:foldlM-39-">foldlM'</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b</li><li class="src short"><a href="#v:foldl1-39-">foldl1'</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; a) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a (<a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:foldr">foldr</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b</li><li class="src short"><a href="#v:foldrM">foldrM</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; m b) -&gt; m b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b</li><li class="src short"><a href="#v:mkFold">mkFold</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (s -&gt; a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> s b) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> s b -&gt; (s -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b</li><li class="src short"><a href="#v:mkFold_">mkFold_</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> b b) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> b b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b</li><li class="src short"><a href="#v:mkFoldM">mkFoldM</a> :: (s -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> s b)) -&gt; m (<a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> s b) -&gt; (s -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b</li><li class="src short"><a href="#v:mkFoldM_">mkFoldM_</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> b b)) -&gt; m (<a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> b b) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b</li><li class="src short"><a href="#v:fromPure">fromPure</a> :: <a href="../base-4.16.4.0/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b</li><li class="src short"><a href="#v:fromEffect">fromEffect</a> :: <a href="../base-4.16.4.0/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; m b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b</li><li class="src short"><a href="#v:fromRefold">fromRefold</a> :: <a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a> m c a b -&gt; c -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b</li><li class="src short"><a href="#v:drain">drain</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a ()</li><li class="src short"><a href="#v:toList">toList</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a [a]</li><li class="src short"><a href="#v:toStreamK">toStreamK</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> n a)</li><li class="src short"><a href="#v:toStreamKRev">toStreamKRev</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> n a)</li><li class="src short"><a href="#v:rmapM">rmapM</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a c</li><li class="src short"><a href="#v:lmap">lmap</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m b r -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a r</li><li class="src short"><a href="#v:lmapM">lmapM</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m b r -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a r</li><li class="src short"><a href="#v:filter">filter</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a r -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a r</li><li class="src short"><a href="#v:filterM">filterM</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a r -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a r</li><li class="src short"><a href="#v:catMaybes">catMaybes</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m (<a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) b</li><li class="src short"><a href="#v:take">take</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b</li><li class="src short"><a href="#v:serialWith">serialWith</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x c</li><li class="src short"><a href="#v:serial_">serial_</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x b</li><li class="src short"><a href="#v:teeWith">teeWith</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x c</li><li class="src short"><a href="#v:teeWithFst">teeWithFst</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; c -&gt; d) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a d</li><li class="src short"><a href="#v:teeWithMin">teeWithMin</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; c -&gt; d) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a d</li><li class="src short"><a href="#v:shortest">shortest</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b)</li><li class="src short"><a href="#v:longest">longest</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b)</li><li class="src short"><span class="keyword">data</span> <a href="#t:ManyState">ManyState</a> s1 s2</li><li class="src short"><a href="#v:many">many</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a c</li><li class="src short"><a href="#v:manyPost">manyPost</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a c</li><li class="src short"><a href="#v:chunksOf">chunksOf</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a c</li><li class="src short"><a href="#v:refoldMany">refoldMany</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a> m x b c -&gt; <a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a> m x a c</li><li class="src short"><a href="#v:refoldMany1">refoldMany1</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a> m x a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a> m x a c</li><li class="src short"><a href="#v:refold">refold</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a> m b a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b</li><li class="src short"><a href="#v:concatMap">concatMap</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a c) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a c</li><li class="src short"><a href="#v:initialize">initialize</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; m (<a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b)</li><li class="src short"><a href="#v:snoc">snoc</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b)</li><li class="src short"><a href="#v:duplicate">duplicate</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a (<a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b)</li><li class="src short"><a href="#v:finish">finish</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; m b</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Types</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Step" class="def">Step</a> s b <a href="src/Streamly.Internal.Data.Fold.Step.html#Step" class="link">Source</a> <a href="#t:Step" class="selflink">#</a></p><div class="doc"><p>Represents the result of the <code>step</code> of a <code>Fold</code>.  <code><a href="Streamly-Internal-Data-Fold-Type.html#v:Partial" title="Streamly.Internal.Data.Fold.Type">Partial</a></code> returns an
 intermediate state of the fold, the fold step can be called again with the
 state or the driver can use <code>extract</code> on the state to get the result out.
 <code><a href="Streamly-Internal-Data-Fold-Type.html#v:Done" title="Streamly.Internal.Data.Fold.Type">Done</a></code> returns the final result and the fold cannot be driven further.</p><p><em>Pre-release</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Partial" class="def">Partial</a> !s</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:Done" class="def">Done</a> !b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Step">Instances</h4><details id="i:Step" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Step:Bifunctor:1"></span> <a href="../base-4.16.4.0/Data-Bifunctor.html#t:Bifunctor" title="Data.Bifunctor">Bifunctor</a> <a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a></span> <a href="src/Streamly.Internal.Data.Fold.Step.html#line-45" class="link">Source</a> <a href="#t:Step" class="selflink">#</a></td><td class="doc"><p><code><a href="../base-4.16.4.0/Data-Bifunctor.html#v:first" title="Data.Bifunctor">first</a></code> maps over <code><a href="Streamly-Internal-Data-Fold-Type.html#v:Partial" title="Streamly.Internal.Data.Fold.Type">Partial</a></code> and <code><a href="../base-4.16.4.0/Data-Bifunctor.html#v:second" title="Data.Bifunctor">second</a></code> maps over <code><a href="Streamly-Internal-Data-Fold-Type.html#v:Done" title="Streamly.Internal.Data.Fold.Type">Done</a></code>.</p></td></tr><tr><td colspan="2"><details id="i:id:Step:Bifunctor:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Step.html">Streamly.Internal.Data.Fold.Step</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:bimap">bimap</a> :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> a c -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> b d <a href="#v:bimap" class="selflink">#</a></p><p class="src"><a href="#v:first">first</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> a c -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> b c <a href="#v:first" class="selflink">#</a></p><p class="src"><a href="#v:second">second</a> :: (b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> a c <a href="#v:second" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Step:Functor:2"></span> <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> s)</span> <a href="src/Streamly.Internal.Data.Fold.Step.html#line-64" class="link">Source</a> <a href="#t:Step" class="selflink">#</a></td><td class="doc"><p><code><a href="../base-4.16.4.0/Data-Functor.html#v:fmap" title="Data.Functor">fmap</a></code> maps over <code><a href="Streamly-Internal-Data-Fold-Type.html#v:Done" title="Streamly.Internal.Data.Fold.Type">Done</a></code>.</p><pre>fmap = <code><a href="../base-4.16.4.0/Data-Bifunctor.html#v:second" title="Data.Bifunctor">second</a></code>
</pre></td></tr><tr><td colspan="2"><details id="i:id:Step:Functor:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Step.html">Streamly.Internal.Data.Fold.Step</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> s a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> s b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> s b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> s a <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Fold" class="def">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Type.html#Fold" class="link">Source</a> <a href="#t:Fold" class="selflink">#</a></p><div class="doc"><p>The type <code>Fold m a b</code> having constructor <code>Fold step initial extract</code>
 represents a fold over an input stream of values of type <code>a</code> to a final
 value of type <code>b</code> in <code><a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> <code>m</code>.</p><p>The fold uses an intermediate state <code>s</code> as accumulator, the type <code>s</code> is
 internal to the specific fold definition. The initial value of the fold
 state <code>s</code> is returned by <code>initial</code>. The <code>step</code> function consumes an input
 and either returns the final result <code>b</code> if the fold is done or the next
 intermediate state (see <code><a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a></code>). At any point the fold driver can extract
 the result from the intermediate state using the <code>extract</code> function.</p><p>NOTE: The constructor is not yet exposed via exposed modules, smart
 constructors are provided to create folds.  If you think you need the
 constructor of this type please consider using the smart constructors in
 <a href="Streamly-Internal-Data-Fold.html">Streamly.Internal.Data.Fold</a> instead.</p><p><em>since 0.8.0 (type changed)</em></p><p><em>Since: 0.7.0</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><span class="keyword">forall</span> s. <a id="v:Fold" class="def">Fold</a> (s -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> s b)) (m (<a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> s b)) (s -&gt; m b)</td><td class="doc"><p><code>Fold </code> <code> step </code> <code> initial </code> <code> extract</code></p></td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Fold">Instances</h4><details id="i:Fold" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Fold:Functor:1"></span> <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> m =&gt; <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a)</span> <a href="src/Streamly.Internal.Data.Fold.Type.html#line-578" class="link">Source</a> <a href="#t:Fold" class="selflink">#</a></td><td class="doc"><p>Maps a function on the output of the fold (the type <code>b</code>).</p></td></tr><tr><td colspan="2"><details id="i:id:Fold:Functor:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Fold-Type.html">Streamly.Internal.Data.Fold.Type</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a0 -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a0 -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a a0 <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><a href="#g:2" id="g:2"><h1>Constructors</h1></a><div class="top"><p class="src"><a id="v:foldl-39-" class="def">foldl'</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Type.html#foldl%27" class="link">Source</a> <a href="#v:foldl-39-" class="selflink">#</a></p><div class="doc"><p>Make a fold from a left fold style pure step function and initial value of
 the accumulator.</p><p>If your <code><a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a></code> returns only <code><a href="Streamly-Internal-Data-Fold-Type.html#v:Partial" title="Streamly.Internal.Data.Fold.Type">Partial</a></code> (i.e. never returns a <code><a href="Streamly-Internal-Data-Fold-Type.html#v:Done" title="Streamly.Internal.Data.Fold.Type">Done</a></code>) then you
 can use <code>foldl'*</code> constructors.</p><p>A fold with an extract function can be expressed using fmap:</p><pre>mkfoldlx :: Monad m =&gt; (s -&gt; a -&gt; s) -&gt; s -&gt; (s -&gt; b) -&gt; Fold m a b
mkfoldlx step initial extract = fmap extract (foldl' step initial)
</pre><p>See also: <code>Streamly.Prelude.foldl'</code></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:foldlM-39-" class="def">foldlM'</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Type.html#foldlM%27" class="link">Source</a> <a href="#v:foldlM-39-" class="selflink">#</a></p><div class="doc"><p>Make a fold from a left fold style monadic step function and initial value
 of the accumulator.</p><p>A fold with an extract function can be expressed using rmapM:</p><pre>mkFoldlxM :: Functor m =&gt; (s -&gt; a -&gt; m s) -&gt; m s -&gt; (s -&gt; m b) -&gt; Fold m a b
mkFoldlxM step initial extract = rmapM extract (foldlM' step initial)
</pre><p>See also: <code>Streamly.Prelude.foldlM'</code></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:foldl1-39-" class="def">foldl1'</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; a) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a (<a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Fold.Type.html#foldl1%27" class="link">Source</a> <a href="#v:foldl1-39-" class="selflink">#</a></p><div class="doc"><p>Make a strict left fold, for non-empty streams, using first element as the
 starting value. Returns Nothing if the stream is empty.</p><p>See also: <code>Streamly.Prelude.foldl1'</code></p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:foldr" class="def">foldr</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Type.html#foldr" class="link">Source</a> <a href="#v:foldr" class="selflink">#</a></p><div class="doc"><p>Make a fold using a right fold style step function and a terminal value.
 It performs a strict right fold via a left fold using function composition.
 Note that this is strict fold, it can only be useful for constructing strict
 structures in memory. For reductions this will be very inefficient.</p><p>For example,</p><pre>toList = foldr (:) []</pre><p>See also: <code><a href="Streamly-Prelude.html#v:foldr" title="Streamly.Prelude">foldr</a></code></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:foldrM" class="def">foldrM</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; m b) -&gt; m b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Type.html#foldrM" class="link">Source</a> <a href="#v:foldrM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Fold-Type.html#v:foldr" title="Streamly.Internal.Data.Fold.Type">foldr</a></code> but with a monadic step function.</p><p>For example,</p><pre>toList = foldrM (\a xs -&gt; return $ a : xs) (return [])</pre><p>See also: <code><a href="Streamly-Prelude.html#v:foldrM" title="Streamly.Prelude">foldrM</a></code></p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:mkFold" class="def">mkFold</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (s -&gt; a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> s b) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> s b -&gt; (s -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Type.html#mkFold" class="link">Source</a> <a href="#v:mkFold" class="selflink">#</a></p><div class="doc"><p>Make a terminating fold using a pure step function, a pure initial state
 and a pure state extraction function.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:mkFold_" class="def">mkFold_</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> b b) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> b b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Type.html#mkFold_" class="link">Source</a> <a href="#v:mkFold_" class="selflink">#</a></p><div class="doc"><p>Similar to <code><a href="Streamly-Internal-Data-Fold-Type.html#v:mkFold" title="Streamly.Internal.Data.Fold.Type">mkFold</a></code> but the final state extracted is identical to the
 intermediate state.</p><pre>mkFold_ step initial = mkFold step initial id
</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:mkFoldM" class="def">mkFoldM</a> :: (s -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> s b)) -&gt; m (<a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> s b) -&gt; (s -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Type.html#mkFoldM" class="link">Source</a> <a href="#v:mkFoldM" class="selflink">#</a></p><div class="doc"><p>Make a terminating fold with an effectful step function and initial state,
 and a state extraction function.</p><pre>mkFoldM = Fold</pre><p>We can just use <code><a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a></code> but it is provided for completeness.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:mkFoldM_" class="def">mkFoldM_</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> b b)) -&gt; m (<a href="Streamly-Internal-Data-Fold-Type.html#t:Step" title="Streamly.Internal.Data.Fold.Type">Step</a> b b) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Type.html#mkFoldM_" class="link">Source</a> <a href="#v:mkFoldM_" class="selflink">#</a></p><div class="doc"><p>Similar to <code><a href="Streamly-Internal-Data-Fold-Type.html#v:mkFoldM" title="Streamly.Internal.Data.Fold.Type">mkFoldM</a></code> but the final state extracted is identical to the
 intermediate state.</p><pre>mkFoldM_ step initial = mkFoldM step initial return
</pre><p><em>Pre-release</em></p></div></div><a href="#g:3" id="g:3"><h1>Folds</h1></a><div class="top"><p class="src"><a id="v:fromPure" class="def">fromPure</a> :: <a href="../base-4.16.4.0/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Type.html#fromPure" class="link">Source</a> <a href="#v:fromPure" class="selflink">#</a></p><div class="doc"><p>A fold that always yields a pure value without consuming any input.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:fromEffect" class="def">fromEffect</a> :: <a href="../base-4.16.4.0/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> m =&gt; m b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Type.html#fromEffect" class="link">Source</a> <a href="#v:fromEffect" class="selflink">#</a></p><div class="doc"><p>A fold that always yields the result of an effectful action without
 consuming any input.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:fromRefold" class="def">fromRefold</a> :: <a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a> m c a b -&gt; c -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Type.html#fromRefold" class="link">Source</a> <a href="#v:fromRefold" class="selflink">#</a></p><div class="doc"><p>Make a fold from a consumer.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:drain" class="def">drain</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a () <a href="src/Streamly.Internal.Data.Fold.Type.html#drain" class="link">Source</a> <a href="#v:drain" class="selflink">#</a></p><div class="doc"><p>A fold that drains all its input, running the effects and discarding the
 results.</p><pre>drain = drainBy (const (return ()))</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:toList" class="def">toList</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a [a] <a href="src/Streamly.Internal.Data.Fold.Type.html#toList" class="link">Source</a> <a href="#v:toList" class="selflink">#</a></p><div class="doc"><p>Folds the input stream to a list.</p><p><em>Warning!</em> working on large lists accumulated as buffers in memory could be
 very inefficient, consider using <a href="Streamly-Data-Array-Foreign.html">Streamly.Data.Array.Foreign</a>
 instead.</p><pre>toList = foldr (:) []</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:toStreamK" class="def">toStreamK</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> n a) <a href="src/Streamly.Internal.Data.Fold.Type.html#toStreamK" class="link">Source</a> <a href="#v:toStreamK" class="selflink">#</a></p><div class="doc"><p>A fold that buffers its input to a pure stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>toStreamK = foldr StreamK.cons StreamK.nil
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>toStreamK = fmap StreamK.reverse Fold.toStreamKRev
</code></strong></pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:toStreamKRev" class="def">toStreamKRev</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a (<a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> n a) <a href="src/Streamly.Internal.Data.Fold.Type.html#toStreamKRev" class="link">Source</a> <a href="#v:toStreamKRev" class="selflink">#</a></p><div class="doc"><p>Buffers the input stream to a pure stream in the reverse order of the
 input.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>toStreamKRev = Foldable.foldl' (flip StreamK.cons) StreamK.nil
</code></strong></pre><p>This is more efficient than <code><a href="Streamly-Internal-Data-Fold-Type.html#v:toStreamK" title="Streamly.Internal.Data.Fold.Type">toStreamK</a></code>. toStreamK has exactly the same
 performance as reversing the stream after toStreamKRev.</p><p><em>Pre-release</em></p></div></div><a href="#g:4" id="g:4"><h1>Combinators</h1></a><a href="#g:5" id="g:5"><h2>Mapping output</h2></a><div class="top"><p class="src"><a id="v:rmapM" class="def">rmapM</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; m c) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a c <a href="src/Streamly.Internal.Data.Fold.Type.html#rmapM" class="link">Source</a> <a href="#v:rmapM" class="selflink">#</a></p><div class="doc"><p>Map a monadic function on the output of a fold.</p><p><em>Since: 0.8.0</em></p></div></div><a href="#g:6" id="g:6"><h2>Mapping Input</h2></a><div class="top"><p class="src"><a id="v:lmap" class="def">lmap</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m b r -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a r <a href="src/Streamly.Internal.Data.Fold.Type.html#lmap" class="link">Source</a> <a href="#v:lmap" class="selflink">#</a></p><div class="doc"><p><code>lmap f fold</code> maps the function <code>f</code> on the input of the fold.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.fold (Fold.lmap (\x -&gt; x * x) Fold.sum) (Stream.enumerateFromTo 1 100)
</code></strong>338350
</pre><pre>lmap = Fold.lmapM return</pre><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:lmapM" class="def">lmapM</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m b r -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a r <a href="src/Streamly.Internal.Data.Fold.Type.html#lmapM" class="link">Source</a> <a href="#v:lmapM" class="selflink">#</a></p><div class="doc"><p><code>lmapM f fold</code> maps the monadic function <code>f</code> on the input of the fold.</p><p><em>Since: 0.8.0</em></p></div></div><a href="#g:7" id="g:7"><h2>Filtering</h2></a><div class="top"><p class="src"><a id="v:filter" class="def">filter</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a r -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a r <a href="src/Streamly.Internal.Data.Fold.Type.html#filter" class="link">Source</a> <a href="#v:filter" class="selflink">#</a></p><div class="doc"><p>Include only those elements that pass a predicate.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.fold (Fold.filter (&gt; 5) Fold.sum) $ Stream.fromList [1..10]
</code></strong>40
</pre><pre>filter f = Fold.filterM (return . f)</pre><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:filterM" class="def">filterM</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a r -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a r <a href="src/Streamly.Internal.Data.Fold.Type.html#filterM" class="link">Source</a> <a href="#v:filterM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Fold-Type.html#v:filter" title="Streamly.Internal.Data.Fold.Type">filter</a></code> but with a monadic predicate.</p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:catMaybes" class="def">catMaybes</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m (<a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) b <a href="src/Streamly.Internal.Data.Fold.Type.html#catMaybes" class="link">Source</a> <a href="#v:catMaybes" class="selflink">#</a></p><div class="doc"><p>Modify a fold to receive a <code><a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> input, the <code><a href="../base-4.16.4.0/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code> values are unwrapped
 and sent to the original fold, <code><a href="../base-4.16.4.0/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> values are discarded.</p><p><em>Since: 0.8.0</em></p></div></div><a href="#g:8" id="g:8"><h2>Trimming</h2></a><div class="top"><p class="src"><a id="v:take" class="def">take</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Type.html#take" class="link">Source</a> <a href="#v:take" class="selflink">#</a></p><div class="doc"><p>Take at most <code>n</code> input elements and fold them using the supplied fold. A
 negative count is treated as 0.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.fold (Fold.take 2 Fold.toList) $ Stream.fromList [1..10]
</code></strong>[1,2]
</pre><p><em>Since: 0.8.0</em></p></div></div><a href="#g:9" id="g:9"><h2>Serial Append</h2></a><div class="top"><p class="src"><a id="v:serialWith" class="def">serialWith</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x c <a href="src/Streamly.Internal.Data.Fold.Type.html#serialWith" class="link">Source</a> <a href="#v:serialWith" class="selflink">#</a></p><div class="doc"><p>Sequential fold application. Apply two folds sequentially to an input
 stream.  The input is provided to the first fold, when it is done - the
 remaining input is provided to the second fold. When the second fold is done
 or if the input stream is over, the outputs of the two folds are combined
 using the supplied function.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>f = Fold.serialWith (,) (Fold.take 8 Fold.toList) (Fold.takeEndBy (== '\n') Fold.toList)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.fold f $ Stream.fromList &quot;header: hello\n&quot;
</code></strong>(&quot;header: &quot;,&quot;hello\n&quot;)
</pre><p>Note: This is dual to appending streams using <code><a href="Streamly-Prelude.html#v:serial" title="Streamly.Prelude">serial</a></code>.</p><p>Note: this implementation allows for stream fusion but has quadratic time
 complexity, because each composition adds a new branch that each subsequent
 fold's input element has to traverse, therefore, it cannot scale to a large
 number of compositions. After around 100 compositions the performance starts
 dipping rapidly compared to a CPS style implementation.</p><p><em>Time: O(n^2) where n is the number of compositions.</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:serial_" class="def">serial_</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x b <a href="src/Streamly.Internal.Data.Fold.Type.html#serial_" class="link">Source</a> <a href="#v:serial_" class="selflink">#</a></p><div class="doc"><p>Same as applicative <code><a href="../base-4.16.4.0/Control-Applicative.html#v:-42--62-" title="Control.Applicative">*&gt;</a></code>. Run two folds serially one after the other
 discarding the result of the first.</p><p>This was written in the hope that it might be faster than implementing it
 using serialWith, but the current benchmarks show that it has the same
 performance. So do not expose it unless some benchmark shows benefit.</p></div></div><a href="#g:10" id="g:10"><h2>Parallel Distribution</h2></a><div class="top"><p class="src"><a id="v:teeWith" class="def">teeWith</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x c <a href="src/Streamly.Internal.Data.Fold.Type.html#teeWith" class="link">Source</a> <a href="#v:teeWith" class="selflink">#</a></p><div class="doc"><p><code>teeWith k f1 f2</code> distributes its input to both <code>f1</code> and <code>f2</code> until both
 of them terminate and combines their output using <code>k</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>avg = Fold.teeWith (/) Fold.sum (fmap fromIntegral Fold.length)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.fold avg $ Stream.fromList [1.0..100.0]
</code></strong>50.5
</pre><pre>teeWith k f1 f2 = fmap (uncurry k) ((Fold.tee f1 f2)</pre><p>For applicative composition using this combinator see
 <a href="Streamly-Internal-Data-Fold-Tee.html">Streamly.Internal.Data.Fold.Tee</a>.</p><p>See also: <a href="Streamly-Internal-Data-Fold-Tee.html">Streamly.Internal.Data.Fold.Tee</a></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:teeWithFst" class="def">teeWithFst</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; c -&gt; d) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a d <a href="src/Streamly.Internal.Data.Fold.Type.html#teeWithFst" class="link">Source</a> <a href="#v:teeWithFst" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Fold-Type.html#v:teeWith" title="Streamly.Internal.Data.Fold.Type">teeWith</a></code> but terminates as soon as the first fold terminates.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:teeWithMin" class="def">teeWithMin</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; c -&gt; d) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a c -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a d <a href="src/Streamly.Internal.Data.Fold.Type.html#teeWithMin" class="link">Source</a> <a href="#v:teeWithMin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Fold-Type.html#v:teeWith" title="Streamly.Internal.Data.Fold.Type">teeWith</a></code> but terminates as soon as any one of the two folds
 terminates.</p><p><em>Pre-release</em></p></div></div><a href="#g:11" id="g:11"><h2>Parallel Alternative</h2></a><div class="top"><p class="src"><a id="v:shortest" class="def">shortest</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) <a href="src/Streamly.Internal.Data.Fold.Type.html#shortest" class="link">Source</a> <a href="#v:shortest" class="selflink">#</a></p><div class="doc"><p>Shortest alternative. Apply both folds in parallel but choose the result
 from the one which consumed least input i.e. take the shortest succeeding
 fold.</p><p>If both the folds finish at the same time or if the result is extracted
 before any of the folds could finish then the left one is taken.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:longest" class="def">longest</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m x (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) <a href="src/Streamly.Internal.Data.Fold.Type.html#longest" class="link">Source</a> <a href="#v:longest" class="selflink">#</a></p><div class="doc"><p>Longest alternative. Apply both folds in parallel but choose the result
 from the one which consumed more input i.e. take the longest succeeding
 fold.</p><p>If both the folds finish at the same time or if the result is extracted
 before any of the folds could finish then the left one is taken.</p><p><em>Pre-release</em></p></div></div><a href="#g:12" id="g:12"><h2>Splitting</h2></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:ManyState" class="def">ManyState</a> s1 s2 <a href="src/Streamly.Internal.Data.Fold.Type.html#ManyState" class="link">Source</a> <a href="#t:ManyState" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:many" class="def">many</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a c <a href="src/Streamly.Internal.Data.Fold.Type.html#many" class="link">Source</a> <a href="#v:many" class="selflink">#</a></p><div class="doc"><p>Collect zero or more applications of a fold.  <code>many split collect</code> applies
 the <code>split</code> fold repeatedly on the input stream and accumulates zero or more
 fold results using <code>collect</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>two = Fold.take 2 Fold.toList
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>twos = Fold.many two Fold.toList
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.fold twos $ Stream.fromList [1..10]
</code></strong>[[1,2],[3,4],[5,6],[7,8],[9,10]]
</pre><p>Stops when <code>collect</code> stops.</p><p>See also: <code><a href="Streamly-Prelude.html#v:concatMap" title="Streamly.Prelude">concatMap</a></code>, <code><a href="Streamly-Prelude.html#v:foldMany" title="Streamly.Prelude">foldMany</a></code></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:manyPost" class="def">manyPost</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a c <a href="src/Streamly.Internal.Data.Fold.Type.html#manyPost" class="link">Source</a> <a href="#v:manyPost" class="selflink">#</a></p><div class="doc"><p>Like many, but inner fold emits an output at the end even if no input is
 received.</p><p><em>Internal</em></p><p><em>See also: <code><a href="Streamly-Prelude.html#v:concatMap" title="Streamly.Prelude">concatMap</a></code>, <code><a href="Streamly-Prelude.html#v:foldMany" title="Streamly.Prelude">foldMany</a></code></em></p></div></div><div class="top"><p class="src"><a id="v:chunksOf" class="def">chunksOf</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a c <a href="src/Streamly.Internal.Data.Fold.Type.html#chunksOf" class="link">Source</a> <a href="#v:chunksOf" class="selflink">#</a></p><div class="doc"><p><code>chunksOf n split collect</code> repeatedly applies the <code>split</code> fold to chunks
 of <code>n</code> items in the input stream and supplies the result to the <code>collect</code>
 fold.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>twos = Fold.chunksOf 2 Fold.toList Fold.toList
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.fold twos $ Stream.fromList [1..10]
</code></strong>[[1,2],[3,4],[5,6],[7,8],[9,10]]
</pre><pre>chunksOf n split = many (take n split)</pre><p>Stops when <code>collect</code> stops.</p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:refoldMany" class="def">refoldMany</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a> m x b c -&gt; <a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a> m x a c <a href="src/Streamly.Internal.Data.Fold.Type.html#refoldMany" class="link">Source</a> <a href="#v:refoldMany" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Fold-Type.html#v:many" title="Streamly.Internal.Data.Fold.Type">many</a></code> but uses a <code><a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a></code> for collecting.</p></div></div><div class="top"><p class="src"><a id="v:refoldMany1" class="def">refoldMany1</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a> m x a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a> m x a c <a href="src/Streamly.Internal.Data.Fold.Type.html#refoldMany1" class="link">Source</a> <a href="#v:refoldMany1" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Fold-Type.html#v:many" title="Streamly.Internal.Data.Fold.Type">many</a></code> but uses a <code><a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a></code> for splitting.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:refold" class="def">refold</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a> m b a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b <a href="src/Streamly.Internal.Data.Fold.Type.html#refold" class="link">Source</a> <a href="#v:refold" class="selflink">#</a></p><div class="doc"><p>Extract the output of a fold and refold it using a <code><a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a></code>.</p><p><em>Internal</em></p></div></div><a href="#g:13" id="g:13"><h2>Nesting</h2></a><div class="top"><p class="src"><a id="v:concatMap" class="def">concatMap</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a c) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a c <a href="src/Streamly.Internal.Data.Fold.Type.html#concatMap" class="link">Source</a> <a href="#v:concatMap" class="selflink">#</a></p><div class="doc"><p>Map a <code><a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a></code> returning function on the result of a <code><a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a></code> and run the
 returned fold. This operation can be used to express data dependencies
 between fold operations.</p><p>Let's say the first element in the stream is a count of the following
 elements that we have to add, then:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Data.Maybe (fromJust)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>count = fmap fromJust Fold.head
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>total n = Fold.take n Fold.sum
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.fold (Fold.concatMap total count) $ Stream.fromList [10,9..1]
</code></strong>45
</pre><p><em>Time: O(n^2) where <code>n</code> is the number of compositions.</em></p><p>See also: <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:foldIterateM" title="Streamly.Internal.Data.Stream.IsStream">foldIterateM</a></code></p><p><em>Since: 0.8.0</em></p></div></div><a href="#g:14" id="g:14"><h1>Running A Fold</h1></a><div class="top"><p class="src"><a id="v:initialize" class="def">initialize</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; m (<a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b) <a href="src/Streamly.Internal.Data.Fold.Type.html#initialize" class="link">Source</a> <a href="#v:initialize" class="selflink">#</a></p><div class="doc"><p>Run the initialization effect of a fold. The returned fold would use the
 value returned by this effect as its initial value.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:snoc" class="def">snoc</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; a -&gt; m (<a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b) <a href="src/Streamly.Internal.Data.Fold.Type.html#snoc" class="link">Source</a> <a href="#v:snoc" class="selflink">#</a></p><div class="doc"><p>Append a singleton value to the fold.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import qualified Data.Foldable as Foldable
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Foldable.foldlM Fold.snoc Fold.toList [1..3] &gt;&gt;= Fold.finish
</code></strong>[1,2,3]
</pre><p>Compare with <code><a href="Streamly-Internal-Data-Fold-Type.html#v:duplicate" title="Streamly.Internal.Data.Fold.Type">duplicate</a></code> which allows appending a stream to the fold.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:duplicate" class="def">duplicate</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a (<a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b) <a href="src/Streamly.Internal.Data.Fold.Type.html#duplicate" class="link">Source</a> <a href="#v:duplicate" class="selflink">#</a></p><div class="doc"><p><code><a href="Streamly-Internal-Data-Fold-Type.html#v:duplicate" title="Streamly.Internal.Data.Fold.Type">duplicate</a></code> provides the ability to run a fold in parts.  The duplicated
 fold consumes the input and returns the same fold as output instead of
 returning the final result, the returned fold can be run later to consume
 more input.</p><p>We can append a stream to a fold as follows:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>foldAppend :: Monad m =&gt; Fold m a b -&gt; SerialT m a -&gt; m (Fold m a b)
foldAppend f = Stream.fold (Fold.duplicate f)
:}
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>do
 sum1 &lt;- foldAppend Fold.sum (Stream.enumerateFromTo 1 10)
 sum2 &lt;- foldAppend sum1 (Stream.enumerateFromTo 11 20)
 Stream.fold sum2 (Stream.enumerateFromTo 21 30)
:}
465
</pre><p><code><a href="Streamly-Internal-Data-Fold-Type.html#v:duplicate" title="Streamly.Internal.Data.Fold.Type">duplicate</a></code> essentially appends a stream to the fold without finishing the
 fold.  Compare with <code><a href="Streamly-Internal-Data-Fold-Type.html#v:snoc" title="Streamly.Internal.Data.Fold.Type">snoc</a></code> which appends a singleton value to the fold.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:finish" class="def">finish</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; m b <a href="src/Streamly.Internal.Data.Fold.Type.html#finish" class="link">Source</a> <a href="#v:finish" class="selflink">#</a></p><div class="doc"><p>Finish the fold to extract the current value of the fold.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Fold.finish Fold.toList
</code></strong>[]
</pre><p><em>Pre-release</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.26.0</p></div></body></html>