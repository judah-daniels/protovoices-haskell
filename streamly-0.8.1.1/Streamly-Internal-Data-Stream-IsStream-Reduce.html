<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Streamly.Internal.Data.Stream.IsStream.Reduce</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">streamly-0.8.1.1: Dataflow programming and declarative concurrency</span><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2017 Composewell Technologies</td></tr><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Stream.IsStream.Reduce</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Reduce By Streams</a></li><li><a href="#g:2">Reduce By Folds</a><ul><li><a href="#g:3">Generic Folding</a></li><li><a href="#g:4">Chunking</a></li><li><a href="#g:5">Splitting</a></li><li><a href="#g:6">Keyed Window Classification</a><ul><li><a href="#g:7">Tumbling Windows</a></li><li><a href="#g:8">Keep Alive Windows</a></li></ul></li></ul></li><li><a href="#g:9">Reduce By Parsers</a><ul><li><a href="#g:10">Generic Parsing</a></li><li><a href="#g:11">Grouping</a></li></ul></li><li><a href="#g:12">Nested splitting</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Reduce streams by streams, folds or parsers.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:dropPrefix">dropPrefix</a> :: t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:dropInfix">dropInfix</a> :: t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:dropSuffix">dropSuffix</a> :: t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:foldMany">foldMany</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:foldManyPost">foldManyPost</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:refoldMany">refoldMany</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a> m c a b -&gt; m c -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:foldSequence">foldSequence</a> :: t m (<a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:foldIterateM">foldIterateM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; m (<a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b)) -&gt; m b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:refoldIterateM">refoldIterateM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a> m b a b -&gt; m b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:chunksOf">chunksOf</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:arraysOf">arraysOf</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="../base-4.16.4.0/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m (<a href="Streamly-Internal-Data-Array-Foreign-Type.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Type">Array</a> a)</li><li class="src short"><a href="#v:intervalsOf">intervalsOf</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:chunksOfTimeout">chunksOfTimeout</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitOn">splitOn</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitOnSuffix">splitOnSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitOnPrefix">splitOnPrefix</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitWithSuffix">splitWithSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitBySeq">splitBySeq</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="../base-4.16.4.0/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Foreign-Type.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Type">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitOnSeq">splitOnSeq</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="../base-4.16.4.0/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="../base-4.16.4.0/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Foreign-Type.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Type">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitOnSuffixSeq">splitOnSuffixSeq</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="../base-4.16.4.0/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="../base-4.16.4.0/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Foreign-Type.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Type">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitWithSuffixSeq">splitWithSuffixSeq</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="../base-4.16.4.0/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="../base-4.16.4.0/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Foreign-Type.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Type">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:classifySessionsBy">classifySessionsBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; (<a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>, (k, a)) -&gt; t m (k, b)</li><li class="src short"><a href="#v:classifySessionsOf">classifySessionsOf</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; (<a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>, (k, a)) -&gt; t m (k, b)</li><li class="src short"><a href="#v:classifyKeepAliveSessions">classifyKeepAliveSessions</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; (<a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>, (k, a)) -&gt; t m (k, b)</li><li class="src short"><a href="#v:parseMany">parseMany</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../exceptions-0.10.4/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m) =&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Type.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Type">Parser</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:parseManyD">parseManyD</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../exceptions-0.10.4/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m) =&gt; <a href="Streamly-Internal-Data-Parser-ParserD-Type.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserD.Type">Parser</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:parseManyTill">parseManyTill</a> :: <a href="Streamly-Internal-Data-Parser-ParserK-Type.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Type">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Type.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Type">Parser</a> m a x -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:parseSequence">parseSequence</a> :: t m (<a href="Streamly-Internal-Data-Parser-ParserK-Type.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Type">Parser</a> m a b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:parseIterate">parseIterate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../exceptions-0.10.4/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m) =&gt; (b -&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Type.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Type">Parser</a> m a b) -&gt; b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:wordsBy">wordsBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:groups">groups</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:groupsBy">groupsBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:groupsByRolling">groupsByRolling</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitInnerBy">splitInnerBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (f a -&gt; m (f a, <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (f a))) -&gt; (f a -&gt; f a -&gt; m (f a)) -&gt; t m (f a) -&gt; t m (f a)</li><li class="src short"><a href="#v:splitInnerBySuffix">splitInnerBySuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> (f a), <a href="../base-4.16.4.0/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (f a)) =&gt; (f a -&gt; m (f a, <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (f a))) -&gt; (f a -&gt; f a -&gt; m (f a)) -&gt; t m (f a) -&gt; t m (f a)</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Reduce By Streams</h1></a><div class="top"><p class="src"><a id="v:dropPrefix" class="def">dropPrefix</a> :: t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#dropPrefix" class="link">Source</a> <a href="#v:dropPrefix" class="selflink">#</a></p><div class="doc"><p>Drop prefix from the input stream if present.</p><p>Space: <code>O(1)</code></p><p><em>Unimplemented</em> - Help wanted.</p></div></div><div class="top"><p class="src"><a id="v:dropInfix" class="def">dropInfix</a> :: t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#dropInfix" class="link">Source</a> <a href="#v:dropInfix" class="selflink">#</a></p><div class="doc"><p>Drop all matching infix from the input stream if present. Infix stream
 may be consumed multiple times.</p><p>Space: <code>O(n)</code> where n is the length of the infix.</p><p><em>Unimplemented</em> - Help wanted.</p></div></div><div class="top"><p class="src"><a id="v:dropSuffix" class="def">dropSuffix</a> :: t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#dropSuffix" class="link">Source</a> <a href="#v:dropSuffix" class="selflink">#</a></p><div class="doc"><p>Drop suffix from the input stream if present. Suffix stream may be
 consumed multiple times.</p><p>Space: <code>O(n)</code> where n is the length of the suffix.</p><p><em>Unimplemented</em> - Help wanted.</p></div></div><a href="#g:2" id="g:2"><h1>Reduce By Folds</h1></a><div class="doc"><p>Reduce a stream by folding or parsing chunks of the stream.  Functions
 generally ending in these shapes:</p><pre>f (Fold m a b) -&gt; t m a -&gt; t m b
f (Parser m a b) -&gt; t m a -&gt; t m b
</pre></div><a href="#g:3" id="g:3"><h2>Generic Folding</h2></a><div class="doc"><p>Apply folds on a stream.</p></div><div class="top"><p class="src"><a id="v:foldMany" class="def">foldMany</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#foldMany" class="link">Source</a> <a href="#v:foldMany" class="selflink">#</a></p><div class="doc"><p>Apply a <code><a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a></code> repeatedly on a stream and emit the fold outputs in the
 output stream.</p><p>To sum every two contiguous elements in a stream:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>f = Fold.take 2 Fold.sum
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.foldMany f $ Stream.fromList [1..10]
</code></strong>[3,7,11,15,19]
</pre><p>On an empty stream the output is empty:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.foldMany f $ Stream.fromList []
</code></strong>[]
</pre><p>Note <code>Stream.foldMany (Fold.take 0)</code> would result in an infinite loop in a
 non-empty stream.</p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:foldManyPost" class="def">foldManyPost</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#foldManyPost" class="link">Source</a> <a href="#v:foldManyPost" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Reduce.html#v:foldMany" title="Streamly.Internal.Data.Stream.IsStream.Reduce">foldMany</a></code> but appends empty fold output if the fold and stream
 termination aligns:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>f = Fold.take 2 Fold.sum
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.foldManyPost f $ Stream.fromList []
</code></strong>[0]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.foldManyPost f $ Stream.fromList [1..9]
</code></strong>[3,7,11,15,9]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.foldManyPost f $ Stream.fromList [1..10]
</code></strong>[3,7,11,15,19,0]
</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:refoldMany" class="def">refoldMany</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a> m c a b -&gt; m c -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#refoldMany" class="link">Source</a> <a href="#v:refoldMany" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Reduce.html#v:foldMany" title="Streamly.Internal.Data.Stream.IsStream.Reduce">foldMany</a></code> but using the <code><a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a></code> type instead of <code><a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a></code>.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:foldSequence" class="def">foldSequence</a> :: t m (<a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#foldSequence" class="link">Source</a> <a href="#v:foldSequence" class="selflink">#</a></p><div class="doc"><p>Apply a stream of folds to an input stream and emit the results in the
 output stream.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:foldIterateM" class="def">foldIterateM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; m (<a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b)) -&gt; m b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#foldIterateM" class="link">Source</a> <a href="#v:foldIterateM" class="selflink">#</a></p><div class="doc"><p>Iterate a fold generator on a stream. The initial value <code>b</code> is used to
 generate the first fold, the fold is applied on the stream and the result of
 the fold is used to generate the next fold and so on.</p><pre>&gt;&gt;&gt; import Data.Monoid (Sum(..))
&gt;&gt;&gt; f x = return (Fold.take 2 (Fold.sconcat x))
&gt;&gt;&gt; s = Stream.map Sum $ Stream.fromList [1..10]
&gt;&gt;&gt; Stream.toList $ Stream.map getSum $ Stream.foldIterateM f (pure 0) s
[3,10,21,36,55,55]

</pre><p>This is the streaming equivalent of monad like sequenced application of
 folds where next fold is dependent on the previous fold.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:refoldIterateM" class="def">refoldIterateM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a> m b a b -&gt; m b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#refoldIterateM" class="link">Source</a> <a href="#v:refoldIterateM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Reduce.html#v:foldIterateM" title="Streamly.Internal.Data.Stream.IsStream.Reduce">foldIterateM</a></code> but using the <code><a href="Streamly-Internal-Data-Refold-Type.html#t:Refold" title="Streamly.Internal.Data.Refold.Type">Refold</a></code> type instead. This could be
 much more efficient due to stream fusion.</p><p><em>Internal</em></p></div></div><a href="#g:4" id="g:4"><h2>Chunking</h2></a><div class="doc"><p>Element unaware grouping.</p></div><div class="top"><p class="src"><a id="v:chunksOf" class="def">chunksOf</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#chunksOf" class="link">Source</a> <a href="#v:chunksOf" class="selflink">#</a></p><div class="doc"><p>Group the input stream into groups of <code>n</code> elements each and then fold each
 group using the provided fold function.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.chunksOf 2 Fold.sum (Stream.enumerateFromTo 1 10)
</code></strong>[3,7,11,15,19]
</pre><p>This can be considered as an n-fold version of <code><a href="../base-4.16.4.0/GHC-List.html#v:take" title="GHC.List">take</a></code> where we apply
 <code><a href="../base-4.16.4.0/GHC-List.html#v:take" title="GHC.List">take</a></code> repeatedly on the leftover stream until the stream exhausts.</p><pre>chunksOf n f = foldMany (FL.take n f)</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:arraysOf" class="def">arraysOf</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="../base-4.16.4.0/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m (<a href="Streamly-Internal-Data-Array-Foreign-Type.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Type">Array</a> a) <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#arraysOf" class="link">Source</a> <a href="#v:arraysOf" class="selflink">#</a></p><div class="doc"><p><code>arraysOf n stream</code> groups the elements in the input stream into arrays of
 <code>n</code> elements each.</p><p>Same as the following but may be more efficient:</p><pre>arraysOf n = Stream.foldMany (A.writeN n)</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:intervalsOf" class="def">intervalsOf</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#intervalsOf" class="link">Source</a> <a href="#v:intervalsOf" class="selflink">#</a></p><div class="doc"><p>Group the input stream into windows of <code>n</code> second each and then fold each
 group using the provided fold function.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.take 5 $ Stream.intervalsOf 1 Fold.sum $ Stream.constRate 2 $ Stream.enumerateFrom 1
</code></strong>[...,...,...,...,...]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:chunksOfTimeout" class="def">chunksOfTimeout</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#chunksOfTimeout" class="link">Source</a> <a href="#v:chunksOfTimeout" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Reduce.html#v:chunksOf" title="Streamly.Internal.Data.Stream.IsStream.Reduce">chunksOf</a></code> but if the chunk is not completed within the specified
 time interval then emit whatever we have collected till now. The chunk
 timeout is reset whenever a chunk is emitted.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>s = Stream.delayPost 0.3 $ Stream.fromList [1..1000]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>f = Stream.mapM_ print $ Stream.chunksOfTimeout 5 1 Fold.toList s
</code></strong></pre><p><em>Pre-release</em></p></div></div><a href="#g:5" id="g:5"><h2>Splitting</h2></a><div class="doc"><p>Streams can be sliced into segments in space or in time. We use the
 term <code>chunk</code> to refer to a spatial length of the stream (spatial window)
 and the term <code>session</code> to refer to a length in time (time window).</p></div><div class="top"><p class="src"><a id="v:splitOn" class="def">splitOn</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#splitOn" class="link">Source</a> <a href="#v:splitOn" class="selflink">#</a></p><div class="doc"><p>Split on an infixed separator element, dropping the separator.  The
 supplied <code><a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a></code> is applied on the split segments.  Splits the stream on
 separator elements determined by the supplied predicate, separator is
 considered as infixed between two segments:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' p xs = Stream.toList $ Stream.splitOn p Fold.toList (Stream.fromList xs)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;a.b&quot;
</code></strong>[&quot;a&quot;,&quot;b&quot;]
</pre><p>An empty stream is folded to the default value of the fold:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;&quot;
</code></strong>[&quot;&quot;]
</pre><p>If one or both sides of the separator are missing then the empty segment on
 that side is folded to the default output of the fold:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;.&quot;
</code></strong>[&quot;&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;.a&quot;
</code></strong>[&quot;&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;a.&quot;
</code></strong>[&quot;a&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;a..b&quot;
</code></strong>[&quot;a&quot;,&quot;&quot;,&quot;b&quot;]
</pre><p>splitOn is an inverse of intercalating single element:</p><pre>Stream.intercalate (Stream.fromPure '.') Unfold.fromList . Stream.splitOn (== '.') Fold.toList === id</pre><p>Assuming the input stream does not contain the separator:</p><pre>Stream.splitOn (== '.') Fold.toList . Stream.intercalate (Stream.fromPure '.') Unfold.fromList === id</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:splitOnSuffix" class="def">splitOnSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#splitOnSuffix" class="link">Source</a> <a href="#v:splitOnSuffix" class="selflink">#</a></p><div class="doc"><p>Split on a suffixed separator element, dropping the separator.  The
 supplied <code><a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a></code> is applied on the split segments.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' p xs = Stream.toList $ Stream.splitOnSuffix p Fold.toList (Stream.fromList xs)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;a.b.&quot;
</code></strong>[&quot;a&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;a.&quot;
</code></strong>[&quot;a&quot;]
</pre><p>An empty stream results in an empty output stream:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;&quot;
</code></strong>[]
</pre><p>An empty segment consisting of only a suffix is folded to the default output
 of the fold:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;.&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;a..b..&quot;
</code></strong>[&quot;a&quot;,&quot;&quot;,&quot;b&quot;,&quot;&quot;]
</pre><p>A suffix is optional at the end of the stream:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;a&quot;
</code></strong>[&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;.a&quot;
</code></strong>[&quot;&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;a.b&quot;
</code></strong>[&quot;a&quot;,&quot;b&quot;]
</pre><pre>lines = splitOnSuffix (== '\n')</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Reduce.html#v:splitOnSuffix" title="Streamly.Internal.Data.Stream.IsStream.Reduce">splitOnSuffix</a></code> is an inverse of <code>intercalateSuffix</code> with a single element:</p><pre>Stream.intercalateSuffix (Stream.fromPure '.') Unfold.fromList . Stream.splitOnSuffix (== '.') Fold.toList === id</pre><p>Assuming the input stream does not contain the separator:</p><pre>Stream.splitOnSuffix (== '.') Fold.toList . Stream.intercalateSuffix (Stream.fromPure '.') Unfold.fromList === id</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:splitOnPrefix" class="def">splitOnPrefix</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#splitOnPrefix" class="link">Source</a> <a href="#v:splitOnPrefix" class="selflink">#</a></p><div class="doc"><p>Split on a prefixed separator element, dropping the separator.  The
 supplied <code><a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a></code> is applied on the split segments.</p><pre>&gt; splitOnPrefix' p xs = Stream.toList $ Stream.splitOnPrefix p (Fold.toList) (Stream.fromList xs)
&gt; splitOnPrefix' (== <code><a href="../base-4.16.4.0/Data-Function.html#v:." title="Data.Function">.</a></code>) &quot;.a.b&quot;
[&quot;a&quot;,&quot;b&quot;]
</pre><p>An empty stream results in an empty output stream:
 <code>
 &gt; splitOnPrefix' (== <code><a href="../base-4.16.4.0/Data-Function.html#v:." title="Data.Function">.</a></code>) &quot;&quot;
 []
 </code></p><p>An empty segment consisting of only a prefix is folded to the default output
 of the fold:</p><pre>&gt; splitOnPrefix' (== <code><a href="../base-4.16.4.0/Data-Function.html#v:." title="Data.Function">.</a></code>) &quot;.&quot;
[&quot;&quot;]

&gt; splitOnPrefix' (== <code><a href="../base-4.16.4.0/Data-Function.html#v:." title="Data.Function">.</a></code>) &quot;.a.b.&quot;
[&quot;a&quot;,&quot;b&quot;,&quot;&quot;]

&gt; splitOnPrefix' (== <code><a href="../base-4.16.4.0/Data-Function.html#v:." title="Data.Function">.</a></code>) &quot;.a..b&quot;
[&quot;a&quot;,&quot;&quot;,&quot;b&quot;]

</pre><p>A prefix is optional at the beginning of the stream:</p><pre>&gt; splitOnPrefix' (== <code><a href="../base-4.16.4.0/Data-Function.html#v:." title="Data.Function">.</a></code>) &quot;a&quot;
[&quot;a&quot;]

&gt; splitOnPrefix' (== <code><a href="../base-4.16.4.0/Data-Function.html#v:." title="Data.Function">.</a></code>) &quot;a.b&quot;
[&quot;a&quot;,&quot;b&quot;]
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Reduce.html#v:splitOnPrefix" title="Streamly.Internal.Data.Stream.IsStream.Reduce">splitOnPrefix</a></code> is an inverse of <code>intercalatePrefix</code> with a single element:</p><pre>Stream.intercalatePrefix (Stream.fromPure '.') Unfold.fromList . Stream.splitOnPrefix (== '.') Fold.toList === id</pre><p>Assuming the input stream does not contain the separator:</p><pre>Stream.splitOnPrefix (== '.') Fold.toList . Stream.intercalatePrefix (Stream.fromPure '.') Unfold.fromList === id</pre><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:splitWithSuffix" class="def">splitWithSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#splitWithSuffix" class="link">Source</a> <a href="#v:splitWithSuffix" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Reduce.html#v:splitOnSuffix" title="Streamly.Internal.Data.Stream.IsStream.Reduce">splitOnSuffix</a></code> but keeps the suffix attached to the resulting
 splits.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' p xs = Stream.toList $ splitWithSuffix p Fold.toList (Stream.fromList xs)
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;&quot;
</code></strong>[]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;.&quot;
</code></strong>[&quot;.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;a&quot;
</code></strong>[&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;.a&quot;
</code></strong>[&quot;.&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;a.&quot;
</code></strong>[&quot;a.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;a.b&quot;
</code></strong>[&quot;a.&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;a.b.&quot;
</code></strong>[&quot;a.&quot;,&quot;b.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;a..b..&quot;
</code></strong>[&quot;a.&quot;,&quot;.&quot;,&quot;b.&quot;,&quot;.&quot;]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:splitBySeq" class="def">splitBySeq</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="../base-4.16.4.0/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Foreign-Type.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Type">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#splitBySeq" class="link">Source</a> <a href="#v:splitBySeq" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Reduce.html#v:splitOnSeq" title="Streamly.Internal.Data.Stream.IsStream.Reduce">splitOnSeq</a></code> but splits the separator as well, as an infix token.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ pat xs = Stream.toList $ Stream.splitBySeq (Array.fromList pat) Fold.toList (Stream.fromList xs)
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;&quot; &quot;hello&quot;
</code></strong>[&quot;h&quot;,&quot;&quot;,&quot;e&quot;,&quot;&quot;,&quot;l&quot;,&quot;&quot;,&quot;l&quot;,&quot;&quot;,&quot;o&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;hello&quot; &quot;&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;hello&quot; &quot;hello&quot;
</code></strong>[&quot;&quot;,&quot;hello&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;x&quot; &quot;hello&quot;
</code></strong>[&quot;hello&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;h&quot; &quot;hello&quot;
</code></strong>[&quot;&quot;,&quot;h&quot;,&quot;ello&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;o&quot; &quot;hello&quot;
</code></strong>[&quot;hell&quot;,&quot;o&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;e&quot; &quot;hello&quot;
</code></strong>[&quot;h&quot;,&quot;e&quot;,&quot;llo&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;l&quot; &quot;hello&quot;
</code></strong>[&quot;he&quot;,&quot;l&quot;,&quot;&quot;,&quot;l&quot;,&quot;o&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;ll&quot; &quot;hello&quot;
</code></strong>[&quot;he&quot;,&quot;ll&quot;,&quot;o&quot;]
</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:splitOnSeq" class="def">splitOnSeq</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="../base-4.16.4.0/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="../base-4.16.4.0/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Foreign-Type.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Type">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#splitOnSeq" class="link">Source</a> <a href="#v:splitOnSeq" class="selflink">#</a></p><div class="doc"><p>Like <code>splitOn</code> but the separator is a sequence of elements instead of a
 single element.</p><p>For illustration, let's define a function that operates on pure lists:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' pat xs = Stream.toList $ Stream.splitOnSeq (Array.fromList pat) Fold.toList (Stream.fromList xs)
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;&quot; &quot;hello&quot;
</code></strong>[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;hello&quot; &quot;&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;hello&quot; &quot;hello&quot;
</code></strong>[&quot;&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;x&quot; &quot;hello&quot;
</code></strong>[&quot;hello&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;h&quot; &quot;hello&quot;
</code></strong>[&quot;&quot;,&quot;ello&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;o&quot; &quot;hello&quot;
</code></strong>[&quot;hell&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;e&quot; &quot;hello&quot;
</code></strong>[&quot;h&quot;,&quot;llo&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;l&quot; &quot;hello&quot;
</code></strong>[&quot;he&quot;,&quot;&quot;,&quot;o&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;ll&quot; &quot;hello&quot;
</code></strong>[&quot;he&quot;,&quot;o&quot;]
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Reduce.html#v:splitOnSeq" title="Streamly.Internal.Data.Stream.IsStream.Reduce">splitOnSeq</a></code> is an inverse of <code>intercalate</code>. The following law always holds:</p><pre>intercalate . splitOnSeq == id</pre><p>The following law holds when the separator is non-empty and contains none of
 the elements present in the input lists:</p><pre>splitOnSeq . intercalate == id</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:splitOnSuffixSeq" class="def">splitOnSuffixSeq</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="../base-4.16.4.0/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="../base-4.16.4.0/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Foreign-Type.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Type">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#splitOnSuffixSeq" class="link">Source</a> <a href="#v:splitOnSuffixSeq" class="selflink">#</a></p><div class="doc"><p>Like <code>splitSuffixBy</code> but the separator is a sequence of elements, instead
 of a predicate for a single element.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffixSeq_ pat xs = Stream.toList $ Stream.splitOnSuffixSeq (Array.fromList pat) Fold.toList (Stream.fromList xs)
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffixSeq_ &quot;.&quot; &quot;&quot;
</code></strong>[]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffixSeq_ &quot;.&quot; &quot;.&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffixSeq_ &quot;.&quot; &quot;a&quot;
</code></strong>[&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffixSeq_ &quot;.&quot; &quot;.a&quot;
</code></strong>[&quot;&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffixSeq_ &quot;.&quot; &quot;a.&quot;
</code></strong>[&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffixSeq_ &quot;.&quot; &quot;a.b&quot;
</code></strong>[&quot;a&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffixSeq_ &quot;.&quot; &quot;a.b.&quot;
</code></strong>[&quot;a&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffixSeq_ &quot;.&quot; &quot;a..b..&quot;
</code></strong>[&quot;a&quot;,&quot;&quot;,&quot;b&quot;,&quot;&quot;]
</pre><pre>lines = splitOnSuffixSeq &quot;\n&quot;</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Reduce.html#v:splitOnSuffixSeq" title="Streamly.Internal.Data.Stream.IsStream.Reduce">splitOnSuffixSeq</a></code> is an inverse of <code>intercalateSuffix</code>. The following law
 always holds:</p><pre>intercalateSuffix . splitOnSuffixSeq == id</pre><p>The following law holds when the separator is non-empty and contains none of
 the elements present in the input lists:</p><pre>splitSuffixOn . intercalateSuffix == id</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:splitWithSuffixSeq" class="def">splitWithSuffixSeq</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="../base-4.16.4.0/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="../base-4.16.4.0/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Foreign-Type.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Type">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#splitWithSuffixSeq" class="link">Source</a> <a href="#v:splitWithSuffixSeq" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Reduce.html#v:splitOnSuffixSeq" title="Streamly.Internal.Data.Stream.IsStream.Reduce">splitOnSuffixSeq</a></code> but keeps the suffix intact in the splits.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffixSeq' pat xs = Stream.toList $ Stream.splitWithSuffixSeq (Array.fromList pat) Fold.toList (Stream.fromList xs)
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffixSeq' &quot;.&quot; &quot;&quot;
</code></strong>[]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffixSeq' &quot;.&quot; &quot;.&quot;
</code></strong>[&quot;.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffixSeq' &quot;.&quot; &quot;a&quot;
</code></strong>[&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffixSeq' &quot;.&quot; &quot;.a&quot;
</code></strong>[&quot;.&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffixSeq' &quot;.&quot; &quot;a.&quot;
</code></strong>[&quot;a.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffixSeq' &quot;.&quot; &quot;a.b&quot;
</code></strong>[&quot;a.&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffixSeq' &quot;.&quot; &quot;a.b.&quot;
</code></strong>[&quot;a.&quot;,&quot;b.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffixSeq' &quot;.&quot; &quot;a..b..&quot;
</code></strong>[&quot;a.&quot;,&quot;.&quot;,&quot;b.&quot;,&quot;.&quot;]
</pre><p><em>Pre-release</em></p></div></div><a href="#g:6" id="g:6"><h2>Keyed Window Classification</h2></a><div class="doc"><p>Split the stream into chunks or windows by position or time. Each
 window can be associated with a key, all events associated with a
 particular key in the window can be folded to a single result.  The
 window termination can be dynamically controlled by the fold.</p><p>The term &quot;chunk&quot; is used for a window defined by position of elements
 and the term &quot;session&quot; is used for a time window.</p></div><a href="#g:7" id="g:7"><h3>Tumbling Windows</h3></a><div class="doc"><p>A new window starts after the previous window is finished.</p></div><div class="top"><p class="src"><a id="v:classifySessionsBy" class="def">classifySessionsBy</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#classifySessionsBy" class="link">Source</a> <a href="#v:classifySessionsBy" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a></td><td class="doc"><p>timer tick in seconds</p></td></tr><tr><td class="src">-&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></td><td class="doc"><p>reset the timer when an event is received</p></td></tr><tr><td class="src">-&gt; (<a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>)</td><td class="doc"><p>predicate to eject sessions based on session count</p></td></tr><tr><td class="src">-&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a></td><td class="doc"><p>session timeout in seconds</p></td></tr><tr><td class="src">-&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b</td><td class="doc"><p>Fold to be applied to session data</p></td></tr><tr><td class="src">-&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>, (k, a))</td><td class="doc"><p>timestamp, (session key, session data)</p></td></tr><tr><td class="src">-&gt; t m (k, b)</td><td class="doc"><p>session key, fold result</p></td></tr></table></div><div class="doc"><p><code>classifySessionsBy tick keepalive predicate timeout fold stream</code>
 classifies an input event <code>stream</code> consisting of  <code>(timestamp, (key,
 value))</code> into sessions based on the <code>key</code>, folding all the values
 corresponding to the same key into a session using the supplied <code>fold</code>.</p><p>When the fold terminates or a <code>timeout</code> occurs, a tuple consisting of the
 session key and the folded value is emitted in the output stream. The
 timeout is measured from the first event in the session.  If the <code>keepalive</code>
 option is set to <code><a href="../base-4.16.4.0/Data-Bool.html#v:True" title="Data.Bool">True</a></code> the timeout is reset to 0 whenever an event is
 received.</p><p>The <code>timestamp</code> in the input stream is an absolute time from some epoch,
 characterizing the time when the input event was generated.  The notion of
 current time is maintained by a monotonic event time clock using the
 timestamps seen in the input stream. The latest timestamp seen till now is
 used as the base for the current time.  When no new events are seen, a timer
 is started with a clock resolution of <code>tick</code> seconds. This timer is used to
 detect session timeouts in the absence of new events.</p><p>To ensure an upper bound on the memory used the number of sessions can be
 limited to an upper bound. If the ejection <code>predicate</code> returns <code><a href="../base-4.16.4.0/Data-Bool.html#v:True" title="Data.Bool">True</a></code>, the
 oldest session is ejected before inserting a new session.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>Stream.mapM_ print
    $ Stream.classifySessionsBy 1 False (const (return False)) 3 (Fold.take 3 Fold.toList)
    $ Stream.timestamped
    $ Stream.delay 0.1
    $ (,) &lt;$&gt; Stream.fromList [1,2,3] &lt;*&gt; Stream.fromList ['a','b','c']
:}
(1,&quot;abc&quot;)
(2,&quot;abc&quot;)
(3,&quot;abc&quot;)
</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:classifySessionsOf" class="def">classifySessionsOf</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#classifySessionsOf" class="link">Source</a> <a href="#v:classifySessionsOf" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (<a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>)</td><td class="doc"><p>predicate to eject sessions on session count</p></td></tr><tr><td class="src">-&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a></td><td class="doc"><p>time window size</p></td></tr><tr><td class="src">-&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b</td><td class="doc"><p>Fold to be applied to session data</p></td></tr><tr><td class="src">-&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>, (k, a))</td><td class="doc"><p>timestamp, (session key, session data)</p></td></tr><tr><td class="src">-&gt; t m (k, b)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Same as <code><a href="Streamly-Internal-Data-Stream-IsStream-Reduce.html#v:classifySessionsBy" title="Streamly.Internal.Data.Stream.IsStream.Reduce">classifySessionsBy</a></code> with a timer tick of 1 second and keepalive
 option set to <code><a href="../base-4.16.4.0/Data-Bool.html#v:False" title="Data.Bool">False</a></code>.</p><pre>classifySessionsOf = classifySessionsBy 1 False
</pre><p><em>Pre-release</em></p></div></div><a href="#g:8" id="g:8"><h3>Keep Alive Windows</h3></a><div class="doc"><p>The window size is extended if an event arrives within the specified
 window size. This can represent sessions with idle or inactive timeout.</p></div><div class="top"><p class="src"><a id="v:classifyKeepAliveSessions" class="def">classifyKeepAliveSessions</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#classifyKeepAliveSessions" class="link">Source</a> <a href="#v:classifyKeepAliveSessions" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (<a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>)</td><td class="doc"><p>predicate to eject sessions on session count</p></td></tr><tr><td class="src">-&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a></td><td class="doc"><p>session inactive timeout</p></td></tr><tr><td class="src">-&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b</td><td class="doc"><p>Fold to be applied to session payload data</p></td></tr><tr><td class="src">-&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>, (k, a))</td><td class="doc"><p>timestamp, (session key, session data)</p></td></tr><tr><td class="src">-&gt; t m (k, b)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Same as <code><a href="Streamly-Internal-Data-Stream-IsStream-Reduce.html#v:classifySessionsBy" title="Streamly.Internal.Data.Stream.IsStream.Reduce">classifySessionsBy</a></code> with a timer tick of 1 second and keepalive
 option set to <code><a href="../base-4.16.4.0/Data-Bool.html#v:True" title="Data.Bool">True</a></code>.</p><pre>classifyKeepAliveSessions = classifySessionsBy 1 True
</pre><p><em>Pre-release</em></p></div></div><a href="#g:9" id="g:9"><h1>Reduce By Parsers</h1></a><a href="#g:10" id="g:10"><h2>Generic Parsing</h2></a><div class="doc"><p>Apply parsers on a stream.</p></div><div class="top"><p class="src"><a id="v:parseMany" class="def">parseMany</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../exceptions-0.10.4/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m) =&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Type.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Type">Parser</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#parseMany" class="link">Source</a> <a href="#v:parseMany" class="selflink">#</a></p><div class="doc"><p>Apply a <code><a href="Streamly-Internal-Data-Parser-ParserK-Type.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Type">Parser</a></code> repeatedly on a stream and emit the parsed values in the
 output stream.</p><p>This is the streaming equivalent of the <code><a href="Streamly-Internal-Data-Parser.html#v:many" title="Streamly.Internal.Data.Parser">many</a></code>
 parse combinator.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.parseMany (Parser.takeBetween 0 2 Fold.sum) $ Stream.fromList [1..10]
</code></strong>[3,7,11,15,19]
</pre><pre>&gt; Stream.toList $ Stream.parseMany (Parser.line Fold.toList) $ Stream.fromList &quot;hello\nworld&quot;
[&quot;hello\n&quot;,&quot;world&quot;]

</pre><pre>foldMany f = parseMany (fromFold f)
</pre><p>Known Issues: When the parser fails there is no way to get the remaining
 stream.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:parseManyD" class="def">parseManyD</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../exceptions-0.10.4/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m) =&gt; <a href="Streamly-Internal-Data-Parser-ParserD-Type.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserD.Type">Parser</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#parseManyD" class="link">Source</a> <a href="#v:parseManyD" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:parseManyTill" class="def">parseManyTill</a> :: <a href="Streamly-Internal-Data-Parser-ParserK-Type.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Type">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Type.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Type">Parser</a> m a x -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#parseManyTill" class="link">Source</a> <a href="#v:parseManyTill" class="selflink">#</a></p><div class="doc"><p><code>parseManyTill collect test stream</code> tries the parser <code>test</code> on the input,
 if <code>test</code> fails it backtracks and tries <code>collect</code>, after <code>collect</code> succeeds
 <code>test</code> is tried again and so on. The parser stops when <code>test</code> succeeds.  The
 output of <code>test</code> is discarded and the output of <code>collect</code> is emitted in the
 output stream. The parser fails if <code>collect</code> fails.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:parseSequence" class="def">parseSequence</a> :: t m (<a href="Streamly-Internal-Data-Parser-ParserK-Type.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Type">Parser</a> m a b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#parseSequence" class="link">Source</a> <a href="#v:parseSequence" class="selflink">#</a></p><div class="doc"><p>Apply a stream of parsers to an input stream and emit the results in the
 output stream.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:parseIterate" class="def">parseIterate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../exceptions-0.10.4/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m) =&gt; (b -&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Type.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Type">Parser</a> m a b) -&gt; b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#parseIterate" class="link">Source</a> <a href="#v:parseIterate" class="selflink">#</a></p><div class="doc"><p>Iterate a parser generating function on a stream. The initial value <code>b</code> is
 used to generate the first parser, the parser is applied on the stream and
 the result is used to generate the next parser and so on.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Data.Monoid (Sum(..))
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.map getSum $ Stream.parseIterate (\b -&gt; Parser.takeBetween 0 2 (Fold.sconcat b)) 0 $ Stream.map Sum $ Stream.fromList [1..10]
</code></strong>[3,10,21,36,55,55]
</pre><p>This is the streaming equivalent of monad like sequenced application of
 parsers where next parser is dependent on the previous parser.</p><p><em>Pre-release</em></p></div></div><a href="#g:11" id="g:11"><h2>Grouping</h2></a><div class="top"><p class="src"><a id="v:wordsBy" class="def">wordsBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#wordsBy" class="link">Source</a> <a href="#v:wordsBy" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Reduce.html#v:splitOn" title="Streamly.Internal.Data.Stream.IsStream.Reduce">splitOn</a></code> after stripping leading, trailing, and repeated separators.
 Therefore, <code>&quot;.a..b.&quot;</code> with <code><a href="../base-4.16.4.0/Data-Function.html#v:." title="Data.Function">.</a></code> as the separator would be parsed as
 <code>[&quot;a&quot;,&quot;b&quot;]</code>.  In other words, its like parsing words from whitespace
 separated text.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>wordsBy' p xs = Stream.toList $ Stream.wordsBy p Fold.toList (Stream.fromList xs)
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>wordsBy' (== ',') &quot;&quot;
</code></strong>[]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>wordsBy' (== ',') &quot;,&quot;
</code></strong>[]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>wordsBy' (== ',') &quot;,a,,b,&quot;
</code></strong>[&quot;a&quot;,&quot;b&quot;]
</pre><pre>words = wordsBy isSpace</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:groups" class="def">groups</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#groups" class="link">Source</a> <a href="#v:groups" class="selflink">#</a></p><div class="doc"><pre>groups = groupsBy (==)
groups = groupsByRolling (==)</pre><p>Groups contiguous spans of equal elements together in individual groups.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.groups Fold.toList $ Stream.fromList [1,1,2,2]
</code></strong>[[1,1],[2,2]]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:groupsBy" class="def">groupsBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#groupsBy" class="link">Source</a> <a href="#v:groupsBy" class="selflink">#</a></p><div class="doc"><p><code>groupsBy cmp f $ S.fromList [a,b,c,...]</code> assigns the element <code>a</code> to the
 first group, if <code>b `cmp` a</code> is <code><a href="../base-4.16.4.0/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then <code>b</code> is also assigned to the same
 group.  If <code>c `cmp` a</code> is <code><a href="../base-4.16.4.0/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then <code>c</code> is also assigned to the same
 group and so on. When the comparison fails a new group is started. Each
 group is folded using the fold <code>f</code> and the result of the fold is emitted in
 the output stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.groupsBy (&gt;) Fold.toList $ Stream.fromList [1,3,7,0,2,5]
</code></strong>[[1,3,7],[0,2,5]]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:groupsByRolling" class="def">groupsByRolling</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#groupsByRolling" class="link">Source</a> <a href="#v:groupsByRolling" class="selflink">#</a></p><div class="doc"><p>Unlike <code>groupsBy</code> this function performs a rolling comparison of two
 successive elements in the input stream. <code>groupsByRolling cmp f $ S.fromList
 [a,b,c,...]</code> assigns the element <code>a</code> to the first group, if <code>a `cmp` b</code> is
 <code><a href="../base-4.16.4.0/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then <code>b</code> is also assigned to the same group.  If <code>b `cmp` c</code> is
 <code><a href="../base-4.16.4.0/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then <code>c</code> is also assigned to the same group and so on. When the
 comparison fails a new group is started. Each group is folded using the fold
 <code>f</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.groupsByRolling (\a b -&gt; a + 1 == b) Fold.toList $ Stream.fromList [1,2,3,7,8,9]
</code></strong>[[1,2,3],[7,8,9]]
</pre><p><em>Since: 0.7.0</em></p></div></div><a href="#g:12" id="g:12"><h1>Nested splitting</h1></a><div class="top"><p class="src"><a id="v:splitInnerBy" class="def">splitInnerBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (f a -&gt; m (f a, <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (f a))) -&gt; (f a -&gt; f a -&gt; m (f a)) -&gt; t m (f a) -&gt; t m (f a) <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#splitInnerBy" class="link">Source</a> <a href="#v:splitInnerBy" class="selflink">#</a></p><div class="doc"><p><code>splitInnerBy splitter joiner stream</code> splits the inner containers <code>f a</code> of
 an input stream <code>t m (f a)</code> using the <code>splitter</code> function. Container
 elements <code>f a</code> are collected until a split occurs, then all the elements
 before the split are joined using the <code>joiner</code> function.</p><p>For example, if we have a stream of <code>Array Word8</code>, we may want to split the
 stream into arrays representing lines separated by 'n' byte such that the
 resulting stream after a split would be one array for each line.</p><p>CAUTION! This is not a true streaming function as the container size after
 the split and merge may not be bounded.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:splitInnerBySuffix" class="def">splitInnerBySuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> (f a), <a href="../base-4.16.4.0/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (f a)) =&gt; (f a -&gt; m (f a, <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (f a))) -&gt; (f a -&gt; f a -&gt; m (f a)) -&gt; t m (f a) -&gt; t m (f a) <a href="src/Streamly.Internal.Data.Stream.IsStream.Reduce.html#splitInnerBySuffix" class="link">Source</a> <a href="#v:splitInnerBySuffix" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Reduce.html#v:splitInnerBy" title="Streamly.Internal.Data.Stream.IsStream.Reduce">splitInnerBy</a></code> but splits assuming the separator joins the segment in
 a suffix style.</p><p><em>Pre-release</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.26.0</p></div></body></html>