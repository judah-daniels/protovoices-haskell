<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Streamly.Internal.Data.Stream.IsStream.Common</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">streamly-0.8.1.1: Dataflow programming and declarative concurrency</span><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2017 Composewell Technologies</td></tr><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Stream.IsStream.Common</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Generation</a></li><li><a href="#g:2">Elimination</a></li><li><a href="#g:3">Transformation</a></li><li><a href="#g:4">Concurrent</a></li><li><a href="#g:5">Nesting</a></li><li><a href="#g:6">Zipping</a></li><li><a href="#g:7">Deprecated</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Bottom level IsStream module that can be used by all other upper level
 IsStream modules.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:fromPure">fromPure</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; a -&gt; t m a</li><li class="src short"><a href="#v:fromEffect">fromEffect</a> :: (<a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t) =&gt; m a -&gt; t m a</li><li class="src short"><a href="#v:repeatM">repeatM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; m a -&gt; t m a</li><li class="src short"><a href="#v:timesWith">timesWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>, <a href="Streamly-Internal-Data-Time-Units.html#t:RelTime64" title="Streamly.Internal.Data.Time.Units">RelTime64</a>)</li><li class="src short"><a href="#v:absTimesWith">absTimesWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a></li><li class="src short"><a href="#v:relTimesWith">relTimesWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m <a href="Streamly-Internal-Data-Time-Units.html#t:RelTime64" title="Streamly.Internal.Data.Time.Units">RelTime64</a></li><li class="src short"><a href="#v:foldOn">foldOn</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b</li><li class="src short"><a href="#v:fold">fold</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a -&gt; m b</li><li class="src short"><a href="#v:fold_">fold_</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a -&gt; m (b, <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a)</li><li class="src short"><a href="#v:map">map</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:scanlMAfter-39-">scanlMAfter'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; (b -&gt; m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:postscanlM-39-">postscanlM'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:smapM">smapM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (s -&gt; a -&gt; m (s, b)) -&gt; m s -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:take">take</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:takeWhile">takeWhile</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:drop">drop</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:findIndices">findIndices</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:intersperseM">intersperseM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:interjectSuffix">interjectSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:reverse">reverse</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:reverse-39-">reverse'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="../base-4.16.4.0/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mkAsync">mkAsync</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mkParallel">mkParallel</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:parallelFst">parallelFst</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:concatM">concatM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m (t m a) -&gt; t m a</li><li class="src short"><a href="#v:concatMapM">concatMapM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m (t m b)) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatMap">concatMap</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; t m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitOnSeq">splitOnSeq</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="../base-4.16.4.0/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="../base-4.16.4.0/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Foreign-Type.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Type">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:zipWithM">zipWithM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; m c) -&gt; t m a -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:zipWith">zipWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; c) -&gt; t m a -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:yield">yield</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; a -&gt; t m a</li><li class="src short"><a href="#v:yieldM">yieldM</a> :: (<a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t) =&gt; m a -&gt; t m a</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Generation</h1></a><div class="top"><p class="src"><a id="v:fromPure" class="def">fromPure</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#fromPure" class="link">Source</a> <a href="#v:fromPure" class="selflink">#</a></p><div class="doc"><pre>fromPure a = a `cons` nil
</pre><p>Create a singleton stream from a pure value.</p><p>The following holds in monadic streams, but not in Zip streams:</p><pre>fromPure = pure
fromPure = fromEffect . pure
</pre><p>In Zip applicative streams <code><a href="Streamly-Internal-Data-Stream-IsStream-Common.html#v:fromPure" title="Streamly.Internal.Data.Stream.IsStream.Common">fromPure</a></code> is not the same as <code><a href="../base-4.16.4.0/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> because in that
 case <code><a href="../base-4.16.4.0/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> is equivalent to <code><a href="../base-4.16.4.0/GHC-List.html#v:repeat" title="GHC.List">repeat</a></code> instead. <code><a href="Streamly-Internal-Data-Stream-IsStream-Common.html#v:fromPure" title="Streamly.Internal.Data.Stream.IsStream.Common">fromPure</a></code> and <code><a href="../base-4.16.4.0/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> are
 equally efficient, in other cases <code><a href="Streamly-Internal-Data-Stream-IsStream-Common.html#v:fromPure" title="Streamly.Internal.Data.Stream.IsStream.Common">fromPure</a></code> may be slightly more efficient
 than the other equivalent definitions.</p><p><em>Since: 0.8.0 (Renamed yield to fromPure)</em></p></div></div><div class="top"><p class="src"><a id="v:fromEffect" class="def">fromEffect</a> :: (<a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t) =&gt; m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#fromEffect" class="link">Source</a> <a href="#v:fromEffect" class="selflink">#</a></p><div class="doc"><pre>fromEffect m = m `consM` nil
</pre><p>Create a singleton stream from a monadic action.</p><pre>&gt; Stream.toList $ Stream.fromEffect getLine
hello
[&quot;hello&quot;]
</pre><p><em>Since: 0.8.0 (Renamed yieldM to fromEffect)</em></p></div></div><div class="top"><p class="src"><a id="v:repeatM" class="def">repeatM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#repeatM" class="link">Source</a> <a href="#v:repeatM" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>repeatM = fix . consM
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>repeatM = cycle1 . fromEffect
</code></strong></pre><p>Generate a stream by repeatedly executing a monadic action forever.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>repeatAsync =
       Stream.repeatM (threadDelay 1000000 &gt;&gt; print 1)
     &amp; Stream.take 10
     &amp; Stream.fromAsync
     &amp; Stream.drain
:}
</pre><p><em>Concurrent, infinite (do not use with <code>fromParallel</code>)</em></p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:timesWith" class="def">timesWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>, <a href="Streamly-Internal-Data-Time-Units.html#t:RelTime64" title="Streamly.Internal.Data.Time.Units">RelTime64</a>) <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#timesWith" class="link">Source</a> <a href="#v:timesWith" class="selflink">#</a></p><div class="doc"><p><code>timesWith g</code> returns a stream of time value tuples. The first component
 of the tuple is an absolute time reference (epoch) denoting the start of the
 stream and the second component is a time relative to the reference.</p><p>The argument <code>g</code> specifies the granularity of the relative time in seconds.
 A lower granularity clock gives higher precision but is more expensive in
 terms of CPU usage. Any granularity lower than 1 ms is treated as 1 ms.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Control.Concurrent (threadDelay)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Streamly.Internal.Data.Stream.IsStream.Common as Stream (timesWith)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.mapM_ (\x -&gt; print x &gt;&gt; threadDelay 1000000) $ Stream.take 3 $ Stream.timesWith 0.01
</code></strong>(AbsTime (TimeSpec {sec = ..., nsec = ...}),RelTime64 (NanoSecond64 ...))
(AbsTime (TimeSpec {sec = ..., nsec = ...}),RelTime64 (NanoSecond64 ...))
(AbsTime (TimeSpec {sec = ..., nsec = ...}),RelTime64 (NanoSecond64 ...))
</pre><p>Note: This API is not safe on 32-bit machines.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:absTimesWith" class="def">absTimesWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#absTimesWith" class="link">Source</a> <a href="#v:absTimesWith" class="selflink">#</a></p><div class="doc"><p><code>absTimesWith g</code> returns a stream of absolute timestamps using a clock of
 granularity <code>g</code> specified in seconds. A low granularity clock is more
 expensive in terms of CPU usage.  Any granularity lower than 1 ms is treated
 as 1 ms.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.mapM_ print $ Stream.delayPre 1 $ Stream.take 3 $ absTimesWith 0.01
</code></strong>AbsTime (TimeSpec {sec = ..., nsec = ...})
AbsTime (TimeSpec {sec = ..., nsec = ...})
AbsTime (TimeSpec {sec = ..., nsec = ...})
</pre><p>Note: This API is not safe on 32-bit machines.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:relTimesWith" class="def">relTimesWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m <a href="Streamly-Internal-Data-Time-Units.html#t:RelTime64" title="Streamly.Internal.Data.Time.Units">RelTime64</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#relTimesWith" class="link">Source</a> <a href="#v:relTimesWith" class="selflink">#</a></p><div class="doc"><p><code>relTimesWith g</code> returns a stream of relative time values starting from 0,
 using a clock of granularity <code>g</code> specified in seconds. A low granularity
 clock is more expensive in terms of CPU usage.  Any granularity lower than 1
 ms is treated as 1 ms.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.mapM_ print $ Stream.delayPre 1 $ Stream.take 3 $ Stream.relTimesWith 0.01
</code></strong>RelTime64 (NanoSecond64 ...)
RelTime64 (NanoSecond64 ...)
RelTime64 (NanoSecond64 ...)
</pre><p>Note: This API is not safe on 32-bit machines.</p><p><em>Pre-release</em></p></div></div><a href="#g:2" id="g:2"><h1>Elimination</h1></a><div class="top"><p class="src"><a id="v:foldOn" class="def">foldOn</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#foldOn" class="link">Source</a> <a href="#v:foldOn" class="selflink">#</a></p><div class="doc"><p>We can create higher order folds using <code><a href="Streamly-Internal-Data-Stream-IsStream-Common.html#v:foldOn" title="Streamly.Internal.Data.Stream.IsStream.Common">foldOn</a></code>. We can fold a number of
 streams to a given fold efficiently with full stream fusion. For example, to
 fold a list of streams on the same sum fold:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>concatFold = Prelude.foldl Stream.foldOn Fold.sum
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fold f = Fold.finish . Stream.foldOn f
</code></strong></pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:fold" class="def">fold</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a -&gt; m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#fold" class="link">Source</a> <a href="#v:fold" class="selflink">#</a></p><div class="doc"><p>Fold a stream using the supplied left <code><a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a></code> and reducing the resulting
 expression strictly at each step. The behavior is similar to <code>foldl'</code>. A
 <code><a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a></code> can terminate early without consuming the full stream. See the
 documentation of individual <code><a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a></code>s for termination behavior.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.fold Fold.sum (Stream.enumerateFromTo 1 100)
</code></strong>5050
</pre><p>Folds never fail, therefore, they produce a default value even when no input
 is provided. It means we can always fold an empty stream and get a valid
 result.  For example:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.fold Fold.sum Stream.nil
</code></strong>0
</pre><p>However, <code>foldMany</code> on an empty stream results in an empty stream.
 Therefore, <code>Stream.fold f</code> is not the same as <code>Stream.head . Stream.foldMany
 f</code>.</p><pre>fold f = Stream.parse (Parser.fromFold f)</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:fold_" class="def">fold_</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a -&gt; m (b, <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a) <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#fold_" class="link">Source</a> <a href="#v:fold_" class="selflink">#</a></p></div><a href="#g:3" id="g:3"><h1>Transformation</h1></a><div class="top"><p class="src"><a id="v:map" class="def">map</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#map" class="link">Source</a> <a href="#v:map" class="selflink">#</a></p><div class="doc"><pre>map = fmap
</pre><p>Same as <code><a href="../base-4.16.4.0/Data-Functor.html#v:fmap" title="Data.Functor">fmap</a></code>.</p><pre>&gt; S.toList $ S.map (+1) $ S.fromList [1,2,3]
[2,3,4]
</pre><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:scanlMAfter-39-" class="def">scanlMAfter'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; (b -&gt; m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#scanlMAfter%27" class="link">Source</a> <a href="#v:scanlMAfter-39-" class="selflink">#</a></p><div class="doc"><p><code>scanlMAfter' accumulate initial done stream</code> is like <code>scanlM'</code> except
 that it provides an additional <code>done</code> function to be applied on the
 accumulator when the stream stops. The result of <code>done</code> is also emitted in
 the stream.</p><p>This function can be used to allocate a resource in the beginning of the
 scan and release it when the stream ends or to flush the internal state of
 the scan at the end.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:postscanlM-39-" class="def">postscanlM'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#postscanlM%27" class="link">Source</a> <a href="#v:postscanlM-39-" class="selflink">#</a></p><div class="doc"><p>Like <code>postscanl'</code> but with a monadic step function and a monadic seed.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>postscanlM' f z xs = Stream.drop 1 $ Stream.scanlM' f z xs
</code></strong></pre><p><em>Since: 0.7.0</em></p><p><em>Since: 0.8.0 (signature change)</em></p></div></div><div class="top"><p class="src"><a id="v:smapM" class="def">smapM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (s -&gt; a -&gt; m (s, b)) -&gt; m s -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#smapM" class="link">Source</a> <a href="#v:smapM" class="selflink">#</a></p><div class="doc"><p>A stateful <code><a href="../base-4.16.4.0/Data-Traversable.html#v:mapM" title="Data.Traversable">mapM</a></code>, equivalent to a left scan, more like mapAccumL.
 Hopefully, this is a better alternative to <code>scan</code>. Separation of state from
 the output makes it easier to think in terms of a shared state, and also
 makes it easier to keep the state fully strict and the output lazy.</p><p>See also: <code>scanlM'</code></p><p><em>Pre-release</em></p></div></div><div class="doc"><p>The stateful step function can be simplified to <code>(s -&gt; a -&gt; m b)</code> to provide
 a read-only environment. However, that would just be <code><a href="../base-4.16.4.0/Data-Traversable.html#v:mapM" title="Data.Traversable">mapM</a></code>.</p><p>The initial action could be <code>m (s, Maybe b)</code>, and we can also add a final
 action <code>s -&gt; m (Maybe b)</code>. This can be used to get pre/post scan like
 functionality and also to flush the state in the end like scanlMAfter'.
 We can also use it along with a fusible version of bracket to get
 scanlMAfter' like functionality. See issue #677.</p><p>This can be further generalized to a type similar to Fold/Parser, giving it
 filtering and parsing capability as well (this is in fact equivalent to
 parseMany):</p><p>smapM :: (s -&gt; a -&gt; m (Step s b)) -&gt; m s -&gt; t m a -&gt; t m b</p></div><div class="top"><p class="src"><a id="v:take" class="def">take</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#take" class="link">Source</a> <a href="#v:take" class="selflink">#</a></p><div class="doc"><p>Take first <code>n</code> elements from the stream and discard the rest.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:takeWhile" class="def">takeWhile</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#takeWhile" class="link">Source</a> <a href="#v:takeWhile" class="selflink">#</a></p><div class="doc"><p>End the stream as soon as the predicate fails on an element.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:drop" class="def">drop</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#drop" class="link">Source</a> <a href="#v:drop" class="selflink">#</a></p><div class="doc"><p>Discard first <code>n</code> elements from the stream and take the rest.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:findIndices" class="def">findIndices</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#findIndices" class="link">Source</a> <a href="#v:findIndices" class="selflink">#</a></p><div class="doc"><p>Find all the indices where the element in the stream satisfies the given
 predicate.</p><pre>findIndices = fold Fold.findIndices</pre><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:intersperseM" class="def">intersperseM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#intersperseM" class="link">Source</a> <a href="#v:intersperseM" class="selflink">#</a></p><div class="doc"><p>Insert an effect and its output before consuming an element of a stream
 except the first one.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.trace putChar $ Stream.intersperseM (putChar '.' &gt;&gt; return ',') $ Stream.fromList &quot;hello&quot;
</code></strong>h.,e.,l.,l.,o&quot;h,e,l,l,o&quot;
</pre><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:interjectSuffix" class="def">interjectSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#interjectSuffix" class="link">Source</a> <a href="#v:interjectSuffix" class="selflink">#</a></p><div class="doc"><p>Intersperse a monadic action into the input stream after every <code>n</code>
 seconds.</p><pre>&gt; import Control.Concurrent (threadDelay)
&gt; Stream.drain $ Stream.interjectSuffix 1 (putChar ',') $ Stream.mapM (x -&gt; threadDelay 1000000 &gt;&gt; putChar x) $ Stream.fromList &quot;hello&quot;
h,e,l,l,o
</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:reverse" class="def">reverse</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#reverse" class="link">Source</a> <a href="#v:reverse" class="selflink">#</a></p><div class="doc"><p>Returns the elements of the stream in reverse order.  The stream must be
 finite. Note that this necessarily buffers the entire stream in memory.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>reverse = Stream.foldlT (flip Stream.cons) Stream.nil
</code></strong></pre><p><em>Since 0.7.0 (Monad m constraint)</em></p><p><em>Since: 0.1.1</em></p></div></div><div class="top"><p class="src"><a id="v:reverse-39-" class="def">reverse'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="../base-4.16.4.0/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#reverse%27" class="link">Source</a> <a href="#v:reverse-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Common.html#v:reverse" title="Streamly.Internal.Data.Stream.IsStream.Common">reverse</a></code> but several times faster, requires a <code><a href="../base-4.16.4.0/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a></code> instance.</p><p><em>Pre-release</em></p></div></div><a href="#g:4" id="g:4"><h1>Concurrent</h1></a><div class="top"><p class="src"><a id="v:mkAsync" class="def">mkAsync</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#mkAsync" class="link">Source</a> <a href="#v:mkAsync" class="selflink">#</a></p><div class="doc"><p>Make the stream producer and consumer run concurrently by introducing a
 buffer between them. The producer thread evaluates the input stream until
 the buffer fills, it terminates if the buffer is full and a worker thread is
 kicked off again to evaluate the remaining stream when there is space in the
 buffer.  The consumer consumes the stream lazily from the buffer.</p><p><em>Since: 0.2.0 (Streamly)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:mkParallel" class="def">mkParallel</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#mkParallel" class="link">Source</a> <a href="#v:mkParallel" class="selflink">#</a></p><div class="doc"><p>Make the stream producer and consumer run concurrently by introducing a
 buffer between them. The producer thread evaluates the input stream until
 the buffer fills, it blocks if the buffer is full until there is space in
 the buffer. The consumer consumes the stream lazily from the buffer.</p><pre>mkParallel = IsStream.fromStreamD . mkParallelD . IsStream.toStreamD</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:parallelFst" class="def">parallelFst</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#parallelFst" class="link">Source</a> <a href="#v:parallelFst" class="selflink">#</a></p><div class="doc"><p>Like <code>parallel</code> but stops the output as soon as the first stream stops.</p><p><em>Pre-release</em></p></div></div><a href="#g:5" id="g:5"><h1>Nesting</h1></a><div class="top"><p class="src"><a id="v:concatM" class="def">concatM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m (t m a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#concatM" class="link">Source</a> <a href="#v:concatM" class="selflink">#</a></p><div class="doc"><p>Given a stream value in the underlying monad, lift and join the underlying
 monad with the stream monad.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>concatM = Stream.concat . Stream.fromEffect
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>concatM = Stream.concat . lift    -- requires (MonadTrans t)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>concatM = join . lift             -- requires (MonadTrans t, Monad (t m))
</code></strong></pre><p>See also: <code><a href="../base-4.16.4.0/Data-List.html#v:concat" title="Data.List">concat</a></code>, <code><a href="../base-4.16.4.0/Data-Traversable.html#v:sequence" title="Data.Traversable">sequence</a></code></p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:concatMapM" class="def">concatMapM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m (t m b)) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#concatMapM" class="link">Source</a> <a href="#v:concatMapM" class="selflink">#</a></p><div class="doc"><p>Map a stream producing monadic function on each element of the stream
 and then flatten the results into a single stream. Since the stream
 generation function is monadic, unlike <code><a href="Streamly-Internal-Data-Stream-IsStream-Common.html#v:concatMap" title="Streamly.Internal.Data.Stream.IsStream.Common">concatMap</a></code>, it can produce an
 effect at the beginning of each iteration of the inner loop.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:concatMap" class="def">concatMap</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; t m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#concatMap" class="link">Source</a> <a href="#v:concatMap" class="selflink">#</a></p><div class="doc"><p>Map a stream producing function on each element of the stream and then
 flatten the results into a single stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>concatMap f = Stream.concatMapM (return . f)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>concatMap f = Stream.concatMapWith Stream.serial f
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>concatMap f = Stream.concat . Stream.map f
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>concatMap f = Stream.unfoldMany (Unfold.lmap f Unfold.fromStream)
</code></strong></pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:splitOnSeq" class="def">splitOnSeq</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="../base-4.16.4.0/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="../base-4.16.4.0/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Foreign-Type.html#t:Array" title="Streamly.Internal.Data.Array.Foreign.Type">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#splitOnSeq" class="link">Source</a> <a href="#v:splitOnSeq" class="selflink">#</a></p><div class="doc"><p>Like <code>splitOn</code> but the separator is a sequence of elements instead of a
 single element.</p><p>For illustration, let's define a function that operates on pure lists:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' pat xs = Stream.toList $ Stream.splitOnSeq (Array.fromList pat) Fold.toList (Stream.fromList xs)
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;&quot; &quot;hello&quot;
</code></strong>[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;hello&quot; &quot;&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;hello&quot; &quot;hello&quot;
</code></strong>[&quot;&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;x&quot; &quot;hello&quot;
</code></strong>[&quot;hello&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;h&quot; &quot;hello&quot;
</code></strong>[&quot;&quot;,&quot;ello&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;o&quot; &quot;hello&quot;
</code></strong>[&quot;hell&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;e&quot; &quot;hello&quot;
</code></strong>[&quot;h&quot;,&quot;llo&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;l&quot; &quot;hello&quot;
</code></strong>[&quot;he&quot;,&quot;&quot;,&quot;o&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;ll&quot; &quot;hello&quot;
</code></strong>[&quot;he&quot;,&quot;o&quot;]
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Common.html#v:splitOnSeq" title="Streamly.Internal.Data.Stream.IsStream.Common">splitOnSeq</a></code> is an inverse of <code>intercalate</code>. The following law always holds:</p><pre>intercalate . splitOnSeq == id</pre><p>The following law holds when the separator is non-empty and contains none of
 the elements present in the input lists:</p><pre>splitOnSeq . intercalate == id</pre><p><em>Pre-release</em></p></div></div><a href="#g:6" id="g:6"><h1>Zipping</h1></a><div class="top"><p class="src"><a id="v:zipWithM" class="def">zipWithM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; m c) -&gt; t m a -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#zipWithM" class="link">Source</a> <a href="#v:zipWithM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Common.html#v:zipWith" title="Streamly.Internal.Data.Stream.IsStream.Common">zipWith</a></code> but using a monadic zipping function.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:zipWith" class="def">zipWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; c) -&gt; t m a -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#zipWith" class="link">Source</a> <a href="#v:zipWith" class="selflink">#</a></p><div class="doc"><p>Stream <code>a</code> is evaluated first, followed by stream <code>b</code>, the resulting
 elements <code>a</code> and <code>b</code> are then zipped using the supplied zip function and the
 result <code>c</code> is yielded to the consumer.</p><p>If stream <code>a</code> or stream <code>b</code> ends, the zipped stream ends. If stream <code>b</code> ends
 first, the element <code>a</code> from previous evaluation of stream <code>a</code> is discarded.</p><pre>&gt; S.toList $ S.zipWith (+) (S.fromList [1,2,3]) (S.fromList [4,5,6])
[5,7,9]
</pre><p><em>Since: 0.1.0</em></p></div></div><a href="#g:7" id="g:7"><h1>Deprecated</h1></a><div class="top"><p class="src"><a id="v:yield" class="def">yield</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#yield" class="link">Source</a> <a href="#v:yield" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use fromPure instead.</p></div><p>Same as <code><a href="Streamly-Internal-Data-Stream-IsStream-Common.html#v:fromPure" title="Streamly.Internal.Data.Stream.IsStream.Common">fromPure</a></code></p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:yieldM" class="def">yieldM</a> :: (<a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t) =&gt; m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#yieldM" class="link">Source</a> <a href="#v:yieldM" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use fromEffect instead.</p></div><p>Same as <code><a href="Streamly-Internal-Data-Stream-IsStream-Common.html#v:fromEffect" title="Streamly.Internal.Data.Stream.IsStream.Common">fromEffect</a></code></p><p><em>Since: 0.4.0</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.26.0</p></div></body></html>