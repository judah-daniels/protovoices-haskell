<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Streamly.Internal.Data.Stream.IsStream.Expand</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">streamly-0.8.1.1: Dataflow programming and declarative concurrency</span><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2017 Composewell Technologies</td></tr><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Stream.IsStream.Expand</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Binary Combinators (Linear)</a></li><li><a href="#g:2">Binary Combinators (Pair Wise)</a><ul><li><a href="#g:3">Append</a></li><li><a href="#g:4">wSerial</a></li><li><a href="#g:5">Interleave</a></li><li><a href="#g:6">Round Robin</a></li><li><a href="#g:7">Zip</a></li><li><a href="#g:8">Merge</a></li></ul></li><li><a href="#g:9">Combine Streams and Unfolds</a><ul><li><a href="#g:10">Append Many (Unfold)</a></li><li><a href="#g:11">Interpose</a></li><li><a href="#g:12">Intercalate</a></li></ul></li><li><a href="#g:13">Append Many (concatMap)</a></li><li><a href="#g:14">Flatten Containers</a></li><li><a href="#g:15">ConcatMapWith</a></li><li><a href="#g:16">ConcatPairsWith</a></li><li><a href="#g:17">IterateMap</a></li><li><a href="#g:18">Deprecated</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Expand a stream by combining two or more streams or by combining streams
 with unfolds.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:serial">serial</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:ahead">ahead</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:async">async</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:wAsync">wAsync</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:parallel">parallel</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:parallelFst">parallelFst</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:parallelMin">parallelMin</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:append">append</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:wSerial">wSerial</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:wSerialFst">wSerialFst</a> :: <a href="Streamly-Internal-Data-Stream-Serial.html#t:WSerialT" title="Streamly.Internal.Data.Stream.Serial">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:WSerialT" title="Streamly.Internal.Data.Stream.Serial">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:WSerialT" title="Streamly.Internal.Data.Stream.Serial">WSerialT</a> m a</li><li class="src short"><a href="#v:wSerialMin">wSerialMin</a> :: <a href="Streamly-Internal-Data-Stream-Serial.html#t:WSerialT" title="Streamly.Internal.Data.Stream.Serial">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:WSerialT" title="Streamly.Internal.Data.Stream.Serial">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:WSerialT" title="Streamly.Internal.Data.Stream.Serial">WSerialT</a> m a</li><li class="src short"><a href="#v:interleave">interleave</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:interleaveMin">interleaveMin</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:interleaveSuffix">interleaveSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:interleaveInfix">interleaveInfix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:roundrobin">roundrobin</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:zipWith">zipWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; c) -&gt; t m a -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:zipWithM">zipWithM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; m c) -&gt; t m a -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:zipAsyncWith">zipAsyncWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; (a -&gt; b -&gt; c) -&gt; t m a -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:zipAsyncWithM">zipAsyncWithM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; (a -&gt; b -&gt; m c) -&gt; t m a -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:mergeBy">mergeBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mergeByM">mergeByM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; m <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mergeByMFused">mergeByMFused</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; m <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mergeAsyncBy">mergeAsyncBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mergeAsyncByM">mergeAsyncByM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; (a -&gt; a -&gt; m <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:unfoldMany">unfoldMany</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:unfoldManyInterleave">unfoldManyInterleave</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:unfoldManyRoundRobin">unfoldManyRoundRobin</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:interpose">interpose</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; c -&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:interposeSuffix">interposeSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; c -&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:intercalate">intercalate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m b c -&gt; b -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:intercalateSuffix">intercalateSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m b c -&gt; b -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:gintercalate">gintercalate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m a c -&gt; t m a -&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:gintercalateSuffix">gintercalateSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m a c -&gt; t m a -&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:concatMapM">concatMapM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m (t m b)) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatMap">concatMap</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; t m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatM">concatM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m (t m a) -&gt; t m a</li><li class="src short"><a href="#v:concat">concat</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m (t m a) -&gt; t m a</li><li class="src short"><a href="#v:concatFoldableWith">concatFoldableWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m a -&gt; t m a -&gt; t m a) -&gt; f (t m a) -&gt; t m a</li><li class="src short"><a href="#v:concatMapFoldableWith">concatMapFoldableWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (a -&gt; t m b) -&gt; f a -&gt; t m b</li><li class="src short"><a href="#v:concatForFoldableWith">concatForFoldableWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; f a -&gt; (a -&gt; t m b) -&gt; t m b</li><li class="src short"><a href="#v:concatMapWith">concatMapWith</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (a -&gt; t m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:bindWith">bindWith</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; t m a -&gt; (a -&gt; t m b) -&gt; t m b</li><li class="src short"><a href="#v:concatSmapMWith">concatSmapMWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (s -&gt; a -&gt; m (s, t m b)) -&gt; m s -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatPairsWith">concatPairsWith</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (a -&gt; t m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:iterateMapWith">iterateMapWith</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; (t m a -&gt; t m a -&gt; t m a) -&gt; (a -&gt; t m a) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:iterateSmapMWith">iterateSmapMWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (t m a -&gt; t m a -&gt; t m a) -&gt; (b -&gt; a -&gt; m (b, t m a)) -&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:iterateMapLeftsWith">iterateMapLeftsWith</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; (t m (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b)) -&gt; (a -&gt; t m (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b)) -&gt; t m (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b)</li><li class="src short"><a href="#v:concatUnfold">concatUnfold</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:-60--61--62-">(&lt;=&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:-60--124-">(&lt;|)</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Binary Combinators (Linear)</h1></a><div class="doc"><p>Functions ending in the shape:</p><p><code>t m a -&gt; t m a -&gt; t m a</code>.</p><p>The functions in this section have a linear or flat n-ary combining
 characterstics. It means that when combined <code>n</code> times (e.g. <code>a <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:serial" title="Streamly.Internal.Data.Stream.IsStream.Expand">serial</a></code>
 b <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:serial" title="Streamly.Internal.Data.Stream.IsStream.Expand">serial</a></code> c ...</code>) the resulting expression will have an <code>O(n)</code>
 complexity (instead O(n^2) for pair wise combinators described in the
 next section. These functions can be used efficiently with
 <code>concatMapWith</code> et. al.  combinators that combine streams in a linear
 fashion (contrast with <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:concatPairsWith" title="Streamly.Internal.Data.Stream.IsStream.Expand">concatPairsWith</a></code> which combines streams as a
 binary tree).</p></div><div class="top"><p class="src"><a id="v:serial" class="def">serial</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 6</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#serial" class="link">Source</a> <a href="#v:serial" class="selflink">#</a></p><div class="doc"><p>Appends two streams sequentially, yielding all elements from the first
 stream, and then all elements from the second stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Streamly.Prelude (serial)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>stream1 = Stream.fromList [1,2]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>stream2 = Stream.fromList [3,4]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ stream1 `serial` stream2
</code></strong>[1,2,3,4]
</pre><p>This operation can be used to fold an infinite lazy container of streams.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:ahead" class="def">ahead</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 6</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#ahead" class="link">Source</a> <a href="#v:ahead" class="selflink">#</a></p><div class="doc"><p>Appends two streams, both the streams may be evaluated concurrently but
 the outputs are used in the same order as the corresponding actions in the
 original streams, side effects will happen in the order in which the streams
 are evaluated:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Streamly.Prelude (ahead, SerialT)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>stream1 = Stream.fromEffect (delay 4) :: SerialT IO Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>stream2 = Stream.fromEffect (delay 2) :: SerialT IO Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ stream1 `ahead` stream2 :: IO [Int]
</code></strong>2 sec
4 sec
[4,2]
</pre><p>Multiple streams can be combined. With enough threads, all of them can be
 scheduled simultaneously:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>stream3 = Stream.fromEffect (delay 1)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ stream1 `ahead` stream2 `ahead` stream3
</code></strong>1 sec
2 sec
4 sec
[4,2,1]
</pre><p>With 2 threads, only two can be scheduled at a time, when one of those
 finishes, the third one gets scheduled:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.maxThreads 2 $ stream1 `ahead` stream2 `ahead` stream3
</code></strong>2 sec
1 sec
4 sec
[4,2,1]
</pre><p>Only streams are scheduled for ahead evaluation, how actions within a stream
 are evaluated depends on the stream type. If it is a concurrent stream they
 will be evaluated concurrently. It may not make much sense combining serial
 streams using <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:ahead" title="Streamly.Internal.Data.Stream.IsStream.Expand">ahead</a></code>.</p><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:ahead" title="Streamly.Internal.Data.Stream.IsStream.Expand">ahead</a></code> can be safely used to fold an infinite lazy container of streams.</p><p><em>Since: 0.3.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:async" class="def">async</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 6</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#async" class="link">Source</a> <a href="#v:async" class="selflink">#</a></p><div class="doc"><p>Merges two streams, both the streams may be evaluated concurrently,
 outputs from both are used as they arrive:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Streamly.Prelude (async)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>stream1 = Stream.fromEffect (delay 4)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>stream2 = Stream.fromEffect (delay 2)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ stream1 `async` stream2
</code></strong>2 sec
4 sec
[2,4]
</pre><p>Multiple streams can be combined. With enough threads, all of them can be
 scheduled simultaneously:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>stream3 = Stream.fromEffect (delay 1)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ stream1 `async` stream2 `async` stream3
</code></strong>...
[1,2,4]
</pre><p>With 2 threads, only two can be scheduled at a time, when one of those
 finishes, the third one gets scheduled:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.maxThreads 2 $ stream1 `async` stream2 `async` stream3
</code></strong>...
[2,1,4]
</pre><p>With a single thread, it becomes serial:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.maxThreads 1 $ stream1 `async` stream2 `async` stream3
</code></strong>...
[4,2,1]
</pre><p>Only streams are scheduled for async evaluation, how actions within a
 stream are evaluated depends on the stream type. If it is a concurrent
 stream they will be evaluated concurrently.</p><p>In the following example, both the streams are scheduled for concurrent
 evaluation but each individual stream is evaluated serially:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>stream1 = Stream.fromListM $ Prelude.map delay [3,3] -- SerialT IO Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>stream2 = Stream.fromListM $ Prelude.map delay [1,1] -- SerialT IO Int
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ stream1 `async` stream2 -- IO [Int]
</code></strong>...
[1,1,3,3]
</pre><p>If total threads are 2, the third stream is scheduled only after one of the
 first two has finished:</p><pre>stream3 = Stream.fromListM $ Prelude.map delay [2,2] -- SerialT IO Int
Stream.toList $ Stream.maxThreads 2 $ stream1 `async` stream2 `async` stream3 -- IO [Int]</pre><p>...
 [1,1,3,2,3,2]</p><p>Thus <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:async" title="Streamly.Internal.Data.Stream.IsStream.Expand">async</a></code> goes deep in first few streams rather than going wide in all
 streams. It prefers to evaluate the leftmost streams as much as possible.
 Because of this behavior, <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:async" title="Streamly.Internal.Data.Stream.IsStream.Expand">async</a></code> can be safely used to fold an infinite
 lazy container of streams.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:wAsync" class="def">wAsync</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 6</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#wAsync" class="link">Source</a> <a href="#v:wAsync" class="selflink">#</a></p><div class="doc"><p>For singleton streams, <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:wAsync" title="Streamly.Internal.Data.Stream.IsStream.Expand">wAsync</a></code> is the same as <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:async" title="Streamly.Internal.Data.Stream.IsStream.Expand">async</a></code>.  See <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:async" title="Streamly.Internal.Data.Stream.IsStream.Expand">async</a></code> for
 singleton stream behavior. For multi-element streams, while <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:async" title="Streamly.Internal.Data.Stream.IsStream.Expand">async</a></code> is left
 biased i.e. it tries to evaluate the left side stream as much as possible,
 <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:wAsync" title="Streamly.Internal.Data.Stream.IsStream.Expand">wAsync</a></code> tries to schedule them both fairly. In other words, <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:async" title="Streamly.Internal.Data.Stream.IsStream.Expand">async</a></code> goes
 deep while <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:wAsync" title="Streamly.Internal.Data.Stream.IsStream.Expand">wAsync</a></code> goes wide. However, outputs are always used as they
 arrive.</p><p>With a single thread, <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:async" title="Streamly.Internal.Data.Stream.IsStream.Expand">async</a></code> starts behaving like <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:serial" title="Streamly.Internal.Data.Stream.IsStream.Expand">serial</a></code> while <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:wAsync" title="Streamly.Internal.Data.Stream.IsStream.Expand">wAsync</a></code>
 starts behaving like <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:wSerial" title="Streamly.Internal.Data.Stream.IsStream.Expand">wSerial</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Streamly.Prelude (async, wAsync)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>stream1 = Stream.fromList [1,2,3]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>stream2 = Stream.fromList [4,5,6]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.fromAsync $ Stream.maxThreads 1 $ stream1 `async` stream2
</code></strong>[1,2,3,4,5,6]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.fromWAsync $ Stream.maxThreads 1 $ stream1 `wAsync` stream2
</code></strong>[1,4,2,5,3,6]
</pre><p>With two threads available, and combining three streams:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>stream3 = Stream.fromList [7,8,9]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.fromAsync $ Stream.maxThreads 2 $ stream1 `async` stream2 `async` stream3
</code></strong>[1,2,3,4,5,6,7,8,9]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.fromWAsync $ Stream.maxThreads 2 $ stream1 `wAsync` stream2 `wAsync` stream3
</code></strong>[1,4,2,7,5,3,8,6,9]
</pre><p>This operation cannot be used to fold an infinite lazy container of streams,
 because it schedules all the streams in a round robin manner.</p><p>Note that <code>WSerialT</code> and single threaded <code>WAsyncT</code> both interleave streams
 but the exact scheduling is slightly different in both cases.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:parallel" class="def">parallel</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 6</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#parallel" class="link">Source</a> <a href="#v:parallel" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Prelude.html#v:async" title="Streamly.Prelude">async</a></code> except that the execution is much more
 strict. There is no limit on the number of threads. While
 <code><a href="Streamly-Prelude.html#v:async" title="Streamly.Prelude">async</a></code> may not schedule a stream if there is no demand
 from the consumer, <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:parallel" title="Streamly.Internal.Data.Stream.IsStream.Expand">parallel</a></code> always evaluates both the streams immediately.
 The only limit that applies to <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:parallel" title="Streamly.Internal.Data.Stream.IsStream.Expand">parallel</a></code> is <code><a href="Streamly-Prelude.html#v:maxBuffer" title="Streamly.Prelude">maxBuffer</a></code>.
 Evaluation may block if the output buffer becomes full.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Streamly.Prelude (parallel)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>stream = Stream.fromEffect (delay 2) `parallel` Stream.fromEffect (delay 1)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList stream -- IO [Int]
</code></strong>1 sec
2 sec
[1,2]
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:parallel" title="Streamly.Internal.Data.Stream.IsStream.Expand">parallel</a></code> guarantees that all the streams are scheduled for execution
 immediately, therefore, we could use things like starting timers inside the
 streams and relying on the fact that all timers were started at the same
 time.</p><p>Unlike <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:async" title="Streamly.Internal.Data.Stream.IsStream.Expand">async</a></code> this operation cannot be used to fold an infinite lazy
 container of streams, because it schedules all the streams strictly
 concurrently.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:parallelFst" class="def">parallelFst</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#parallelFst" class="link">Source</a> <a href="#v:parallelFst" class="selflink">#</a></p><div class="doc"><p>Like <code>parallel</code> but stops the output as soon as the first stream stops.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:parallelMin" class="def">parallelMin</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#parallelMin" class="link">Source</a> <a href="#v:parallelMin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:parallel" title="Streamly.Internal.Data.Stream.IsStream.Expand">parallel</a></code> but stops the output as soon as any of the two streams
 stops.</p><p><em>Pre-release</em></p></div></div><a href="#g:2" id="g:2"><h1>Binary Combinators (Pair Wise)</h1></a><div class="doc"><p>Like the functions in the section above these functions also combine
 two streams into a single stream but when used <code>n</code> times linearly they
 exhibit O(n^2) complexity. They are best combined in a binary tree
 fashion using <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:concatPairsWith" title="Streamly.Internal.Data.Stream.IsStream.Expand">concatPairsWith</a></code> giving a <code>n * log n</code> complexity.  Avoid
 using these with <code>concatMapWith</code> when combining a large or infinite
 number of streams.</p></div><a href="#g:3" id="g:3"><h2>Append</h2></a><div class="top"><p class="src"><a id="v:append" class="def">append</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#append" class="link">Source</a> <a href="#v:append" class="selflink">#</a></p><div class="doc"><p>Append the outputs of two streams, yielding all the elements from the
 first stream and then yielding all the elements from the second stream.</p><p>IMPORTANT NOTE: This could be 100x faster than <code>serial/&lt;&gt;</code> for appending a
 few (say 100) streams because it can fuse via stream fusion. However, it
 does not scale for a large number of streams (say 1000s) and becomes
 qudartically slow. Therefore use this for custom appending of a few streams
 but use <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:concatMap" title="Streamly.Internal.Data.Stream.IsStream.Expand">concatMap</a></code> or 'concatMapWith serial' for appending <code>n</code> streams or
 infinite containers of streams.</p><p><em>Pre-release</em></p></div></div><a href="#g:4" id="g:4"><h2>wSerial</h2></a><div class="doc"><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:wSerial" title="Streamly.Internal.Data.Stream.IsStream.Expand">wSerial</a></code> is a CPS based stream interleaving functions. Use
 'concatPairsWith wSerial' to interleave <code>n</code> streams uniformly. It can be
 used with <code>concatMapWith</code> as well, however, the interleaving behavior of
 <code>n</code> streams would be asymmetric giving exponentially more weightage to
 streams that come earlier in the composition.</p></div><div class="top"><p class="src"><a id="v:wSerial" class="def">wSerial</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 6</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#wSerial" class="link">Source</a> <a href="#v:wSerial" class="selflink">#</a></p><div class="doc"><p>Interleaves two streams, yielding one element from each stream
 alternately.  When one stream stops the rest of the other stream is used in
 the output stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Streamly.Prelude (wSerial)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>stream1 = Stream.fromList [1,2]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>stream2 = Stream.fromList [3,4]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.fromWSerial $ stream1 `wSerial` stream2
</code></strong>[1,3,2,4]
</pre><p>Note, for singleton streams <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:wSerial" title="Streamly.Internal.Data.Stream.IsStream.Expand">wSerial</a></code> and <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:serial" title="Streamly.Internal.Data.Stream.IsStream.Expand">serial</a></code> are identical.</p><p>Note that this operation cannot be used to fold a container of infinite
 streams but it can be used for very large streams as the state that it needs
 to maintain is proportional to the logarithm of the number of streams.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:wSerialFst" class="def">wSerialFst</a> :: <a href="Streamly-Internal-Data-Stream-Serial.html#t:WSerialT" title="Streamly.Internal.Data.Stream.Serial">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:WSerialT" title="Streamly.Internal.Data.Stream.Serial">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:WSerialT" title="Streamly.Internal.Data.Stream.Serial">WSerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.Serial.html#wSerialFst" class="link">Source</a> <a href="#v:wSerialFst" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:wSerialMin" class="def">wSerialMin</a> :: <a href="Streamly-Internal-Data-Stream-Serial.html#t:WSerialT" title="Streamly.Internal.Data.Stream.Serial">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:WSerialT" title="Streamly.Internal.Data.Stream.Serial">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:WSerialT" title="Streamly.Internal.Data.Stream.Serial">WSerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.Serial.html#wSerialMin" class="link">Source</a> <a href="#v:wSerialMin" class="selflink">#</a></p></div><a href="#g:5" id="g:5"><h2>Interleave</h2></a><div class="doc"><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:interleave" title="Streamly.Internal.Data.Stream.IsStream.Expand">interleave</a></code> is like <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:wSerial" title="Streamly.Internal.Data.Stream.IsStream.Expand">wSerial</a></code>  but using a direct style
 implementation instead of CPS. It is faster than <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:wSerial" title="Streamly.Internal.Data.Stream.IsStream.Expand">wSerial</a></code> due to stream
 fusion but has worse efficiency when used with <code>concatMapWith</code> for large
 number of streams.</p></div><div class="top"><p class="src"><a id="v:interleave" class="def">interleave</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#interleave" class="link">Source</a> <a href="#v:interleave" class="selflink">#</a></p><div class="doc"><p>Interleaves the outputs of two streams, yielding elements from each stream
 alternately, starting from the first stream. If any of the streams finishes
 early the other stream continues alone until it too finishes.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XOverloadedStrings
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Data.Functor.Identity (Identity)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.interleave &quot;ab&quot; &quot;,,,,&quot; :: Stream.SerialT Identity Char
</code></strong>fromList &quot;a,b,,,&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.interleave &quot;abcd&quot; &quot;,,&quot; :: Stream.SerialT Identity Char
</code></strong>fromList &quot;a,b,cd&quot;
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:interleave" title="Streamly.Internal.Data.Stream.IsStream.Expand">interleave</a></code> is dual to <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:interleaveMin" title="Streamly.Internal.Data.Stream.IsStream.Expand">interleaveMin</a></code>, it can be called <code>interleaveMax</code>.</p><p>Do not use at scale in concatMapWith.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:interleaveMin" class="def">interleaveMin</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#interleaveMin" class="link">Source</a> <a href="#v:interleaveMin" class="selflink">#</a></p><div class="doc"><p>Interleaves the outputs of two streams, yielding elements from each stream
 alternately, starting from the first stream. The output stops as soon as any
 of the two streams finishes, discarding the remaining part of the other
 stream. The last element of the resulting stream would be from the longer
 stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XOverloadedStrings
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Data.Functor.Identity (Identity)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.interleaveMin &quot;ab&quot; &quot;,,,,&quot; :: Stream.SerialT Identity Char
</code></strong>fromList &quot;a,b,&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.interleaveMin &quot;abcd&quot; &quot;,,&quot; :: Stream.SerialT Identity Char
</code></strong>fromList &quot;a,b,c&quot;
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:interleaveMin" title="Streamly.Internal.Data.Stream.IsStream.Expand">interleaveMin</a></code> is dual to <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:interleave" title="Streamly.Internal.Data.Stream.IsStream.Expand">interleave</a></code>.</p><p>Do not use at scale in concatMapWith.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:interleaveSuffix" class="def">interleaveSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#interleaveSuffix" class="link">Source</a> <a href="#v:interleaveSuffix" class="selflink">#</a></p><div class="doc"><p>Interleaves the outputs of two streams, yielding elements from each stream
 alternately, starting from the first stream. As soon as the first stream
 finishes, the output stops, discarding the remaining part of the second
 stream. In this case, the last element in the resulting stream would be from
 the second stream. If the second stream finishes early then the first stream
 still continues to yield elements until it finishes.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XOverloadedStrings
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Data.Functor.Identity (Identity)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.interleaveSuffix &quot;abc&quot; &quot;,,,,&quot; :: Stream.SerialT Identity Char
</code></strong>fromList &quot;a,b,c,&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.interleaveSuffix &quot;abc&quot; &quot;,&quot; :: Stream.SerialT Identity Char
</code></strong>fromList &quot;a,bc&quot;
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:interleaveSuffix" title="Streamly.Internal.Data.Stream.IsStream.Expand">interleaveSuffix</a></code> is a dual of <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:interleaveInfix" title="Streamly.Internal.Data.Stream.IsStream.Expand">interleaveInfix</a></code>.</p><p>Do not use at scale in concatMapWith.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:interleaveInfix" class="def">interleaveInfix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#interleaveInfix" class="link">Source</a> <a href="#v:interleaveInfix" class="selflink">#</a></p><div class="doc"><p>Interleaves the outputs of two streams, yielding elements from each stream
 alternately, starting from the first stream and ending at the first stream.
 If the second stream is longer than the first, elements from the second
 stream are infixed with elements from the first stream. If the first stream
 is longer then it continues yielding elements even after the second stream
 has finished.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XOverloadedStrings
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Data.Functor.Identity (Identity)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.interleaveInfix &quot;abc&quot; &quot;,,,,&quot; :: Stream.SerialT Identity Char
</code></strong>fromList &quot;a,b,c&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.interleaveInfix &quot;abc&quot; &quot;,&quot; :: Stream.SerialT Identity Char
</code></strong>fromList &quot;a,bc&quot;
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:interleaveInfix" title="Streamly.Internal.Data.Stream.IsStream.Expand">interleaveInfix</a></code> is a dual of <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:interleaveSuffix" title="Streamly.Internal.Data.Stream.IsStream.Expand">interleaveSuffix</a></code>.</p><p>Do not use at scale in concatMapWith.</p><p><em>Pre-release</em></p></div></div><a href="#g:6" id="g:6"><h2>Round Robin</h2></a><div class="top"><p class="src"><a id="v:roundrobin" class="def">roundrobin</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#roundrobin" class="link">Source</a> <a href="#v:roundrobin" class="selflink">#</a></p><div class="doc"><p>Schedule the execution of two streams in a fair round-robin manner,
 executing each stream once, alternately. Execution of a stream may not
 necessarily result in an output, a stream may chose to <code>Skip</code> producing an
 element until later giving the other stream a chance to run. Therefore, this
 combinator fairly interleaves the execution of two streams rather than
 fairly interleaving the output of the two streams. This can be useful in
 co-operative multitasking without using explicit threads. This can be used
 as an alternative to <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:async" title="Streamly.Internal.Data.Stream.IsStream.Expand">async</a></code>.</p><p>Do not use at scale in concatMapWith.</p><p><em>Pre-release</em></p></div></div><a href="#g:7" id="g:7"><h2>Zip</h2></a><div class="top"><p class="src"><a id="v:zipWith" class="def">zipWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; c) -&gt; t m a -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#zipWith" class="link">Source</a> <a href="#v:zipWith" class="selflink">#</a></p><div class="doc"><p>Stream <code>a</code> is evaluated first, followed by stream <code>b</code>, the resulting
 elements <code>a</code> and <code>b</code> are then zipped using the supplied zip function and the
 result <code>c</code> is yielded to the consumer.</p><p>If stream <code>a</code> or stream <code>b</code> ends, the zipped stream ends. If stream <code>b</code> ends
 first, the element <code>a</code> from previous evaluation of stream <code>a</code> is discarded.</p><pre>&gt; S.toList $ S.zipWith (+) (S.fromList [1,2,3]) (S.fromList [4,5,6])
[5,7,9]
</pre><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:zipWithM" class="def">zipWithM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; m c) -&gt; t m a -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#zipWithM" class="link">Source</a> <a href="#v:zipWithM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:zipWith" title="Streamly.Internal.Data.Stream.IsStream.Expand">zipWith</a></code> but using a monadic zipping function.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:zipAsyncWith" class="def">zipAsyncWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; (a -&gt; b -&gt; c) -&gt; t m a -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#zipAsyncWith" class="link">Source</a> <a href="#v:zipAsyncWith" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:zipWith" title="Streamly.Internal.Data.Stream.IsStream.Expand">zipWith</a></code> but zips concurrently i.e. both the streams being zipped
 are evaluated concurrently using the <code>ParallelT</code> concurrent evaluation
 style. The maximum number of elements of each stream evaluated in advance
 can be controlled by <code>maxBuffer</code>.</p><p>The stream ends if stream <code>a</code> or stream <code>b</code> ends. However, if stream <code>b</code>
 ends while we are still evaluating stream <code>a</code> and waiting for a result then
 stream will not end until after the evaluation of stream <code>a</code> finishes. This
 behavior can potentially be changed in future to end the stream immediately
 as soon as any of the stream end is detected.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:zipAsyncWithM" class="def">zipAsyncWithM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; (a -&gt; b -&gt; m c) -&gt; t m a -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#zipAsyncWithM" class="link">Source</a> <a href="#v:zipAsyncWithM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:zipAsyncWith" title="Streamly.Internal.Data.Stream.IsStream.Expand">zipAsyncWith</a></code> but with a monadic zipping function.</p><p><em>Since: 0.4.0</em></p></div></div><a href="#g:8" id="g:8"><h2>Merge</h2></a><div class="top"><p class="src"><a id="v:mergeBy" class="def">mergeBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#mergeBy" class="link">Source</a> <a href="#v:mergeBy" class="selflink">#</a></p><div class="doc"><p>Merge two streams using a comparison function. The head elements of both
 the streams are compared and the smaller of the two elements is emitted, if
 both elements are equal then the element from the first stream is used
 first.</p><p>If the streams are sorted in ascending order, the resulting stream would
 also remain sorted in ascending order.</p><pre>&gt;&gt;&gt; Stream.toList $ Stream.mergeBy compare (Stream.fromList [1,3,5]) (Stream.fromList [2,4,6,8])
[1,2,3,4,5,6,8]

</pre><p>See also: <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:mergeByMFused" title="Streamly.Internal.Data.Stream.IsStream.Expand">mergeByMFused</a></code></p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:mergeByM" class="def">mergeByM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; m <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#mergeByM" class="link">Source</a> <a href="#v:mergeByM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:mergeBy" title="Streamly.Internal.Data.Stream.IsStream.Expand">mergeBy</a></code> but with a monadic comparison function.</p><p>Merge two streams randomly:</p><pre>&gt; randomly _ _ = randomIO &gt;&gt;= x -&gt; return $ if x then LT else GT
&gt; Stream.toList $ Stream.mergeByM randomly (Stream.fromList [1,1,1,1]) (Stream.fromList [2,2,2,2])
[2,1,2,2,2,1,1,1]
</pre><p>Merge two streams in a proportion of 2:1:</p><pre>&gt;&gt;&gt; :{
do
 let proportionately m n = do
      ref &lt;- newIORef $ cycle $ Prelude.concat [Prelude.replicate m LT, Prelude.replicate n GT]
      return $ _ _ -&gt; do
         r &lt;- readIORef ref
         writeIORef ref $ Prelude.tail r
         return $ Prelude.head r
 f &lt;- proportionately 2 1
 xs &lt;- Stream.toList $ Stream.mergeByM f (Stream.fromList [1,1,1,1,1,1]) (Stream.fromList [2,2,2])
 print xs
:}
[1,1,2,1,1,2,1,1,2]

</pre><p>See also: <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:mergeByMFused" title="Streamly.Internal.Data.Stream.IsStream.Expand">mergeByMFused</a></code></p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:mergeByMFused" class="def">mergeByMFused</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; m <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#mergeByMFused" class="link">Source</a> <a href="#v:mergeByMFused" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:mergeByM" title="Streamly.Internal.Data.Stream.IsStream.Expand">mergeByM</a></code> but much faster, works best when merging statically known
 number of streams. When merging more than two streams try to merge pairs and
 pair pf pairs in a tree like structure.<code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:mergeByM" title="Streamly.Internal.Data.Stream.IsStream.Expand">mergeByM</a></code> works better with variable
 number of streams being merged using <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:concatPairsWith" title="Streamly.Internal.Data.Stream.IsStream.Expand">concatPairsWith</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:mergeAsyncBy" class="def">mergeAsyncBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#mergeAsyncBy" class="link">Source</a> <a href="#v:mergeAsyncBy" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:mergeBy" title="Streamly.Internal.Data.Stream.IsStream.Expand">mergeBy</a></code> but merges concurrently (i.e. both the elements being
 merged are generated concurrently).</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:mergeAsyncByM" class="def">mergeAsyncByM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; (a -&gt; a -&gt; m <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#mergeAsyncByM" class="link">Source</a> <a href="#v:mergeAsyncByM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:mergeByM" title="Streamly.Internal.Data.Stream.IsStream.Expand">mergeByM</a></code> but merges concurrently (i.e. both the elements being
 merged are generated concurrently).</p><p><em>Since: 0.6.0</em></p></div></div><a href="#g:9" id="g:9"><h1>Combine Streams and Unfolds</h1></a><div class="doc"><p>Expand a stream by repeatedly using an unfold and merging the resulting
 streams.  Functions generally ending in the shape:</p><pre>Unfold m a b -&gt; t m a -&gt; t m b</pre></div><a href="#g:10" id="g:10"><h2>Append Many (Unfold)</h2></a><div class="doc"><p>Unfold and flatten streams.</p></div><div class="top"><p class="src"><a id="v:unfoldMany" class="def">unfoldMany</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#unfoldMany" class="link">Source</a> <a href="#v:unfoldMany" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:concatMap" title="Streamly.Internal.Data.Stream.IsStream.Expand">concatMap</a></code> but uses an <code><a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a></code> for stream generation. Unlike
 <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:concatMap" title="Streamly.Internal.Data.Stream.IsStream.Expand">concatMap</a></code> this can fuse the <code><a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a></code> code with the inner loop and
 therefore provide many times better performance.</p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:unfoldManyInterleave" class="def">unfoldManyInterleave</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#unfoldManyInterleave" class="link">Source</a> <a href="#v:unfoldManyInterleave" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:unfoldMany" title="Streamly.Internal.Data.Stream.IsStream.Expand">unfoldMany</a></code> but interleaves the streams in the same way as
 <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:interleave" title="Streamly.Internal.Data.Stream.IsStream.Expand">interleave</a></code> behaves instead of appending them.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:unfoldManyRoundRobin" class="def">unfoldManyRoundRobin</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#unfoldManyRoundRobin" class="link">Source</a> <a href="#v:unfoldManyRoundRobin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:unfoldMany" title="Streamly.Internal.Data.Stream.IsStream.Expand">unfoldMany</a></code> but executes the streams in the same way as
 <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:roundrobin" title="Streamly.Internal.Data.Stream.IsStream.Expand">roundrobin</a></code>.</p><p><em>Pre-release</em></p></div></div><a href="#g:11" id="g:11"><h2>Interpose</h2></a><div class="doc"><p>Insert effects between streams. Like unfoldMany but intersperses an
 effect between the streams. A special case of gintercalate.</p></div><div class="top"><p class="src"><a id="v:interpose" class="def">interpose</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; c -&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#interpose" class="link">Source</a> <a href="#v:interpose" class="selflink">#</a></p><div class="doc"><p>Unfold the elements of a stream, intersperse the given element between the
 unfolded streams and then concat them into a single stream.</p><pre>unwords = S.interpose ' '</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:interposeSuffix" class="def">interposeSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; c -&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#interposeSuffix" class="link">Source</a> <a href="#v:interposeSuffix" class="selflink">#</a></p><div class="doc"><p>Unfold the elements of a stream, append the given element after each
 unfolded stream and then concat them into a single stream.</p><pre>unlines = S.interposeSuffix '\n'</pre><p><em>Pre-release</em></p></div></div><a href="#g:12" id="g:12"><h2>Intercalate</h2></a><div class="doc"><p>Insert Streams between Streams.
 Like unfoldMany but intersperses streams from another source between
 the streams from the first source.</p></div><div class="top"><p class="src"><a id="v:intercalate" class="def">intercalate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m b c -&gt; b -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#intercalate" class="link">Source</a> <a href="#v:intercalate" class="selflink">#</a></p><div class="doc"><p><code>intersperse</code> followed by unfold and concat.</p><pre>intercalate unf a str = unfoldMany unf $ intersperse a str
intersperse = intercalate (Unfold.function id)
unwords = intercalate Unfold.fromList &quot; &quot;</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.intercalate Unfold.fromList &quot; &quot; $ Stream.fromList [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]
</code></strong>&quot;abc def ghi&quot;
</pre><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:intercalateSuffix" class="def">intercalateSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m b c -&gt; b -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#intercalateSuffix" class="link">Source</a> <a href="#v:intercalateSuffix" class="selflink">#</a></p><div class="doc"><p><code>intersperseSuffix</code> followed by unfold and concat.</p><pre>intercalateSuffix unf a str = unfoldMany unf $ intersperseSuffix a str
intersperseSuffix = intercalateSuffix (Unfold.function id)
unlines = intercalateSuffix Unfold.fromList &quot;\n&quot;</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.intercalateSuffix Unfold.fromList &quot;\n&quot; $ Stream.fromList [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]
</code></strong>&quot;abc\ndef\nghi\n&quot;
</pre><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:gintercalate" class="def">gintercalate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m a c -&gt; t m a -&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#gintercalate" class="link">Source</a> <a href="#v:gintercalate" class="selflink">#</a></p><div class="doc"><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:interleaveInfix" title="Streamly.Internal.Data.Stream.IsStream.Expand">interleaveInfix</a></code> followed by unfold and concat.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:gintercalateSuffix" class="def">gintercalateSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m a c -&gt; t m a -&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#gintercalateSuffix" class="link">Source</a> <a href="#v:gintercalateSuffix" class="selflink">#</a></p><div class="doc"><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:interleaveSuffix" title="Streamly.Internal.Data.Stream.IsStream.Expand">interleaveSuffix</a></code> followed by unfold and concat.</p><p><em>Pre-release</em></p></div></div><a href="#g:13" id="g:13"><h1>Append Many (concatMap)</h1></a><div class="doc"><p>Map and serially append streams. <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:concatMapM" title="Streamly.Internal.Data.Stream.IsStream.Expand">concatMapM</a></code> is a generalization of
 the binary append operation to append many streams.</p></div><div class="top"><p class="src"><a id="v:concatMapM" class="def">concatMapM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m (t m b)) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#concatMapM" class="link">Source</a> <a href="#v:concatMapM" class="selflink">#</a></p><div class="doc"><p>Map a stream producing monadic function on each element of the stream
 and then flatten the results into a single stream. Since the stream
 generation function is monadic, unlike <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:concatMap" title="Streamly.Internal.Data.Stream.IsStream.Expand">concatMap</a></code>, it can produce an
 effect at the beginning of each iteration of the inner loop.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:concatMap" class="def">concatMap</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; t m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#concatMap" class="link">Source</a> <a href="#v:concatMap" class="selflink">#</a></p><div class="doc"><p>Map a stream producing function on each element of the stream and then
 flatten the results into a single stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>concatMap f = Stream.concatMapM (return . f)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>concatMap f = Stream.concatMapWith Stream.serial f
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>concatMap f = Stream.concat . Stream.map f
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>concatMap f = Stream.unfoldMany (Unfold.lmap f Unfold.fromStream)
</code></strong></pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:concatM" class="def">concatM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m (t m a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#concatM" class="link">Source</a> <a href="#v:concatM" class="selflink">#</a></p><div class="doc"><p>Given a stream value in the underlying monad, lift and join the underlying
 monad with the stream monad.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>concatM = Stream.concat . Stream.fromEffect
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>concatM = Stream.concat . lift    -- requires (MonadTrans t)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>concatM = join . lift             -- requires (MonadTrans t, Monad (t m))
</code></strong></pre><p>See also: <code><a href="../base-4.16.4.0/Data-List.html#v:concat" title="Data.List">concat</a></code>, <code><a href="../base-4.16.4.0/Data-Traversable.html#v:sequence" title="Data.Traversable">sequence</a></code></p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:concat" class="def">concat</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m (t m a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#concat" class="link">Source</a> <a href="#v:concat" class="selflink">#</a></p><div class="doc"><p>Flatten a stream of streams to a single stream.</p><pre>concat = concatMap id
</pre><p><em>Pre-release</em></p></div></div><a href="#g:14" id="g:14"><h1>Flatten Containers</h1></a><div class="doc"><p>Flatten <code><a href="../base-4.16.4.0/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a></code> containers using the binary stream merging
 operations.</p></div><div class="top"><p class="src"><a id="v:concatFoldableWith" class="def">concatFoldableWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m a -&gt; t m a -&gt; t m a) -&gt; f (t m a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Type.html#concatFoldableWith" class="link">Source</a> <a href="#v:concatFoldableWith" class="selflink">#</a></p><div class="doc"><p>A variant of <code><a href="../base-4.16.4.0/Data-Foldable.html#v:fold" title="Data.Foldable">fold</a></code> that allows you to fold a <code><a href="../base-4.16.4.0/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a></code>
 container of streams using the specified stream sum operation.</p><pre>concatFoldableWith <code>async</code> $ map return [1..3]</pre><p>Equivalent to:</p><pre>concatFoldableWith f = Prelude.foldr f S.nil
concatFoldableWith f = S.concatMapFoldableWith f id
</pre><p><em>Since: 0.8.0 (Renamed foldWith to concatFoldableWith)</em></p><p><em>Since: 0.1.0 (<a href="Streamly.html">Streamly</a>)</em></p></div></div><div class="top"><p class="src"><a id="v:concatMapFoldableWith" class="def">concatMapFoldableWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (a -&gt; t m b) -&gt; f a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Type.html#concatMapFoldableWith" class="link">Source</a> <a href="#v:concatMapFoldableWith" class="selflink">#</a></p><div class="doc"><p>A variant of <code><a href="../base-4.16.4.0/Data-Foldable.html#v:foldMap" title="Data.Foldable">foldMap</a></code> that allows you to map a monadic streaming action
 on a <code><a href="../base-4.16.4.0/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a></code> container and then fold it using the specified stream merge
 operation.</p><pre>concatMapFoldableWith <code>async</code> return [1..3]</pre><p>Equivalent to:</p><pre>concatMapFoldableWith f g = Prelude.foldr (f . g) S.nil
concatMapFoldableWith f g xs = S.concatMapWith f g (S.fromFoldable xs)
</pre><p><em>Since: 0.8.0 (Renamed foldMapWith to concatMapFoldableWith)</em></p><p><em>Since: 0.1.0 (<a href="Streamly.html">Streamly</a>)</em></p></div></div><div class="top"><p class="src"><a id="v:concatForFoldableWith" class="def">concatForFoldableWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; f a -&gt; (a -&gt; t m b) -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Type.html#concatForFoldableWith" class="link">Source</a> <a href="#v:concatForFoldableWith" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:concatMapFoldableWith" title="Streamly.Internal.Data.Stream.IsStream.Expand">concatMapFoldableWith</a></code> but with the last two arguments reversed i.e. the
 monadic streaming function is the last argument.</p><p>Equivalent to:</p><pre>concatForFoldableWith f xs g = Prelude.foldr (f . g) S.nil xs
concatForFoldableWith f = flip (S.concatMapFoldableWith f)
</pre><p><em>Since: 0.8.0 (Renamed forEachWith to concatForFoldableWith)</em></p><p><em>Since: 0.1.0 (<a href="Streamly.html">Streamly</a>)</em></p></div></div><a href="#g:15" id="g:15"><h1>ConcatMapWith</h1></a><div class="doc"><p>Map and flatten a stream like <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:concatMap" title="Streamly.Internal.Data.Stream.IsStream.Expand">concatMap</a></code> but using a custom binary
 stream merging combinator instead of just appending the streams.  The
 merging occurs sequentially, it works efficiently for <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:serial" title="Streamly.Internal.Data.Stream.IsStream.Expand">serial</a></code>, <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:async" title="Streamly.Internal.Data.Stream.IsStream.Expand">async</a></code>,
 <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:ahead" title="Streamly.Internal.Data.Stream.IsStream.Expand">ahead</a></code> like merge operations where we consume one stream before the
 next or in case of <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:wAsync" title="Streamly.Internal.Data.Stream.IsStream.Expand">wAsync</a></code> or <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:parallel" title="Streamly.Internal.Data.Stream.IsStream.Expand">parallel</a></code> where we consume all streams
 simultaneously anyway.</p><p>However, in cases where the merging consumes streams in a round robin
 fashion, a pair wise merging using <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:concatPairsWith" title="Streamly.Internal.Data.Stream.IsStream.Expand">concatPairsWith</a></code> would be more
 efficient. These cases include operations like <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:mergeBy" title="Streamly.Internal.Data.Stream.IsStream.Expand">mergeBy</a></code> or <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:zipWith" title="Streamly.Internal.Data.Stream.IsStream.Expand">zipWith</a></code>.</p></div><div class="top"><p class="src"><a id="v:concatMapWith" class="def">concatMapWith</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (a -&gt; t m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Type.html#concatMapWith" class="link">Source</a> <a href="#v:concatMapWith" class="selflink">#</a></p><div class="doc"><p><code>concatMapWith mixer generator stream</code> is a two dimensional looping
 combinator.  The <code>generator</code> function is used to generate streams from the
 elements in the input <code>stream</code> and the <code>mixer</code> function is used to merge
 those streams.</p><p>Note we can merge streams concurrently by using a concurrent merge function.</p><p><em>Since: 0.7.0</em></p><p><em>Since: 0.8.0 (signature change)</em></p></div></div><div class="top"><p class="src"><a id="v:bindWith" class="def">bindWith</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; t m a -&gt; (a -&gt; t m b) -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Type.html#bindWith" class="link">Source</a> <a href="#v:bindWith" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:concatSmapMWith" class="def">concatSmapMWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (s -&gt; a -&gt; m (s, t m b)) -&gt; m s -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#concatSmapMWith" class="link">Source</a> <a href="#v:concatSmapMWith" class="selflink">#</a></p><div class="doc"><p>Like <code>concatMapWith</code> but carries a state which can be used to share
 information across multiple steps of concat.</p><pre>concatSmapMWith combine f initial = concatMapWith combine id . smapM f initial
</pre><p><em>Pre-release</em></p></div></div><a href="#g:16" id="g:16"><h1>ConcatPairsWith</h1></a><div class="doc"><p>See the notes about suitable merge functions in the <code>concatMapWith</code>
 section.</p></div><div class="top"><p class="src"><a id="v:concatPairsWith" class="def">concatPairsWith</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (a -&gt; t m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#concatPairsWith" class="link">Source</a> <a href="#v:concatPairsWith" class="selflink">#</a></p><div class="doc"><p>Combine streams in pairs using a binary stream combinator, then combine
 the resulting streams in pairs recursively until we get to a single combined
 stream.</p><p>For example, you can sort a stream using merge sort like this:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.concatPairsWith (Stream.mergeBy compare) Stream.fromPure $ Stream.fromList [5,1,7,9,2]
</code></strong>[1,2,5,7,9]
</pre><p><em>Caution: the stream of streams must be finite</em></p><p><em>Pre-release</em></p></div></div><a href="#g:17" id="g:17"><h1>IterateMap</h1></a><div class="doc"><p>Map and flatten Trees of Streams</p></div><div class="top"><p class="src"><a id="v:iterateMapWith" class="def">iterateMapWith</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; (t m a -&gt; t m a -&gt; t m a) -&gt; (a -&gt; t m a) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#iterateMapWith" class="link">Source</a> <a href="#v:iterateMapWith" class="selflink">#</a></p><div class="doc"><p>Like <code>iterateM</code> but iterates after mapping a stream generator on the
 output.</p><p>Yield an input element in the output stream, map a stream generator on it
 and then do the same on the resulting stream. This can be used for a depth
 first traversal of a tree like structure.</p><p>Note that <code>iterateM</code> is a special case of <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:iterateMapWith" title="Streamly.Internal.Data.Stream.IsStream.Expand">iterateMapWith</a></code>:</p><pre>iterateM f = iterateMapWith serial (fromEffect . f) . fromEffect
</pre><p>It can be used to traverse a tree structure.  For example, to list a
 directory tree:</p><pre>Stream.iterateMapWith Stream.serial
    (either Dir.toEither (const nil))
    (fromPure (Left &quot;tmp&quot;))
</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:iterateSmapMWith" class="def">iterateSmapMWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (t m a -&gt; t m a -&gt; t m a) -&gt; (b -&gt; a -&gt; m (b, t m a)) -&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#iterateSmapMWith" class="link">Source</a> <a href="#v:iterateSmapMWith" class="selflink">#</a></p><div class="doc"><p>Like <code>iterateMap</code> but carries a state in the stream generation function.
 This can be used to traverse graph like structures, we can remember the
 visited nodes in the state to avoid cycles.</p><p>Note that a combination of <code>iterateMap</code> and <code>usingState</code> can also be used to
 traverse graphs. However, this function provides a more localized state
 instead of using a global state.</p><p>See also: <code>mfix</code></p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:iterateMapLeftsWith" class="def">iterateMapLeftsWith</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; (t m (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b)) -&gt; (a -&gt; t m (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b)) -&gt; t m (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#iterateMapLeftsWith" class="link">Source</a> <a href="#v:iterateMapLeftsWith" class="selflink">#</a></p><div class="doc"><p>In an <code><a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a></code> stream iterate on <code><a href="../base-4.16.4.0/Data-Either.html#v:Left" title="Data.Either">Left</a></code>s.  This is a special case of
 <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:iterateMapWith" title="Streamly.Internal.Data.Stream.IsStream.Expand">iterateMapWith</a></code>:</p><pre>iterateMapLeftsWith combine f = iterateMapWith combine (either f (const nil))
</pre><p>To traverse a directory tree:</p><pre>iterateMapLeftsWith serial Dir.toEither (fromPure (Left &quot;tmp&quot;))
</pre><p><em>Pre-release</em></p></div></div><a href="#g:18" id="g:18"><h1>Deprecated</h1></a><div class="top"><p class="src"><a id="v:concatUnfold" class="def">concatUnfold</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Type.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Type">Unfold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#concatUnfold" class="link">Source</a> <a href="#v:concatUnfold" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use unfoldMany instead.</p></div></div></div><div class="top"><p class="src"><a id="v:-60--61--62-" class="def">(&lt;=&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 5</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#%3C%3D%3E" class="link">Source</a> <a href="#v:-60--61--62-" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:wSerial" title="Streamly.Internal.Data.Stream.IsStream.Expand">wSerial</a></code> instead.</p></div><p>Same as <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:wSerial" title="Streamly.Internal.Data.Stream.IsStream.Expand">wSerial</a></code>.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:-60--124-" class="def">(&lt;|)</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Expand.html#%3C%7C" class="link">Source</a> <a href="#v:-60--124-" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:async" title="Streamly.Internal.Data.Stream.IsStream.Expand">async</a></code> instead.</p></div><p>Same as <code><a href="Streamly-Internal-Data-Stream-IsStream-Expand.html#v:async" title="Streamly.Internal.Data.Stream.IsStream.Expand">async</a></code>.</p><p><em>Since: 0.1.0</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.26.0</p></div></body></html>