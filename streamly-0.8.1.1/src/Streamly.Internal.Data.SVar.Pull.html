<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-comment">-- |</span><span>
</span><span id="line-2"></span><span class="hs-comment">-- Module      : Streamly.Internal.Data.SVar.Pull</span><span>
</span><span id="line-3"></span><span class="hs-comment">-- Copyright   : (c) 2017 Composewell Technologies</span><span>
</span><span id="line-4"></span><span class="hs-comment">-- License     : BSD-3-Clause</span><span>
</span><span id="line-5"></span><span class="hs-comment">-- Maintainer  : streamly@composewell.com</span><span>
</span><span id="line-6"></span><span class="hs-comment">-- Stability   : experimental</span><span>
</span><span id="line-7"></span><span class="hs-comment">-- Portability : GHC</span><span>
</span><span id="line-8"></span><span class="hs-comment">--</span><span>
</span><span id="line-9"></span><span class="hs-comment">--</span><span>
</span><span id="line-10"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Streamly.Internal.Data.SVar.Pull</span><span>
</span><span id="line-11"></span><span>    </span><span class="hs-special">(</span><span>
</span><span id="line-12"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Read Output</span></span><span>
</span><span id="line-13"></span><span>      </span><span class="annot"><a href="Streamly.Internal.Data.SVar.Pull.html#readOutputQBasic"><span class="hs-identifier">readOutputQBasic</span></a></span><span>
</span><span id="line-14"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.SVar.Pull.html#readOutputQRaw"><span class="hs-identifier">readOutputQRaw</span></a></span><span>
</span><span id="line-15"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.SVar.Pull.html#readOutputQPaced"><span class="hs-identifier">readOutputQPaced</span></a></span><span>
</span><span id="line-16"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.SVar.Pull.html#readOutputQBounded"><span class="hs-identifier">readOutputQBounded</span></a></span><span>
</span><span id="line-17"></span><span>
</span><span id="line-18"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Postprocess Hook After Reading</span></span><span>
</span><span id="line-19"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.SVar.Pull.html#postProcessPaced"><span class="hs-identifier">postProcessPaced</span></a></span><span>
</span><span id="line-20"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.SVar.Pull.html#postProcessBounded"><span class="hs-identifier">postProcessBounded</span></a></span><span>
</span><span id="line-21"></span><span>
</span><span id="line-22"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Release Resources</span></span><span>
</span><span id="line-23"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.SVar.Pull.html#cleanupSVar"><span class="hs-identifier">cleanupSVar</span></a></span><span>
</span><span id="line-24"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.SVar.Pull.html#cleanupSVarFromWorker"><span class="hs-identifier">cleanupSVarFromWorker</span></a></span><span>
</span><span id="line-25"></span><span>    </span><span class="hs-special">)</span><span>
</span><span id="line-26"></span><span class="hs-keyword">where</span><span class="hs-cpp">

#include &quot;inline.hs&quot;
</span><span>
</span><span id="line-30"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Concurrent</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">myThreadId</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">throwTo</span></span><span class="hs-special">)</span><span>
</span><span id="line-31"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">when</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">void</span></span><span class="hs-special">)</span><span>
</span><span id="line-32"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.IO.Class</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">MonadIO</span></span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">liftIO</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-33"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.IORef</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">readIORef</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">writeIORef</span></span><span class="hs-special">)</span><span>
</span><span id="line-34"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.IORef</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">IORef</span></span><span class="hs-special">)</span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Streamly.Internal.Control.Concurrent.html"><span class="hs-identifier">Streamly.Internal.Control.Concurrent</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Streamly.Internal.Control.Concurrent.html#MonadAsync"><span class="hs-identifier">MonadAsync</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-36"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.Atomics.html"><span class="hs-identifier">Streamly.Internal.Data.Atomics</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Streamly.Internal.Data.Atomics.html#atomicModifyIORefCAS"><span class="hs-identifier">atomicModifyIORefCAS</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-37"></span><span>
</span><span id="line-38"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Set</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">S</span></span><span>
</span><span id="line-39"></span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.SVar.Type.html"><span class="hs-identifier">Streamly.Internal.Data.SVar.Type</span></a></span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.SVar.Dispatch.html"><span class="hs-identifier">Streamly.Internal.Data.SVar.Dispatch</span></a></span><span>
</span><span id="line-42"></span><span>
</span><span id="line-43"></span><span class="hs-comment">-------------------------------------------------------------------------------</span><span>
</span><span id="line-44"></span><span class="hs-comment">-- Reading from the workers' output queue/buffer</span><span>
</span><span id="line-45"></span><span class="hs-comment">-------------------------------------------------------------------------------</span><span>
</span><span id="line-46"></span><span>
</span><span id="line-47"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.SVar.Pull.html#readOutputQBasic"><span class="hs-pragma hs-type">readOutputQBasic</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-48"></span><span id="local-6989586621679391769"><span class="annot"><a href="Streamly.Internal.Data.SVar.Pull.html#readOutputQBasic"><span class="hs-identifier hs-type">readOutputQBasic</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IORef</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="Streamly.Internal.Data.SVar.Type.html#ChildEvent"><span class="hs-identifier hs-type">ChildEvent</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391769"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="Streamly.Internal.Data.SVar.Type.html#ChildEvent"><span class="hs-identifier hs-type">ChildEvent</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391769"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span></span><span>
</span><span id="line-49"></span><span id="readOutputQBasic"><span class="annot"><span class="annottext">readOutputQBasic :: forall a. IORef ([ChildEvent a], Int) -&gt; IO ([ChildEvent a], Int)
</span><a href="Streamly.Internal.Data.SVar.Pull.html#readOutputQBasic"><span class="hs-identifier hs-var hs-var">readOutputQBasic</span></a></span></span><span> </span><span id="local-6989586621679391658"><span class="annot"><span class="annottext">IORef ([ChildEvent a], Int)
</span><a href="#local-6989586621679391658"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. IORef a -&gt; (a -&gt; (a, b)) -&gt; IO b
</span><a href="Streamly.Internal.Data.Atomics.html#atomicModifyIORefCAS"><span class="hs-identifier hs-var">atomicModifyIORefCAS</span></a></span><span> </span><span class="annot"><span class="annottext">IORef ([ChildEvent a], Int)
</span><a href="#local-6989586621679391658"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679391657"><span class="annot"><span class="annottext">([ChildEvent a], Int)
</span><a href="#local-6989586621679391657"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">([ChildEvent a], Int)
</span><a href="#local-6989586621679391657"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-50"></span><span>
</span><span id="line-51"></span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.SVar.Pull.html#readOutputQRaw"><span class="hs-pragma hs-type">readOutputQRaw</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-52"></span><span id="local-6989586621679391757"><span id="local-6989586621679391758"><span id="local-6989586621679391759"><span class="annot"><a href="Streamly.Internal.Data.SVar.Pull.html#readOutputQRaw"><span class="hs-identifier hs-type">readOutputQRaw</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.SVar.Type.html#SVar"><span class="hs-identifier hs-type">SVar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391759"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391758"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391757"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="Streamly.Internal.Data.SVar.Type.html#ChildEvent"><span class="hs-identifier hs-type">ChildEvent</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391757"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-53"></span><span id="readOutputQRaw"><span class="annot"><span class="annottext">readOutputQRaw :: forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
SVar t m a -&gt; IO ([ChildEvent a], Int)
</span><a href="Streamly.Internal.Data.SVar.Pull.html#readOutputQRaw"><span class="hs-identifier hs-var hs-var">readOutputQRaw</span></a></span></span><span> </span><span id="local-6989586621679391646"><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391646"><span class="hs-identifier hs-var">sv</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-54"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679391645"><span class="annot"><span class="annottext">[ChildEvent a]
</span><a href="#local-6989586621679391645"><span class="hs-identifier hs-var">list</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679391644"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679391644"><span class="hs-identifier hs-var">len</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall a. IORef ([ChildEvent a], Int) -&gt; IO ([ChildEvent a], Int)
</span><a href="Streamly.Internal.Data.SVar.Pull.html#readOutputQBasic"><span class="hs-identifier hs-var">readOutputQBasic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
SVar t m a -&gt; IORef ([ChildEvent a], Int)
</span><a href="Streamly.Internal.Data.SVar.Type.html#outputQueue"><span class="hs-identifier hs-var">outputQueue</span></a></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391646"><span class="hs-identifier hs-var">sv</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-55"></span><span>    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">when</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
SVar t m a -&gt; Bool
</span><a href="Streamly.Internal.Data.SVar.Type.html#svarInspectMode"><span class="hs-identifier hs-var">svarInspectMode</span></a></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391646"><span class="hs-identifier hs-var">sv</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-56"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679391641"><span class="annot"><span class="annottext">ref :: IORef Int
</span><a href="#local-6989586621679391641"><span class="hs-identifier hs-var hs-var">ref</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SVarStats -&gt; IORef Int
</span><a href="Streamly.Internal.Data.SVar.Type.html#maxOutQSize"><span class="hs-identifier hs-var">maxOutQSize</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
SVar t m a -&gt; SVarStats
</span><a href="Streamly.Internal.Data.SVar.Type.html#svarStats"><span class="hs-identifier hs-var">svarStats</span></a></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391646"><span class="hs-identifier hs-var">sv</span></a></span><span>
</span><span id="line-57"></span><span>        </span><span id="local-6989586621679391638"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679391638"><span class="hs-identifier hs-var">oqLen</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall a. IORef a -&gt; IO a
</span><span class="hs-identifier hs-var">readIORef</span></span><span> </span><span class="annot"><span class="annottext">IORef Int
</span><a href="#local-6989586621679391641"><span class="hs-identifier hs-var">ref</span></a></span><span>
</span><span id="line-58"></span><span>        </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">when</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679391644"><span class="hs-identifier hs-var">len</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679391638"><span class="hs-identifier hs-var">oqLen</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. IORef a -&gt; a -&gt; IO ()
</span><span class="hs-identifier hs-var">writeIORef</span></span><span> </span><span class="annot"><span class="annottext">IORef Int
</span><a href="#local-6989586621679391641"><span class="hs-identifier hs-var">ref</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679391644"><span class="hs-identifier hs-var">len</span></a></span><span>
</span><span id="line-59"></span><span>    </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[ChildEvent a]
</span><a href="#local-6989586621679391645"><span class="hs-identifier hs-var">list</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679391644"><span class="hs-identifier hs-var">len</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-60"></span><span>
</span><span id="line-61"></span><span id="local-6989586621679391739"><span id="local-6989586621679391740"><span id="local-6989586621679391742"><span class="annot"><a href="Streamly.Internal.Data.SVar.Pull.html#readOutputQBounded"><span class="hs-identifier hs-type">readOutputQBounded</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Streamly.Internal.Control.Concurrent.html#MonadAsync"><span class="hs-identifier hs-type">MonadAsync</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391742"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.SVar.Type.html#SVar"><span class="hs-identifier hs-type">SVar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391740"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391742"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391739"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679391742"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Streamly.Internal.Data.SVar.Type.html#ChildEvent"><span class="hs-identifier hs-type">ChildEvent</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391739"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span></span><span>
</span><span id="line-62"></span><span id="readOutputQBounded"><span class="annot"><span class="annottext">readOutputQBounded :: forall (m :: * -&gt; *) (t :: (* -&gt; *) -&gt; * -&gt; *) a.
MonadAsync m =&gt;
SVar t m a -&gt; m [ChildEvent a]
</span><a href="Streamly.Internal.Data.SVar.Pull.html#readOutputQBounded"><span class="hs-identifier hs-var hs-var">readOutputQBounded</span></a></span></span><span> </span><span id="local-6989586621679391621"><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391621"><span class="hs-identifier hs-var">sv</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-63"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679391620"><span class="annot"><span class="annottext">[ChildEvent a]
</span><a href="#local-6989586621679391620"><span class="hs-identifier hs-var">list</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679391619"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679391619"><span class="hs-identifier hs-var">len</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. MonadIO m =&gt; IO a -&gt; m a
</span><span class="hs-identifier hs-var">liftIO</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
SVar t m a -&gt; IO ([ChildEvent a], Int)
</span><a href="Streamly.Internal.Data.SVar.Pull.html#readOutputQRaw"><span class="hs-identifier hs-var">readOutputQRaw</span></a></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391621"><span class="hs-identifier hs-var">sv</span></a></span><span>
</span><span id="line-64"></span><span>    </span><span class="hs-comment">-- When there is no output seen we dispatch more workers to help</span><span>
</span><span id="line-65"></span><span>    </span><span class="hs-comment">-- out if there is work pending in the work queue.</span><span>
</span><span id="line-66"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679391619"><span class="hs-identifier hs-var">len</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;=</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-67"></span><span>    </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">m [ChildEvent a]
</span><a href="#local-6989586621679391617"><span class="hs-identifier hs-var">blockingRead</span></a></span><span>
</span><span id="line-68"></span><span>    </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-69"></span><span>        </span><span class="hs-comment">-- send a worker proactively, if needed, even before we start</span><span>
</span><span id="line-70"></span><span>        </span><span class="hs-comment">-- processing the output.  This may degrade single processor</span><span>
</span><span id="line-71"></span><span>        </span><span class="hs-comment">-- perf but improves multi-processor, because of more</span><span>
</span><span id="line-72"></span><span>        </span><span class="hs-comment">-- parallelism</span><span>
</span><span id="line-73"></span><span>        </span><span class="annot"><span class="annottext">m ()
</span><a href="#local-6989586621679391616"><span class="hs-identifier hs-var">sendOneWorker</span></a></span><span>
</span><span id="line-74"></span><span>        </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">[ChildEvent a]
</span><a href="#local-6989586621679391620"><span class="hs-identifier hs-var">list</span></a></span><span>
</span><span id="line-75"></span><span>
</span><span id="line-76"></span><span>    </span><span class="hs-keyword">where</span><span>
</span><span id="line-77"></span><span>
</span><span id="line-78"></span><span>    </span><span id="local-6989586621679391616"><span class="annot"><span class="annottext">sendOneWorker :: m ()
</span><a href="#local-6989586621679391616"><span class="hs-identifier hs-var hs-var">sendOneWorker</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-79"></span><span>        </span><span id="local-6989586621679391602"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679391602"><span class="hs-identifier hs-var">cnt</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. MonadIO m =&gt; IO a -&gt; m a
</span><span class="hs-identifier hs-var">liftIO</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. IORef a -&gt; IO a
</span><span class="hs-identifier hs-var">readIORef</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
SVar t m a -&gt; IORef Int
</span><a href="Streamly.Internal.Data.SVar.Type.html#workerCount"><span class="hs-identifier hs-var">workerCount</span></a></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391621"><span class="hs-identifier hs-var">sv</span></a></span><span>
</span><span id="line-80"></span><span>        </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">when</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679391602"><span class="hs-identifier hs-var">cnt</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;=</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-81"></span><span>            </span><span id="local-6989586621679391600"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679391600"><span class="hs-identifier hs-var">done</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. MonadIO m =&gt; IO a -&gt; m a
</span><span class="hs-identifier hs-var">liftIO</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
SVar t m a -&gt; IO Bool
</span><a href="Streamly.Internal.Data.SVar.Type.html#isWorkDone"><span class="hs-identifier hs-var">isWorkDone</span></a></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391621"><span class="hs-identifier hs-var">sv</span></a></span><span>
</span><span id="line-82"></span><span>            </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">when</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679391600"><span class="hs-identifier hs-var">done</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) (t :: (* -&gt; *) -&gt; * -&gt; *) a.
MonadAsync m =&gt;
Count -&gt; SVar t m a -&gt; m ()
</span><a href="Streamly.Internal.Data.SVar.Dispatch.html#pushWorker"><span class="hs-identifier hs-var">pushWorker</span></a></span><span> </span><span class="annot"><span class="annottext">Count
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391621"><span class="hs-identifier hs-var">sv</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-83"></span><span>
</span><span id="line-84"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="#local-6989586621679391617"><span class="hs-pragma hs-type">blockingRead</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-85"></span><span>    </span><span id="local-6989586621679391617"><span class="annot"><span class="annottext">blockingRead :: m [ChildEvent a]
</span><a href="#local-6989586621679391617"><span class="hs-identifier hs-var hs-var">blockingRead</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-86"></span><span>        </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) (t :: (* -&gt; *) -&gt; * -&gt; *) a.
MonadAsync m =&gt;
(SVar t m a -&gt; IO ())
-&gt; (SVar t m a -&gt; m Bool) -&gt; SVar t m a -&gt; m ()
</span><a href="Streamly.Internal.Data.SVar.Dispatch.html#sendWorkerWait"><span class="hs-identifier hs-var">sendWorkerWait</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
SVar t m a -&gt; IO ()
</span><a href="Streamly.Internal.Data.SVar.Dispatch.html#sendWorkerDelay"><span class="hs-identifier hs-var">sendWorkerDelay</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) (t :: (* -&gt; *) -&gt; * -&gt; *) a.
MonadAsync m =&gt;
Count -&gt; SVar t m a -&gt; m Bool
</span><a href="Streamly.Internal.Data.SVar.Dispatch.html#dispatchWorker"><span class="hs-identifier hs-var">dispatchWorker</span></a></span><span> </span><span class="annot"><span class="annottext">Count
</span><span class="hs-number">0</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391621"><span class="hs-identifier hs-var">sv</span></a></span><span>
</span><span id="line-87"></span><span>        </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. MonadIO m =&gt; IO a -&gt; m a
</span><span class="hs-identifier hs-var">liftIO</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">`fmap`</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
SVar t m a -&gt; IO ([ChildEvent a], Int)
</span><a href="Streamly.Internal.Data.SVar.Pull.html#readOutputQRaw"><span class="hs-identifier hs-var">readOutputQRaw</span></a></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391621"><span class="hs-identifier hs-var">sv</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-88"></span><span>
</span><span id="line-89"></span><span id="local-6989586621679391581"><span id="local-6989586621679391582"><span id="local-6989586621679391583"><span class="annot"><a href="Streamly.Internal.Data.SVar.Pull.html#readOutputQPaced"><span class="hs-identifier hs-type">readOutputQPaced</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Streamly.Internal.Control.Concurrent.html#MonadAsync"><span class="hs-identifier hs-type">MonadAsync</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391583"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.SVar.Type.html#SVar"><span class="hs-identifier hs-type">SVar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391582"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391583"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391581"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679391583"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Streamly.Internal.Data.SVar.Type.html#ChildEvent"><span class="hs-identifier hs-type">ChildEvent</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391581"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span></span><span>
</span><span id="line-90"></span><span id="readOutputQPaced"><span class="annot"><span class="annottext">readOutputQPaced :: forall (m :: * -&gt; *) (t :: (* -&gt; *) -&gt; * -&gt; *) a.
MonadAsync m =&gt;
SVar t m a -&gt; m [ChildEvent a]
</span><a href="Streamly.Internal.Data.SVar.Pull.html#readOutputQPaced"><span class="hs-identifier hs-var hs-var">readOutputQPaced</span></a></span></span><span> </span><span id="local-6989586621679391564"><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391564"><span class="hs-identifier hs-var">sv</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-91"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679391563"><span class="annot"><span class="annottext">[ChildEvent a]
</span><a href="#local-6989586621679391563"><span class="hs-identifier hs-var">list</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679391562"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679391562"><span class="hs-identifier hs-var">len</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. MonadIO m =&gt; IO a -&gt; m a
</span><span class="hs-identifier hs-var">liftIO</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
SVar t m a -&gt; IO ([ChildEvent a], Int)
</span><a href="Streamly.Internal.Data.SVar.Pull.html#readOutputQRaw"><span class="hs-identifier hs-var">readOutputQRaw</span></a></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391564"><span class="hs-identifier hs-var">sv</span></a></span><span>
</span><span id="line-92"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679391562"><span class="hs-identifier hs-var">len</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;=</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-93"></span><span>    </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">m [ChildEvent a]
</span><a href="#local-6989586621679391561"><span class="hs-identifier hs-var">blockingRead</span></a></span><span>
</span><span id="line-94"></span><span>    </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-95"></span><span>        </span><span class="hs-comment">-- XXX send a worker proactively, if needed, even before we start</span><span>
</span><span id="line-96"></span><span>        </span><span class="hs-comment">-- processing the output.</span><span>
</span><span id="line-97"></span><span>        </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Functor f =&gt; f a -&gt; f ()
</span><span class="hs-identifier hs-var">void</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) (t :: (* -&gt; *) -&gt; * -&gt; *) a.
MonadAsync m =&gt;
SVar t m a -&gt; m Bool
</span><a href="Streamly.Internal.Data.SVar.Dispatch.html#dispatchWorkerPaced"><span class="hs-identifier hs-var">dispatchWorkerPaced</span></a></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391564"><span class="hs-identifier hs-var">sv</span></a></span><span>
</span><span id="line-98"></span><span>        </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">[ChildEvent a]
</span><a href="#local-6989586621679391563"><span class="hs-identifier hs-var">list</span></a></span><span>
</span><span id="line-99"></span><span>
</span><span id="line-100"></span><span>    </span><span class="hs-keyword">where</span><span>
</span><span id="line-101"></span><span>
</span><span id="line-102"></span><span>    </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="#local-6989586621679391561"><span class="hs-pragma hs-type">blockingRead</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-103"></span><span>    </span><span id="local-6989586621679391561"><span class="annot"><span class="annottext">blockingRead :: m [ChildEvent a]
</span><a href="#local-6989586621679391561"><span class="hs-identifier hs-var hs-var">blockingRead</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-104"></span><span>        </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) (t :: (* -&gt; *) -&gt; * -&gt; *) a.
MonadAsync m =&gt;
(SVar t m a -&gt; IO ())
-&gt; (SVar t m a -&gt; m Bool) -&gt; SVar t m a -&gt; m ()
</span><a href="Streamly.Internal.Data.SVar.Dispatch.html#sendWorkerWait"><span class="hs-identifier hs-var">sendWorkerWait</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
SVar t m a -&gt; IO ()
</span><a href="Streamly.Internal.Data.SVar.Dispatch.html#sendWorkerDelayPaced"><span class="hs-identifier hs-var">sendWorkerDelayPaced</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) (t :: (* -&gt; *) -&gt; * -&gt; *) a.
MonadAsync m =&gt;
SVar t m a -&gt; m Bool
</span><a href="Streamly.Internal.Data.SVar.Dispatch.html#dispatchWorkerPaced"><span class="hs-identifier hs-var">dispatchWorkerPaced</span></a></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391564"><span class="hs-identifier hs-var">sv</span></a></span><span>
</span><span id="line-105"></span><span>        </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. MonadIO m =&gt; IO a -&gt; m a
</span><span class="hs-identifier hs-var">liftIO</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">`fmap`</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
SVar t m a -&gt; IO ([ChildEvent a], Int)
</span><a href="Streamly.Internal.Data.SVar.Pull.html#readOutputQRaw"><span class="hs-identifier hs-var">readOutputQRaw</span></a></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391564"><span class="hs-identifier hs-var">sv</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-106"></span><span>
</span><span id="line-107"></span><span id="local-6989586621679391548"><span id="local-6989586621679391549"><span id="local-6989586621679391550"><span class="annot"><a href="Streamly.Internal.Data.SVar.Pull.html#postProcessPaced"><span class="hs-identifier hs-type">postProcessPaced</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Streamly.Internal.Control.Concurrent.html#MonadAsync"><span class="hs-identifier hs-type">MonadAsync</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391550"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.SVar.Type.html#SVar"><span class="hs-identifier hs-type">SVar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391549"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391550"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391548"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679391550"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span></span><span>
</span><span id="line-108"></span><span id="postProcessPaced"><span class="annot"><span class="annottext">postProcessPaced :: forall (m :: * -&gt; *) (t :: (* -&gt; *) -&gt; * -&gt; *) a.
MonadAsync m =&gt;
SVar t m a -&gt; m Bool
</span><a href="Streamly.Internal.Data.SVar.Pull.html#postProcessPaced"><span class="hs-identifier hs-var hs-var">postProcessPaced</span></a></span></span><span> </span><span id="local-6989586621679391526"><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391526"><span class="hs-identifier hs-var">sv</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-109"></span><span>    </span><span id="local-6989586621679391525"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679391525"><span class="hs-identifier hs-var">workersDone</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) (t :: (* -&gt; *) -&gt; * -&gt; *) a.
MonadIO m =&gt;
SVar t m a -&gt; m Bool
</span><a href="Streamly.Internal.Data.SVar.Dispatch.html#allThreadsDone"><span class="hs-identifier hs-var">allThreadsDone</span></a></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391526"><span class="hs-identifier hs-var">sv</span></a></span><span>
</span><span id="line-110"></span><span>    </span><span class="hs-comment">-- XXX If during consumption we figure out we are getting delayed then we</span><span>
</span><span id="line-111"></span><span>    </span><span class="hs-comment">-- should trigger dispatch there as well.  We should try to check on the</span><span>
</span><span id="line-112"></span><span>    </span><span class="hs-comment">-- workers after consuming every n item from the buffer?</span><span>
</span><span id="line-113"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679391525"><span class="hs-identifier hs-var">workersDone</span></a></span><span>
</span><span id="line-114"></span><span>    </span><span class="hs-keyword">then</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-115"></span><span>        </span><span id="local-6989586621679391523"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679391523"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. MonadIO m =&gt; IO a -&gt; m a
</span><span class="hs-identifier hs-var">liftIO</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
SVar t m a -&gt; IO Bool
</span><a href="Streamly.Internal.Data.SVar.Type.html#isWorkDone"><span class="hs-identifier hs-var">isWorkDone</span></a></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391526"><span class="hs-identifier hs-var">sv</span></a></span><span>
</span><span id="line-116"></span><span>        </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">when</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679391523"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-117"></span><span>            </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Functor f =&gt; f a -&gt; f ()
</span><span class="hs-identifier hs-var">void</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) (t :: (* -&gt; *) -&gt; * -&gt; *) a.
MonadAsync m =&gt;
SVar t m a -&gt; m Bool
</span><a href="Streamly.Internal.Data.SVar.Dispatch.html#dispatchWorkerPaced"><span class="hs-identifier hs-var">dispatchWorkerPaced</span></a></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391526"><span class="hs-identifier hs-var">sv</span></a></span><span>
</span><span id="line-118"></span><span>            </span><span class="hs-comment">-- Note that we need to guarantee a worker since the work is not</span><span>
</span><span id="line-119"></span><span>            </span><span class="hs-comment">-- finished, therefore we cannot just rely on dispatchWorkerPaced</span><span>
</span><span id="line-120"></span><span>            </span><span class="hs-comment">-- which may or may not send a worker.</span><span>
</span><span id="line-121"></span><span>            </span><span id="local-6989586621679391522"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679391522"><span class="hs-identifier hs-var">noWorker</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) (t :: (* -&gt; *) -&gt; * -&gt; *) a.
MonadIO m =&gt;
SVar t m a -&gt; m Bool
</span><a href="Streamly.Internal.Data.SVar.Dispatch.html#allThreadsDone"><span class="hs-identifier hs-var">allThreadsDone</span></a></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391526"><span class="hs-identifier hs-var">sv</span></a></span><span>
</span><span id="line-122"></span><span>            </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">when</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679391522"><span class="hs-identifier hs-var">noWorker</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) (t :: (* -&gt; *) -&gt; * -&gt; *) a.
MonadAsync m =&gt;
Count -&gt; SVar t m a -&gt; m ()
</span><a href="Streamly.Internal.Data.SVar.Dispatch.html#pushWorker"><span class="hs-identifier hs-var">pushWorker</span></a></span><span> </span><span class="annot"><span class="annottext">Count
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391526"><span class="hs-identifier hs-var">sv</span></a></span><span>
</span><span id="line-123"></span><span>        </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679391523"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-124"></span><span>    </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-125"></span><span>
</span><span id="line-126"></span><span id="local-6989586621679391519"><span id="local-6989586621679391520"><span id="local-6989586621679391521"><span class="annot"><a href="Streamly.Internal.Data.SVar.Pull.html#postProcessBounded"><span class="hs-identifier hs-type">postProcessBounded</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Streamly.Internal.Control.Concurrent.html#MonadAsync"><span class="hs-identifier hs-type">MonadAsync</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391521"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.SVar.Type.html#SVar"><span class="hs-identifier hs-type">SVar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391520"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391521"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391519"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679391521"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span></span><span>
</span><span id="line-127"></span><span id="postProcessBounded"><span class="annot"><span class="annottext">postProcessBounded :: forall (m :: * -&gt; *) (t :: (* -&gt; *) -&gt; * -&gt; *) a.
MonadAsync m =&gt;
SVar t m a -&gt; m Bool
</span><a href="Streamly.Internal.Data.SVar.Pull.html#postProcessBounded"><span class="hs-identifier hs-var hs-var">postProcessBounded</span></a></span></span><span> </span><span id="local-6989586621679391504"><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391504"><span class="hs-identifier hs-var">sv</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-128"></span><span>    </span><span id="local-6989586621679391503"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679391503"><span class="hs-identifier hs-var">workersDone</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) (t :: (* -&gt; *) -&gt; * -&gt; *) a.
MonadIO m =&gt;
SVar t m a -&gt; m Bool
</span><a href="Streamly.Internal.Data.SVar.Dispatch.html#allThreadsDone"><span class="hs-identifier hs-var">allThreadsDone</span></a></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391504"><span class="hs-identifier hs-var">sv</span></a></span><span>
</span><span id="line-129"></span><span>    </span><span class="hs-comment">-- There may still be work pending even if there are no workers pending</span><span>
</span><span id="line-130"></span><span>    </span><span class="hs-comment">-- because all the workers may return if the outputQueue becomes full. In</span><span>
</span><span id="line-131"></span><span>    </span><span class="hs-comment">-- that case send off a worker to kickstart the work again.</span><span>
</span><span id="line-132"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-133"></span><span>    </span><span class="hs-comment">-- Note that isWorkDone can only be safely checked if all workers are done.</span><span>
</span><span id="line-134"></span><span>    </span><span class="hs-comment">-- When some workers are in progress they may have decremented the yield</span><span>
</span><span id="line-135"></span><span>    </span><span class="hs-comment">-- Limit and later ending up incrementing it again. If we look at the yield</span><span>
</span><span id="line-136"></span><span>    </span><span class="hs-comment">-- limit in that window we may falsely say that it is 0 and therefore we</span><span>
</span><span id="line-137"></span><span>    </span><span class="hs-comment">-- are done.</span><span>
</span><span id="line-138"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679391503"><span class="hs-identifier hs-var">workersDone</span></a></span><span>
</span><span id="line-139"></span><span>    </span><span class="hs-keyword">then</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-140"></span><span>        </span><span id="local-6989586621679391502"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679391502"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. MonadIO m =&gt; IO a -&gt; m a
</span><span class="hs-identifier hs-var">liftIO</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
SVar t m a -&gt; IO Bool
</span><a href="Streamly.Internal.Data.SVar.Type.html#isWorkDone"><span class="hs-identifier hs-var">isWorkDone</span></a></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391504"><span class="hs-identifier hs-var">sv</span></a></span><span>
</span><span id="line-141"></span><span>        </span><span class="hs-comment">-- Note that we need to guarantee a worker, therefore we cannot just</span><span>
</span><span id="line-142"></span><span>        </span><span class="hs-comment">-- use dispatchWorker which may or may not send a worker.</span><span>
</span><span id="line-143"></span><span>        </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">when</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679391502"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) (t :: (* -&gt; *) -&gt; * -&gt; *) a.
MonadAsync m =&gt;
Count -&gt; SVar t m a -&gt; m ()
</span><a href="Streamly.Internal.Data.SVar.Dispatch.html#pushWorker"><span class="hs-identifier hs-var">pushWorker</span></a></span><span> </span><span class="annot"><span class="annottext">Count
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391504"><span class="hs-identifier hs-var">sv</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-144"></span><span>        </span><span class="hs-comment">-- XXX do we need to dispatch many here?</span><span>
</span><span id="line-145"></span><span>        </span><span class="hs-comment">-- void $ dispatchWorker sv</span><span>
</span><span id="line-146"></span><span>        </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679391502"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-147"></span><span>    </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-148"></span><span>
</span><span id="line-149"></span><span class="hs-comment">-------------------------------------------------------------------------------</span><span>
</span><span id="line-150"></span><span class="hs-comment">-- Cleanup</span><span>
</span><span id="line-151"></span><span class="hs-comment">-------------------------------------------------------------------------------</span><span>
</span><span id="line-152"></span><span>
</span><span id="line-153"></span><span id="local-6989586621679391499"><span id="local-6989586621679391500"><span id="local-6989586621679391501"><span class="annot"><a href="Streamly.Internal.Data.SVar.Pull.html#cleanupSVar"><span class="hs-identifier hs-type">cleanupSVar</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.SVar.Type.html#SVar"><span class="hs-identifier hs-type">SVar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391501"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391500"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391499"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-154"></span><span id="cleanupSVar"><span class="annot"><span class="annottext">cleanupSVar :: forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
SVar t m a -&gt; IO ()
</span><a href="Streamly.Internal.Data.SVar.Pull.html#cleanupSVar"><span class="hs-identifier hs-var hs-var">cleanupSVar</span></a></span></span><span> </span><span id="local-6989586621679391492"><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391492"><span class="hs-identifier hs-var">sv</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-155"></span><span>    </span><span id="local-6989586621679391491"><span class="annot"><span class="annottext">Set ThreadId
</span><a href="#local-6989586621679391491"><span class="hs-identifier hs-var">workers</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall a. IORef a -&gt; IO a
</span><span class="hs-identifier hs-var">readIORef</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
SVar t m a -&gt; IORef (Set ThreadId)
</span><a href="Streamly.Internal.Data.SVar.Type.html#workerThreads"><span class="hs-identifier hs-var">workerThreads</span></a></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391492"><span class="hs-identifier hs-var">sv</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-156"></span><span>    </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Foldable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m ()
</span><span class="hs-identifier hs-var">Prelude.mapM_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall e. Exception e =&gt; ThreadId -&gt; e -&gt; IO ()
</span><span class="hs-operator hs-var">`throwTo`</span></span><span> </span><span class="annot"><span class="annottext">ThreadAbort
</span><a href="Streamly.Internal.Data.SVar.Type.html#ThreadAbort"><span class="hs-identifier hs-var">ThreadAbort</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-157"></span><span>          </span><span class="annot"><span class="annottext">Set ThreadId
</span><a href="#local-6989586621679391491"><span class="hs-identifier hs-var">workers</span></a></span><span>
</span><span id="line-158"></span><span>
</span><span id="line-159"></span><span id="local-6989586621679391485"><span id="local-6989586621679391486"><span id="local-6989586621679391487"><span class="annot"><a href="Streamly.Internal.Data.SVar.Pull.html#cleanupSVarFromWorker"><span class="hs-identifier hs-type">cleanupSVarFromWorker</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Streamly.Internal.Data.SVar.Type.html#SVar"><span class="hs-identifier hs-type">SVar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391487"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391486"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679391485"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-160"></span><span id="cleanupSVarFromWorker"><span class="annot"><span class="annottext">cleanupSVarFromWorker :: forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
SVar t m a -&gt; IO ()
</span><a href="Streamly.Internal.Data.SVar.Pull.html#cleanupSVarFromWorker"><span class="hs-identifier hs-var hs-var">cleanupSVarFromWorker</span></a></span></span><span> </span><span id="local-6989586621679391476"><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391476"><span class="hs-identifier hs-var">sv</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-161"></span><span>    </span><span id="local-6989586621679391475"><span class="annot"><span class="annottext">Set ThreadId
</span><a href="#local-6989586621679391475"><span class="hs-identifier hs-var">workers</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall a. IORef a -&gt; IO a
</span><span class="hs-identifier hs-var">readIORef</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (t :: (* -&gt; *) -&gt; * -&gt; *) (m :: * -&gt; *) a.
SVar t m a -&gt; IORef (Set ThreadId)
</span><a href="Streamly.Internal.Data.SVar.Type.html#workerThreads"><span class="hs-identifier hs-var">workerThreads</span></a></span><span> </span><span class="annot"><span class="annottext">SVar t m a
</span><a href="#local-6989586621679391476"><span class="hs-identifier hs-var">sv</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-162"></span><span>    </span><span id="local-6989586621679391474"><span class="annot"><span class="annottext">ThreadId
</span><a href="#local-6989586621679391474"><span class="hs-identifier hs-var">self</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">IO ThreadId
</span><span class="hs-identifier hs-var">myThreadId</span></span><span>
</span><span id="line-163"></span><span>    </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Foldable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m ()
</span><span class="hs-identifier hs-var">Prelude.mapM_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall e. Exception e =&gt; ThreadId -&gt; e -&gt; IO ()
</span><span class="hs-operator hs-var">`throwTo`</span></span><span> </span><span class="annot"><span class="annottext">ThreadAbort
</span><a href="Streamly.Internal.Data.SVar.Type.html#ThreadAbort"><span class="hs-identifier hs-var">ThreadAbort</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-164"></span><span>          </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">Prelude.filter</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="annottext">ThreadId
</span><a href="#local-6989586621679391474"><span class="hs-identifier hs-var">self</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. Set a -&gt; [a]
</span><span class="hs-identifier hs-var">S.toList</span></span><span> </span><span class="annot"><span class="annottext">Set ThreadId
</span><a href="#local-6989586621679391475"><span class="hs-identifier hs-var">workers</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-165"></span></pre></body></html>