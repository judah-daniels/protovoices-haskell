<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Streamly.Internal.Data.Stream.SVar.Eliminate</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">streamly-0.8.1.1: Dataflow programming and declarative concurrency</span><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Stream.SVar.Eliminate.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2017 Composewell Technologies</td></tr><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Stream.SVar.Eliminate</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Concurrent Function Application</a></li><li><a href="#g:2">Concurrent folds</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Eliminate a stream by distributing it to multiple SVars concurrently.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:toSVarParallel">toSVarParallel</a> :: <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar-Type.html#t:State" title="Streamly.Internal.Data.SVar.Type">State</a> t m a -&gt; <a href="Streamly-Internal-Data-SVar-Type.html#t:SVar" title="Streamly.Internal.Data.SVar.Type">SVar</a> t m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamD-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamD.Type">Stream</a> m a -&gt; m ()</li><li class="src short"><a href="#v:newFoldSVar">newFoldSVar</a> :: <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar-Type.html#t:State" title="Streamly.Internal.Data.SVar.Type">State</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; (<a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a -&gt; m b) -&gt; m (<a href="Streamly-Internal-Data-SVar-Type.html#t:SVar" title="Streamly.Internal.Data.SVar.Type">SVar</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a)</li><li class="src short"><a href="#v:newFoldSVarF">newFoldSVarF</a> :: <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar-Type.html#t:State" title="Streamly.Internal.Data.SVar.Type">State</a> t m a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; m (<a href="Streamly-Internal-Data-SVar-Type.html#t:SVar" title="Streamly.Internal.Data.SVar.Type">SVar</a> t m a)</li><li class="src short"><a href="#v:fromConsumer">fromConsumer</a> :: <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar-Type.html#t:SVar" title="Streamly.Internal.Data.SVar.Type">SVar</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; m <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:pushToFold">pushToFold</a> :: <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar-Type.html#t:SVar" title="Streamly.Internal.Data.SVar.Type">SVar</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; a -&gt; m <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:teeToSVar">teeToSVar</a> :: <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar-Type.html#t:SVar" title="Streamly.Internal.Data.SVar.Type">SVar</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Concurrent Function Application</h1></a><div class="top"><p class="src"><a id="v:toSVarParallel" class="def">toSVarParallel</a> :: <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar-Type.html#t:State" title="Streamly.Internal.Data.SVar.Type">State</a> t m a -&gt; <a href="Streamly-Internal-Data-SVar-Type.html#t:SVar" title="Streamly.Internal.Data.SVar.Type">SVar</a> t m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamD-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamD.Type">Stream</a> m a -&gt; m () <a href="src/Streamly.Internal.Data.Stream.SVar.Eliminate.html#toSVarParallel" class="link">Source</a> <a href="#v:toSVarParallel" class="selflink">#</a></p><div class="doc"><p>Fold the supplied stream to the SVar asynchronously using Parallel
 concurrency style.
 {-# INLINE [1] toSVarParallel #-}</p></div></div><a href="#g:2" id="g:2"><h1>Concurrent folds</h1></a><div class="doc"><p>To run folds concurrently, we need to decouple the fold execution from the
 stream production. We use the SVar to do that, we have a single worker
 pushing the stream elements to the SVar and on the consumer side a fold
 driver pulls the values and folds them.</p><pre>
Fold worker &lt;------SVar&lt;------input stream
    |  exceptions  |
    ---------------&gt;

</pre><p>We need a channel for pushing exceptions from the fold worker to the stream
 pusher. The stream may be pushed to multiple folds at the same time. For
 that we need one SVar per fold:</p><pre>
Fold worker &lt;------SVar&lt;---
                   |       |
Fold worker &lt;------SVar&lt;------input stream
                   |       |
Fold worker &lt;------SVar&lt;---

</pre><p>Unlike in case concurrent stream evaluation, the puller does not drive the
 scheduling and concurrent execution of the stream. The stream is simply
 pushed by the stream producer at its own rate. The fold worker just pulls it
 and folds it.</p><p>Note: If the stream pusher terminates due to an exception, we do not
 actively terminate the fold. It gets cleaned up by the GC.</p></div><div class="top"><p class="src"><a id="v:newFoldSVar" class="def">newFoldSVar</a> :: <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar-Type.html#t:State" title="Streamly.Internal.Data.SVar.Type">State</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; (<a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a -&gt; m b) -&gt; m (<a href="Streamly-Internal-Data-SVar-Type.html#t:SVar" title="Streamly.Internal.Data.SVar.Type">SVar</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a) <a href="src/Streamly.Internal.Data.Stream.SVar.Eliminate.html#newFoldSVar" class="link">Source</a> <a href="#v:newFoldSVar" class="selflink">#</a></p><div class="doc"><p>Create a Fold style SVar that runs a supplied fold function as the
 consumer.  Any elements sent to the SVar are consumed by the supplied fold
 function.</p></div></div><div class="top"><p class="src"><a id="v:newFoldSVarF" class="def">newFoldSVarF</a> :: <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar-Type.html#t:State" title="Streamly.Internal.Data.SVar.Type">State</a> t m a -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; m (<a href="Streamly-Internal-Data-SVar-Type.html#t:SVar" title="Streamly.Internal.Data.SVar.Type">SVar</a> t m a) <a href="src/Streamly.Internal.Data.Stream.SVar.Eliminate.html#newFoldSVarF" class="link">Source</a> <a href="#v:newFoldSVarF" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-SVar-Eliminate.html#v:newFoldSVar" title="Streamly.Internal.Data.Stream.SVar.Eliminate">newFoldSVar</a></code> except that it uses a <code><a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a></code> instead of a fold
 function.</p></div></div><div class="top"><p class="src"><a id="v:fromConsumer" class="def">fromConsumer</a> :: <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar-Type.html#t:SVar" title="Streamly.Internal.Data.SVar.Type">SVar</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; m <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Stream.SVar.Eliminate.html#fromConsumer" class="link">Source</a> <a href="#v:fromConsumer" class="selflink">#</a></p><div class="doc"><p>Poll for events sent by the fold consumer to the stream pusher. The fold
 consumer can send a <a href="Stop.html">Stop</a> event or an exception. When a <a href="Stop.html">Stop</a> is received
 this function returns <code><a href="../base-4.16.4.0/Data-Bool.html#v:True" title="Data.Bool">True</a></code>. If an exception is recieved then it throws the
 exception.</p></div></div><div class="top"><p class="src"><a id="v:pushToFold" class="def">pushToFold</a> :: <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar-Type.html#t:SVar" title="Streamly.Internal.Data.SVar.Type">SVar</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; a -&gt; m <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Stream.SVar.Eliminate.html#pushToFold" class="link">Source</a> <a href="#v:pushToFold" class="selflink">#</a></p><div class="doc"><p>Push values from a stream to a fold worker via an SVar. Before pushing a
 value to the SVar it polls for events received from the fold consumer.  If a
 stop event is received then it returns <code><a href="../base-4.16.4.0/Data-Bool.html#v:True" title="Data.Bool">True</a></code> otherwise false.  Propagates
 exceptions received from the fold consumer.</p></div></div><div class="top"><p class="src"><a id="v:teeToSVar" class="def">teeToSVar</a> :: <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m =&gt; <a href="Streamly-Internal-Data-SVar-Type.html#t:SVar" title="Streamly.Internal.Data.SVar.Type">SVar</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.SVar.Eliminate.html#teeToSVar" class="link">Source</a> <a href="#v:teeToSVar" class="selflink">#</a></p><div class="doc"><p>Tap a stream and send the elements to the specified SVar in addition to
 yielding them again. The SVar runs a fold consumer. Elements are tapped and
 sent to the SVar until the fold finishes. Any exceptions from the fold
 evaluation are propagated in the current thread.</p><pre>
------input stream---------output stream-----&gt;
                   /|\   |
        exceptions  |    |  input
                    |   \|/
                    ----SVar
                         |
                        Fold

</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.26.0</p></div></body></html>