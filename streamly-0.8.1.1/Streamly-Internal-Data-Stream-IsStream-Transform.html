<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Streamly.Internal.Data.Stream.IsStream.Transform</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">streamly-0.8.1.1: Dataflow programming and declarative concurrency</span><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2017 Composewell Technologies</td></tr><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Stream.IsStream.Transform</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Piping</a></li><li><a href="#g:2">Folding</a></li><li><a href="#g:3">Mapping</a></li><li><a href="#g:4">Mapping Side Effects (Observation)</a></li><li><a href="#g:5">Scanning By <code>Fold</code></a></li><li><a href="#g:6">Scanning</a></li><li><a href="#g:7">Filtering</a></li><li><a href="#g:8">Trimming</a></li><li><a href="#g:9">Inserting Elements</a></li><li><a href="#g:10">Inserting Side Effects/Time</a></li><li><a href="#g:11">Element Aware Insertion</a></li><li><a href="#g:12">Reordering</a></li><li><a href="#g:13">Position Indexing</a></li><li><a href="#g:14">Time Indexing</a></li><li><a href="#g:15">Searching</a></li><li><a href="#g:16">Rolling map</a></li><li><a href="#g:17">Maybe Streams</a></li><li><a href="#g:18">Either Streams</a></li><li><a href="#g:19">Concurrent Evaluation</a><ul><li><a href="#g:20">Concurrent Pipelines</a></li><li><a href="#g:21">Concurrency Control</a></li><li><a href="#g:22">Buffering and Sampling</a></li><li><a href="#g:23">Rate Limiting</a></li></ul></li><li><a href="#g:24">Diagnostics</a></li><li><a href="#g:25">Deprecated</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc empty">&nbsp;</div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:transform">transform</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Pipe-Type.html#t:Pipe" title="Streamly.Internal.Data.Pipe.Type">Pipe</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:foldrS">foldrS</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; (a -&gt; t m b -&gt; t m b) -&gt; t m b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:foldrSShared">foldrSShared</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; (a -&gt; t m b -&gt; t m b) -&gt; t m b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:foldrT">foldrT</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (s m), <a href="../transformers-0.5.6.2/Control-Monad-Trans-Class.html#t:MonadTrans" title="Control.Monad.Trans.Class">MonadTrans</a> s) =&gt; (a -&gt; s m b -&gt; s m b) -&gt; s m b -&gt; t m a -&gt; s m b</li><li class="src short"><a href="#v:map">map</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:sequence">sequence</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m (m a) -&gt; t m a</li><li class="src short"><a href="#v:mapM">mapM</a> :: <span class="keyword">forall</span> t m a b. (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; (a -&gt; m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:smapM">smapM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (s -&gt; a -&gt; m (s, b)) -&gt; m s -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:trace">trace</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; (a -&gt; m b) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:trace_">trace_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:tap">tap</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:tapOffsetEvery">tapOffsetEvery</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:tapAsync">tapAsync</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:tapAsyncK">tapAsyncK</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; (t m a -&gt; m b) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:distributeAsync_">distributeAsync_</a> :: (<a href="../base-4.16.4.0/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f, <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; f (t m a -&gt; m b) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:tapRate">tapRate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../exceptions-0.10.4/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; (<a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m b) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:pollCounts">pollCounts</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (t m <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:scan">scan</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:postscan">postscan</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:scanl-39-">scanl'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:scanlM-39-">scanlM'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:scanlMAfter-39-">scanlMAfter'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; (b -&gt; m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:postscanl-39-">postscanl'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:postscanlM-39-">postscanlM'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:prescanl-39-">prescanl'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:prescanlM-39-">prescanlM'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:scanl1-39-">scanl1'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; a) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:scanl1M-39-">scanl1M'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; m a) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:with">with</a> :: <span class="keyword">forall</span> (t :: (<a href="../base-4.16.4.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.16.4.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="../base-4.16.4.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.16.4.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) m a b s. <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m) =&gt; (t m a -&gt; t m (s, a)) -&gt; (((s, a) -&gt; b) -&gt; t m (s, a) -&gt; t m (s, a)) -&gt; ((s, a) -&gt; b) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:deleteBy">deleteBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:filter">filter</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:filterM">filterM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:uniq">uniq</a> :: (<a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:uniqBy">uniqBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:nubBy">nubBy</a> :: (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:nubWindowBy">nubWindowBy</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:prune">prune</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:repeated">repeated</a> :: t m a -&gt; t m a</li><li class="src short"><a href="#v:take">take</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:takeInterval">takeInterval</a> :: (<a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Data-Time-Units.html#t:TimeUnit64" title="Streamly.Internal.Data.Time.Units">TimeUnit64</a> d) =&gt; d -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:takeLast">takeLast</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:takeLastInterval">takeLastInterval</a> :: <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:takeWhile">takeWhile</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:takeWhileM">takeWhileM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:takeWhileLast">takeWhileLast</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:takeWhileAround">takeWhileAround</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:drop">drop</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:dropInterval">dropInterval</a> :: (<a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Data-Time-Units.html#t:TimeUnit64" title="Streamly.Internal.Data.Time.Units">TimeUnit64</a> d) =&gt; d -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:dropLast">dropLast</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:dropLastInterval">dropLastInterval</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:dropWhile">dropWhile</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:dropWhileM">dropWhileM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:dropWhileLast">dropWhileLast</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:dropWhileAround">dropWhileAround</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:intersperse">intersperse</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:intersperseM">intersperseM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:intersperseBySpan">intersperseBySpan</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:intersperseSuffix">intersperseSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:intersperseSuffixBySpan">intersperseSuffixBySpan</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:interjectSuffix">interjectSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:intersperseM_">intersperseM_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:delay">delay</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:intersperseSuffix_">intersperseSuffix_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:delayPost">delayPost</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:interspersePrefix_">interspersePrefix_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:delayPre">delayPre</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:insertBy">insertBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:reverse">reverse</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:reverse-39-">reverse'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="../base-4.16.4.0/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:reassembleBy">reassembleBy</a> :: <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:indexed">indexed</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m (<a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>, a)</li><li class="src short"><a href="#v:indexedR">indexedR</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m (<a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>, a)</li><li class="src short"><a href="#v:timestamped">timestamped</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m a -&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>, a)</li><li class="src short"><a href="#v:timestampWith">timestampWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>, a)</li><li class="src short"><a href="#v:timeIndexed">timeIndexed</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m a -&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:RelTime64" title="Streamly.Internal.Data.Time.Units">RelTime64</a>, a)</li><li class="src short"><a href="#v:timeIndexWith">timeIndexWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:RelTime64" title="Streamly.Internal.Data.Time.Units">RelTime64</a>, a)</li><li class="src short"><a href="#v:findIndices">findIndices</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:elemIndices">elemIndices</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; t m a -&gt; t m <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:rollingMapM">rollingMapM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:rollingMap">rollingMap</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:catMaybes">catMaybes</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m (<a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) -&gt; t m a</li><li class="src short"><a href="#v:mapMaybe">mapMaybe</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:mapMaybeM">mapMaybeM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; (a -&gt; m (<a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b)) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:lefts">lefts</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m a</li><li class="src short"><a href="#v:rights">rights</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m b</li><li class="src short"><a href="#v:both">both</a> :: <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m) =&gt; t m (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a a) -&gt; t m a</li><li class="src short"><a href="#v:mkAsync">mkAsync</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mkParallel">mkParallel</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:applyAsync">applyAsync</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; (t m a -&gt; t m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:-124--36-">(|$)</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; (t m a -&gt; t m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:-124--38-">(|&amp;)</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; (t m a -&gt; t m b) -&gt; t m b</li><li class="src short"><a href="#v:maxThreads">maxThreads</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:maxBuffer">maxBuffer</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:sampleOld">sampleOld</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:sampleNew">sampleNew</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:sampleRate">sampleRate</a> :: <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><span class="keyword">data</span> <a href="#t:Rate">Rate</a> = <a href="#v:Rate">Rate</a> {<ul class="subs"><li><a href="#v:rateLow">rateLow</a> :: <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a></li><li><a href="#v:rateGoal">rateGoal</a> :: <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a></li><li><a href="#v:rateHigh">rateHigh</a> :: <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a></li><li><a href="#v:rateBuffer">rateBuffer</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a></li></ul>}</li><li class="src short"><a href="#v:rate">rate</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#t:Rate" title="Streamly.Internal.Data.Stream.IsStream.Transform">Rate</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:avgRate">avgRate</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:minRate">minRate</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:maxRate">maxRate</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:constRate">constRate</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:inspectMode">inspectMode</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:scanx">scanx</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (x -&gt; a -&gt; x) -&gt; x -&gt; (x -&gt; b) -&gt; t m a -&gt; t m b</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Piping</h1></a><div class="doc"><p>Pass through a <code><a href="Streamly-Internal-Data-Pipe-Type.html#t:Pipe" title="Streamly.Internal.Data.Pipe.Type">Pipe</a></code>.</p></div><div class="top"><p class="src"><a id="v:transform" class="def">transform</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Pipe-Type.html#t:Pipe" title="Streamly.Internal.Data.Pipe.Type">Pipe</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#transform" class="link">Source</a> <a href="#v:transform" class="selflink">#</a></p><div class="doc"><p>Use a <code><a href="Streamly-Internal-Data-Pipe-Type.html#t:Pipe" title="Streamly.Internal.Data.Pipe.Type">Pipe</a></code> to transform a stream.</p><p><em>Pre-release</em></p></div></div><a href="#g:2" id="g:2"><h1>Folding</h1></a><div class="top"><p class="src"><a id="v:foldrS" class="def">foldrS</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; (a -&gt; t m b -&gt; t m b) -&gt; t m b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#foldrS" class="link">Source</a> <a href="#v:foldrS" class="selflink">#</a></p><div class="doc"><p>Right fold to a streaming monad.</p><pre>foldrS Stream.cons Stream.nil === id</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:foldrS" title="Streamly.Internal.Data.Stream.IsStream.Transform">foldrS</a></code> can be used to perform stateless stream to stream transformations
 like map and filter in general. It can be coupled with a scan to perform
 stateful transformations. However, note that the custom map and filter
 routines can be much more efficient than this due to better stream fusion.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.foldrS Stream.cons Stream.nil $ Stream.fromList [1..5]
</code></strong>[1,2,3,4,5]
</pre><p>Find if any element in the stream is <code><a href="../base-4.16.4.0/Data-Bool.html#v:True" title="Data.Bool">True</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.foldrS (\x xs -&gt; if odd x then return True else xs) (return False) $ (Stream.fromList (2:4:5:undefined) :: Stream.SerialT IO Int)
</code></strong>[True]
</pre><p>Map (+2) on odd elements and filter out the even elements:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.foldrS (\x xs -&gt; if odd x then (x + 2) `Stream.cons` xs else xs) Stream.nil $ (Stream.fromList [1..5] :: Stream.SerialT IO Int)
</code></strong>[3,5,7]
</pre><p><code>foldrM</code> can also be represented in terms of <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:foldrS" title="Streamly.Internal.Data.Stream.IsStream.Transform">foldrS</a></code>, however, the former
 is much more efficient:</p><pre>foldrM f z s = runIdentityT $ foldrS (\x xs -&gt; lift $ f x (runIdentityT xs)) (lift z) s</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:foldrSShared" class="def">foldrSShared</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; (a -&gt; t m b -&gt; t m b) -&gt; t m b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#foldrSShared" class="link">Source</a> <a href="#v:foldrSShared" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:foldrT" class="def">foldrT</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (s m), <a href="../transformers-0.5.6.2/Control-Monad-Trans-Class.html#t:MonadTrans" title="Control.Monad.Trans.Class">MonadTrans</a> s) =&gt; (a -&gt; s m b -&gt; s m b) -&gt; s m b -&gt; t m a -&gt; s m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#foldrT" class="link">Source</a> <a href="#v:foldrT" class="selflink">#</a></p><div class="doc"><p>Right fold to a transformer monad.  This is the most general right fold
 function. <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:foldrS" title="Streamly.Internal.Data.Stream.IsStream.Transform">foldrS</a></code> is a special case of <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:foldrT" title="Streamly.Internal.Data.Stream.IsStream.Transform">foldrT</a></code>, however <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:foldrS" title="Streamly.Internal.Data.Stream.IsStream.Transform">foldrS</a></code>
 implementation can be more efficient:</p><pre>foldrS = foldrT
foldrM f z s = runIdentityT $ foldrT (\x xs -&gt; lift $ f x (runIdentityT xs)) (lift z) s</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:foldrT" title="Streamly.Internal.Data.Stream.IsStream.Transform">foldrT</a></code> can be used to translate streamly streams to other transformer
 monads e.g.  to a different streaming type.</p><p><em>Pre-release</em></p></div></div><a href="#g:3" id="g:3"><h1>Mapping</h1></a><div class="doc"><p>Stateless one-to-one maps.</p></div><div class="top"><p class="src"><a id="v:map" class="def">map</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#map" class="link">Source</a> <a href="#v:map" class="selflink">#</a></p><div class="doc"><pre>map = fmap
</pre><p>Same as <code><a href="../base-4.16.4.0/Data-Functor.html#v:fmap" title="Data.Functor">fmap</a></code>.</p><pre>&gt; S.toList $ S.map (+1) $ S.fromList [1,2,3]
[2,3,4]
</pre><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:sequence" class="def">sequence</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m (m a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#sequence" class="link">Source</a> <a href="#v:sequence" class="selflink">#</a></p><div class="doc"><pre>sequence = mapM id
</pre><p>Replace the elements of a stream of monadic actions with the outputs of
 those actions.</p><pre>&gt;&gt;&gt; drain $ Stream.sequence $ Stream.fromList [putStr &quot;a&quot;, putStr &quot;b&quot;, putStrLn &quot;c&quot;]
abc

&gt;&gt;&gt; :{
drain $ Stream.replicateM 3 (return $ threadDelay 1000000 &gt;&gt; print 1)
 &amp; (fromSerial . Stream.sequence)
:}
1
1
1

&gt;&gt;&gt; :{
drain $ Stream.replicateM 3 (return $ threadDelay 1000000 &gt;&gt; print 1)
 &amp; (fromAsync . Stream.sequence)
:}
1
1
1

</pre><p><em>Concurrent (do not use with <code>fromParallel</code> on infinite streams)</em></p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:mapM" class="def">mapM</a> :: <span class="keyword">forall</span> t m a b. (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; (a -&gt; m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#mapM" class="link">Source</a> <a href="#v:mapM" class="selflink">#</a></p><div class="doc"><pre>mapM f = sequence . map f
</pre><p>Apply a monadic function to each element of the stream and replace it with
 the output of the resulting action.</p><pre>&gt;&gt;&gt; drain $ Stream.mapM putStr $ Stream.fromList [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
abc

&gt;&gt;&gt; :{
   drain $ Stream.replicateM 10 (return 1)
     &amp; (fromSerial . Stream.mapM (x -&gt; threadDelay 1000000 &gt;&gt; print x))
:}
1
...
1

&gt; drain $ Stream.replicateM 10 (return 1)
 &amp; (fromAsync . Stream.mapM (x -&gt; threadDelay 1000000 &gt;&gt; print x))
</pre><p><em>Concurrent (do not use with <code>fromParallel</code> on infinite streams)</em></p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:smapM" class="def">smapM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (s -&gt; a -&gt; m (s, b)) -&gt; m s -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#smapM" class="link">Source</a> <a href="#v:smapM" class="selflink">#</a></p><div class="doc"><p>A stateful <code><a href="../base-4.16.4.0/Data-Traversable.html#v:mapM" title="Data.Traversable">mapM</a></code>, equivalent to a left scan, more like mapAccumL.
 Hopefully, this is a better alternative to <code>scan</code>. Separation of state from
 the output makes it easier to think in terms of a shared state, and also
 makes it easier to keep the state fully strict and the output lazy.</p><p>See also: <code>scanlM'</code></p><p><em>Pre-release</em></p></div></div><a href="#g:4" id="g:4"><h1>Mapping Side Effects (Observation)</h1></a><div class="doc"><p>See also the intersperse*_ combinators.</p></div><div class="top"><p class="src"><a id="v:trace" class="def">trace</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; (a -&gt; m b) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#trace" class="link">Source</a> <a href="#v:trace" class="selflink">#</a></p><div class="doc"><p>Apply a monadic function to each element flowing through the stream and
 discard the results.</p><pre>&gt;&gt;&gt; Stream.drain $ Stream.trace print (Stream.enumerateFromTo 1 2)
1
2

</pre><p>Compare with <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:tap" title="Streamly.Internal.Data.Stream.IsStream.Transform">tap</a></code>.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:trace_" class="def">trace_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#trace_" class="link">Source</a> <a href="#v:trace_" class="selflink">#</a></p><div class="doc"><p>Perform a side effect before yielding each element of the stream and
 discard the results.</p><pre>&gt;&gt;&gt; Stream.drain $ Stream.trace_ (print &quot;got here&quot;) (Stream.enumerateFromTo 1 2)
&quot;got here&quot;
&quot;got here&quot;

</pre><p>Same as <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:interspersePrefix_" title="Streamly.Internal.Data.Stream.IsStream.Transform">interspersePrefix_</a></code> but always serial.</p><p>See also: <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:trace" title="Streamly.Internal.Data.Stream.IsStream.Transform">trace</a></code></p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:tap" class="def">tap</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#tap" class="link">Source</a> <a href="#v:tap" class="selflink">#</a></p><div class="doc"><p>Tap the data flowing through a stream into a <code><a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a></code>. For example, you may
 add a tap to log the contents flowing through the stream. The fold is used
 only for effects, its result is discarded.</p><pre>                  Fold m a b
                      |
-----stream m a ---------------stream m a-----

</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.drain $ Stream.tap (Fold.drainBy print) (Stream.enumerateFromTo 1 2)
</code></strong>1
2
</pre><p>Compare with <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:trace" title="Streamly.Internal.Data.Stream.IsStream.Transform">trace</a></code>.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:tapOffsetEvery" class="def">tapOffsetEvery</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#tapOffsetEvery" class="link">Source</a> <a href="#v:tapOffsetEvery" class="selflink">#</a></p><div class="doc"><p><code>tapOffsetEvery offset n</code> taps every <code>n</code>th element in the stream
 starting at <code>offset</code>. <code>offset</code> can be between <code>0</code> and <code>n - 1</code>. Offset 0
 means start at the first element in the stream. If the offset is outside
 this range then <code>offset <code><a href="../base-4.16.4.0/Prelude.html#v:mod" title="Prelude">mod</a></code> n</code> is used as offset.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.drain $ Stream.tapOffsetEvery 0 2 (Fold.rmapM print Fold.toList) $ Stream.enumerateFromTo 0 10
</code></strong>[0,2,4,6,8,10]
</pre></div></div><div class="top"><p class="src"><a id="v:tapAsync" class="def">tapAsync</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#tapAsync" class="link">Source</a> <a href="#v:tapAsync" class="selflink">#</a></p><div class="doc"><p>Redirect a copy of the stream to a supplied fold and run it concurrently
 in an independent thread. The fold may buffer some elements. The buffer size
 is determined by the prevailing <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:maxBuffer" title="Streamly.Internal.Data.Stream.IsStream.Transform">maxBuffer</a></code> setting.</p><pre>              Stream m a -&gt; m b
                      |
-----stream m a ---------------stream m a-----

</pre><pre>&gt;&gt;&gt; Stream.drain $ Stream.tapAsync (Fold.drainBy print) (Stream.enumerateFromTo 1 2)
1
2

</pre><p>Exceptions from the concurrently running fold are propagated to the current
 computation.  Note that, because of buffering in the fold, exceptions may be
 delayed and may not correspond to the current element being processed in the
 parent stream, but we guarantee that before the parent stream stops the tap
 finishes and all exceptions from it are drained.</p><p>Compare with <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:tap" title="Streamly.Internal.Data.Stream.IsStream.Transform">tap</a></code>.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:tapAsyncK" class="def">tapAsyncK</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; (t m a -&gt; m b) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#tapAsyncK" class="link">Source</a> <a href="#v:tapAsyncK" class="selflink">#</a></p><div class="doc"><p>Redirect a copy of the stream to a supplied fold and run it concurrently
 in an independent thread. The fold may buffer some elements. The buffer size
 is determined by the prevailing <code><a href="Streamly-Prelude.html#v:maxBuffer" title="Streamly.Prelude">maxBuffer</a></code> setting.</p><pre>              Stream m a -&gt; m b
                      |
-----stream m a ---------------stream m a-----

</pre><pre>&gt; S.drain $ S.tapAsync (S.mapM_ print) (S.enumerateFromTo 1 2)
1
2
</pre><p>Exceptions from the concurrently running fold are propagated to the current
 computation.  Note that, because of buffering in the fold, exceptions may be
 delayed and may not correspond to the current element being processed in the
 parent stream, but we guarantee that before the parent stream stops the tap
 finishes and all exceptions from it are drained.</p><p>Compare with <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:tap" title="Streamly.Internal.Data.Stream.IsStream.Transform">tap</a></code>.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:distributeAsync_" class="def">distributeAsync_</a> :: (<a href="../base-4.16.4.0/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f, <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; f (t m a -&gt; m b) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#distributeAsync_" class="link">Source</a> <a href="#v:distributeAsync_" class="selflink">#</a></p><div class="doc"><p>Concurrently distribute a stream to a collection of fold functions,
 discarding the outputs of the folds.</p><pre>&gt; Stream.drain $ Stream.distributeAsync_ [Stream.mapM_ print, Stream.mapM_ print] (Stream.enumerateFromTo 1 2)
1
2
1
2

</pre><pre>distributeAsync_ = flip (foldr tapAsync)
</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:tapRate" class="def">tapRate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../exceptions-0.10.4/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; (<a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m b) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#tapRate" class="link">Source</a> <a href="#v:tapRate" class="selflink">#</a></p><div class="doc"><p>Calls the supplied function with the number of elements consumed
 every <code>n</code> seconds. The given function is run in a separate thread
 until the end of the stream. In case there is an exception in the
 stream the thread is killed during the next major GC.</p><p>Note: The action is not guaranteed to run if the main thread exits.</p><pre>&gt; delay n = threadDelay (round $ n * 1000000) &gt;&gt; return n
&gt; Stream.toList $ Stream.tapRate 2 (n -&gt; print $ show n ++ &quot; elements processed&quot;) (delay 1 Stream.|: delay 0.5 Stream.|: delay 0.5 Stream.|: Stream.nil)
&quot;2 elements processed&quot;
[1.0,0.5,0.5]
&quot;1 elements processed&quot;
</pre><p>Note: This may not work correctly on 32-bit machines.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:pollCounts" class="def">pollCounts</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (t m <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#pollCounts" class="link">Source</a> <a href="#v:pollCounts" class="selflink">#</a></p><div class="doc"><p><code>pollCounts predicate transform fold stream</code> counts those elements in the
 stream that pass the <code>predicate</code>. The resulting count stream is sent to
 another thread which transforms it using <code>transform</code> and then folds it using
 <code>fold</code>.  The thread is automatically cleaned up if the stream stops or
 aborts due to exception.</p><p>For example, to print the count of elements processed every second:</p><pre>&gt; Stream.drain $ Stream.pollCounts (const True) (Stream.rollingMap (-) . Stream.delayPost 1) (FLold.drainBy print)
          $ Stream.enumerateFrom 0
</pre><p>Note: This may not work correctly on 32-bit machines.</p><p><em>Pre-release</em></p></div></div><a href="#g:5" id="g:5"><h1>Scanning By <code>Fold</code></h1></a><div class="top"><p class="src"><a id="v:scan" class="def">scan</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#scan" class="link">Source</a> <a href="#v:scan" class="selflink">#</a></p><div class="doc"><p>Scan a stream using the given monadic fold.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.takeWhile (&lt; 10) $ Stream.scan Fold.sum (Stream.fromList [1..10])
</code></strong>[0,1,3,6]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:postscan" class="def">postscan</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#postscan" class="link">Source</a> <a href="#v:postscan" class="selflink">#</a></p><div class="doc"><p>Postscan a stream using the given monadic fold.</p><p>The following example extracts the input stream up to a point where the
 running average of elements is no more than 10:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Data.Maybe (fromJust)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let avg = Fold.teeWith (/) Fold.sum (fmap fromIntegral Fold.length)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong> Stream.toList
  $ Stream.map (fromJust . fst)
  $ Stream.takeWhile (\(_,x) -&gt; x &lt;= 10)
  $ Stream.postscan (Fold.tee Fold.last avg) (Stream.enumerateFromTo 1.0 100.0)
:}
[1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0,18.0,19.0]
</pre><p><em>Since: 0.7.0</em></p></div></div><a href="#g:6" id="g:6"><h1>Scanning</h1></a><div class="doc"><p>Left scans. Stateful, mostly one-to-one maps.</p></div><div class="top"><p class="src"><a id="v:scanl-39-" class="def">scanl'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#scanl%27" class="link">Source</a> <a href="#v:scanl-39-" class="selflink">#</a></p><div class="doc"><p>Strict left scan. Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:map" title="Streamly.Internal.Data.Stream.IsStream.Transform">map</a></code>, <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:scanl-39-" title="Streamly.Internal.Data.Stream.IsStream.Transform">scanl'</a></code> too is a one to one transformation,
 however it adds an extra element.</p><pre>&gt;&gt;&gt; Stream.toList $ Stream.scanl' (+) 0 $ fromList [1,2,3,4]
[0,1,3,6,10]

</pre><pre>&gt;&gt;&gt; Stream.toList $ Stream.scanl' (flip (:)) [] $ Stream.fromList [1,2,3,4]
[[],[1],[2,1],[3,2,1],[4,3,2,1]]

</pre><p>The output of <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:scanl-39-" title="Streamly.Internal.Data.Stream.IsStream.Transform">scanl'</a></code> is the initial value of the accumulator followed by
 all the intermediate steps and the final result of <code>foldl'</code>.</p><p>By streaming the accumulated state after each fold step, we can share the
 state across multiple stages of stream composition. Each stage can modify or
 extend the state, do some processing with it and emit it for the next stage,
 thus modularizing the stream processing. This can be useful in
 stateful or event-driven programming.</p><p>Consider the following monolithic example, computing the sum and the product
 of the elements in a stream in one go using a <code>foldl'</code>:</p><pre>&gt;&gt;&gt; Stream.foldl' ((s, p) x -&gt; (s + x, p * x)) (0,1) $ Stream.fromList <a href="10,24">1,2,3,4</a>

</pre><p>Using <code>scanl'</code> we can make it modular by computing the sum in the first
 stage and passing it down to the next stage for computing the product:</p><pre>&gt;&gt;&gt; :{
  Stream.foldl' ((_, p) (s, x) -&gt; (s, p * x)) (0,1)
  $ Stream.scanl' ((s, _) x -&gt; (s + x, x)) (0,1)
  $ Stream.fromList [1,2,3,4]
:}
(10,24)

</pre><p>IMPORTANT: <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:scanl-39-" title="Streamly.Internal.Data.Stream.IsStream.Transform">scanl'</a></code> evaluates the accumulator to WHNF.  To avoid building
 lazy expressions inside the accumulator, it is recommended that a strict
 data structure is used for accumulator.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>scanl' f z xs = scanlM' (\a b -&gt; return (f a b)) (return z) xs
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>scanl' f z xs = z `Stream.cons` postscanl' f z xs
</code></strong></pre><p>See also: <code>usingStateT</code></p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:scanlM-39-" class="def">scanlM'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#scanlM%27" class="link">Source</a> <a href="#v:scanlM-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:scanl-39-" title="Streamly.Internal.Data.Stream.IsStream.Transform">scanl'</a></code> but with a monadic step function and a monadic seed.</p><p><em>Since: 0.4.0</em></p><p><em>Since: 0.8.0 (signature change)</em></p></div></div><div class="top"><p class="src"><a id="v:scanlMAfter-39-" class="def">scanlMAfter'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; (b -&gt; m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#scanlMAfter%27" class="link">Source</a> <a href="#v:scanlMAfter-39-" class="selflink">#</a></p><div class="doc"><p><code>scanlMAfter' accumulate initial done stream</code> is like <code>scanlM'</code> except
 that it provides an additional <code>done</code> function to be applied on the
 accumulator when the stream stops. The result of <code>done</code> is also emitted in
 the stream.</p><p>This function can be used to allocate a resource in the beginning of the
 scan and release it when the stream ends or to flush the internal state of
 the scan at the end.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:postscanl-39-" class="def">postscanl'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#postscanl%27" class="link">Source</a> <a href="#v:postscanl-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:scanl-39-" title="Streamly.Internal.Data.Stream.IsStream.Transform">scanl'</a></code> but does not stream the initial value of the accumulator.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>postscanl' f z = postscanlM' (\a b -&gt; return (f a b)) (return z)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>postscanl' f z xs = Stream.drop 1 $ Stream.scanl' f z xs
</code></strong></pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:postscanlM-39-" class="def">postscanlM'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#postscanlM%27" class="link">Source</a> <a href="#v:postscanlM-39-" class="selflink">#</a></p><div class="doc"><p>Like <code>postscanl'</code> but with a monadic step function and a monadic seed.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>postscanlM' f z xs = Stream.drop 1 $ Stream.scanlM' f z xs
</code></strong></pre><p><em>Since: 0.7.0</em></p><p><em>Since: 0.8.0 (signature change)</em></p></div></div><div class="top"><p class="src"><a id="v:prescanl-39-" class="def">prescanl'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#prescanl%27" class="link">Source</a> <a href="#v:prescanl-39-" class="selflink">#</a></p><div class="doc"><p>Like scanl' but does not stream the final value of the accumulator.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:prescanlM-39-" class="def">prescanlM'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#prescanlM%27" class="link">Source</a> <a href="#v:prescanlM-39-" class="selflink">#</a></p><div class="doc"><p>Like prescanl' but with a monadic step function and a monadic seed.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:scanl1-39-" class="def">scanl1'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; a) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#scanl1%27" class="link">Source</a> <a href="#v:scanl1-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:scanl-39-" title="Streamly.Internal.Data.Stream.IsStream.Transform">scanl'</a></code> but for a non-empty stream. The first element of the stream
 is used as the initial value of the accumulator. Does nothing if the stream
 is empty.</p><pre>&gt;&gt;&gt; Stream.toList $ Stream.scanl1' (+) $ fromList [1,2,3,4]
[1,3,6,10]

</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:scanl1M-39-" class="def">scanl1M'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; m a) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#scanl1M%27" class="link">Source</a> <a href="#v:scanl1M-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:scanl1-39-" title="Streamly.Internal.Data.Stream.IsStream.Transform">scanl1'</a></code> but with a monadic step function.</p><p><em>Since: 0.6.0</em></p></div></div><a href="#g:7" id="g:7"><h1>Filtering</h1></a><div class="doc"><p>Produce a subset of the stream using criteria based on the values of
 the elements. We can use a concatMap and scan for filtering but these
 combinators are more efficient and convenient.</p></div><div class="top"><p class="src"><a id="v:with" class="def">with</a> :: <span class="keyword">forall</span> (t :: (<a href="../base-4.16.4.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.16.4.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="../base-4.16.4.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.16.4.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) m a b s. <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m) =&gt; (t m a -&gt; t m (s, a)) -&gt; (((s, a) -&gt; b) -&gt; t m (s, a) -&gt; t m (s, a)) -&gt; ((s, a) -&gt; b) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#with" class="link">Source</a> <a href="#v:with" class="selflink">#</a></p><div class="doc"><p>Modify a <code>t m a -&gt; t m a</code> stream transformation that accepts a predicate
 <code>(a -&gt; b)</code> to accept <code>((s, a) -&gt; b)</code> instead, provided a transformation <code>t m
 a -&gt; t m (s, a)</code>. Convenient to filter with index or time.</p><pre>filterWithIndex = with indexed filter
filterWithAbsTime = with timestamped filter
filterWithRelTime = with timeIndexed filter
</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:deleteBy" class="def">deleteBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#deleteBy" class="link">Source</a> <a href="#v:deleteBy" class="selflink">#</a></p><div class="doc"><p>Deletes the first occurrence of the element in the stream that satisfies
 the given equality predicate.</p><pre>&gt;&gt;&gt; Stream.toList $ Stream.deleteBy (==) 3 $ Stream.fromList [1,3,3,5]
[1,3,5]

</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:filter" class="def">filter</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#filter" class="link">Source</a> <a href="#v:filter" class="selflink">#</a></p><div class="doc"><p>Include only those elements that pass a predicate.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:filterM" class="def">filterM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#filterM" class="link">Source</a> <a href="#v:filterM" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:filter" title="Streamly.Internal.Data.Stream.IsStream.Transform">filter</a></code> but with a monadic predicate.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:uniq" class="def">uniq</a> :: (<a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#uniq" class="link">Source</a> <a href="#v:uniq" class="selflink">#</a></p><div class="doc"><p>Drop repeated elements that are adjacent to each other.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:uniqBy" class="def">uniqBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#uniqBy" class="link">Source</a> <a href="#v:uniqBy" class="selflink">#</a></p><div class="doc"><p>Drop repeated elements that are adjacent to each other using the supplied
 comparison function.</p><p>@uniq = uniqBy (==)</p><p>To strip duplicate path separators:</p><pre>f x y = x == <code><a href="../base-4.16.4.0/Prelude.html#v:-47-" title="Prelude">/</a></code> &amp;&amp; x == y
Stream.toList $ Stream.uniqBy f $ Stream.fromList &quot;/<em>a</em>/b&quot;
&quot;<em>a</em>b&quot;
</pre><p>Space: <code>O(1)</code></p><p>See also: <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:nubBy" title="Streamly.Internal.Data.Stream.IsStream.Transform">nubBy</a></code>.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:nubBy" class="def">nubBy</a> :: (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#nubBy" class="link">Source</a> <a href="#v:nubBy" class="selflink">#</a></p><div class="doc"><p>Drop repeated elements anywhere in the stream.</p><p><em>Caution: not scalable for infinite streams</em></p><p><em>See also: nubWindowBy</em></p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:nubWindowBy" class="def">nubWindowBy</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#nubWindowBy" class="link">Source</a> <a href="#v:nubWindowBy" class="selflink">#</a></p><div class="doc"><p>Drop repeated elements within the specified tumbling window in the stream.</p><pre>nubBy = nubWindowBy maxBound</pre><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:prune" class="def">prune</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#prune" class="link">Source</a> <a href="#v:prune" class="selflink">#</a></p><div class="doc"><p>Strip all leading and trailing occurrences of an element passing a
 predicate and make all other consecutive occurrences uniq.</p><pre>prune p = dropWhileAround p $ uniqBy (x y -&gt; p x &amp;&amp; p y)
</pre><pre>&gt; Stream.prune isSpace (Stream.fromList &quot;  hello      world!   &quot;)
&quot;hello world!&quot;

</pre><p>Space: <code>O(1)</code></p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:repeated" class="def">repeated</a> :: t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#repeated" class="link">Source</a> <a href="#v:repeated" class="selflink">#</a></p><div class="doc"><p>Emit only repeated elements, once.</p><p><em>Unimplemented</em></p></div></div><a href="#g:8" id="g:8"><h1>Trimming</h1></a><div class="doc"><p>Produce a subset of the stream trimmed at ends.</p></div><div class="top"><p class="src"><a id="v:take" class="def">take</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#take" class="link">Source</a> <a href="#v:take" class="selflink">#</a></p><div class="doc"><p>Take first <code>n</code> elements from the stream and discard the rest.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:takeInterval" class="def">takeInterval</a> :: (<a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Data-Time-Units.html#t:TimeUnit64" title="Streamly.Internal.Data.Time.Units">TimeUnit64</a> d) =&gt; d -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#takeInterval" class="link">Source</a> <a href="#v:takeInterval" class="selflink">#</a></p><div class="doc"><p><code>takeInterval duration</code> yields stream elements upto specified time
 <code>duration</code>. The duration starts when the stream is evaluated for the first
 time, before the first element is yielded. The time duration is checked
 before generating each element, if the duration has expired the stream
 stops.</p><p>The total time taken in executing the stream is guaranteed to be <em>at least</em>
 <code>duration</code>, however, because the duration is checked before generating an
 element, the upper bound is indeterminate and depends on the time taken in
 generating and processing the last element.</p><p>No element is yielded if the duration is zero. At least one element is
 yielded if the duration is non-zero.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:takeLast" class="def">takeLast</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#takeLast" class="link">Source</a> <a href="#v:takeLast" class="selflink">#</a></p><div class="doc"><p>Take <code>n</code> elements at the end of the stream.</p><p>O(n) space, where n is the number elements taken.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:takeLastInterval" class="def">takeLastInterval</a> :: <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#takeLastInterval" class="link">Source</a> <a href="#v:takeLastInterval" class="selflink">#</a></p><div class="doc"><p>Take time interval <code>i</code> seconds at the end of the stream.</p><p>O(n) space, where n is the number elements taken.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:takeWhile" class="def">takeWhile</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#takeWhile" class="link">Source</a> <a href="#v:takeWhile" class="selflink">#</a></p><div class="doc"><p>End the stream as soon as the predicate fails on an element.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:takeWhileM" class="def">takeWhileM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#takeWhileM" class="link">Source</a> <a href="#v:takeWhileM" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:takeWhile" title="Streamly.Internal.Data.Stream.IsStream.Transform">takeWhile</a></code> but with a monadic predicate.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:takeWhileLast" class="def">takeWhileLast</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#takeWhileLast" class="link">Source</a> <a href="#v:takeWhileLast" class="selflink">#</a></p><div class="doc"><p>Take all consecutive elements at the end of the stream for which the
 predicate is true.</p><p>O(n) space, where n is the number elements taken.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:takeWhileAround" class="def">takeWhileAround</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#takeWhileAround" class="link">Source</a> <a href="#v:takeWhileAround" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:takeWhile" title="Streamly.Internal.Data.Stream.IsStream.Transform">takeWhile</a></code> and <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:takeWhileLast" title="Streamly.Internal.Data.Stream.IsStream.Transform">takeWhileLast</a></code> combined.</p><p>O(n) space, where n is the number elements taken from the end.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:drop" class="def">drop</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#drop" class="link">Source</a> <a href="#v:drop" class="selflink">#</a></p><div class="doc"><p>Discard first <code>n</code> elements from the stream and take the rest.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:dropInterval" class="def">dropInterval</a> :: (<a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Data-Time-Units.html#t:TimeUnit64" title="Streamly.Internal.Data.Time.Units">TimeUnit64</a> d) =&gt; d -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#dropInterval" class="link">Source</a> <a href="#v:dropInterval" class="selflink">#</a></p><div class="doc"><p><code>dropInterval duration</code> drops stream elements until specified <code>duration</code> has
 passed.  The duration begins when the stream is evaluated for the first
 time. The time duration is checked <em>after</em> generating a stream element, the
 element is yielded if the duration has expired otherwise it is dropped.</p><p>The time elapsed before starting to generate the first element is <em>at most</em>
 <code>duration</code>, however, because the duration expiry is checked after the
 element is generated, the lower bound is indeterminate and depends on the
 time taken in generating an element.</p><p>All elements are yielded if the duration is zero.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:dropLast" class="def">dropLast</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#dropLast" class="link">Source</a> <a href="#v:dropLast" class="selflink">#</a></p><div class="doc"><p>Drop <code>n</code> elements at the end of the stream.</p><p>O(n) space, where n is the number elements dropped.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:dropLastInterval" class="def">dropLastInterval</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#dropLastInterval" class="link">Source</a> <a href="#v:dropLastInterval" class="selflink">#</a></p><div class="doc"><p>Drop time interval <code>i</code> seconds at the end of the stream.</p><p>O(n) space, where n is the number elements dropped.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:dropWhile" class="def">dropWhile</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#dropWhile" class="link">Source</a> <a href="#v:dropWhile" class="selflink">#</a></p><div class="doc"><p>Drop elements in the stream as long as the predicate succeeds and then
 take the rest of the stream.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:dropWhileM" class="def">dropWhileM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#dropWhileM" class="link">Source</a> <a href="#v:dropWhileM" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:dropWhile" title="Streamly.Internal.Data.Stream.IsStream.Transform">dropWhile</a></code> but with a monadic predicate.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:dropWhileLast" class="def">dropWhileLast</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#dropWhileLast" class="link">Source</a> <a href="#v:dropWhileLast" class="selflink">#</a></p><div class="doc"><p>Drop all consecutive elements at the end of the stream for which the
 predicate is true.</p><p>O(n) space, where n is the number elements dropped.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:dropWhileAround" class="def">dropWhileAround</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#dropWhileAround" class="link">Source</a> <a href="#v:dropWhileAround" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:dropWhile" title="Streamly.Internal.Data.Stream.IsStream.Transform">dropWhile</a></code> and <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:dropWhileLast" title="Streamly.Internal.Data.Stream.IsStream.Transform">dropWhileLast</a></code> combined.</p><p>O(n) space, where n is the number elements dropped from the end.</p><p><em>Unimplemented</em></p></div></div><a href="#g:9" id="g:9"><h1>Inserting Elements</h1></a><div class="doc"><p>Produce a superset of the stream. This is the opposite of
 filtering/sampling.  We can always use concatMap and scan for inserting
 but these combinators are more efficient and convenient.</p></div><div class="top"><p class="src"><a id="v:intersperse" class="def">intersperse</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#intersperse" class="link">Source</a> <a href="#v:intersperse" class="selflink">#</a></p><div class="doc"><p>Insert a pure value between successive elements of a stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.intersperse ',' $ Stream.fromList &quot;hello&quot;
</code></strong>&quot;h,e,l,l,o&quot;
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:intersperseM" class="def">intersperseM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#intersperseM" class="link">Source</a> <a href="#v:intersperseM" class="selflink">#</a></p><div class="doc"><p>Insert an effect and its output before consuming an element of a stream
 except the first one.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.trace putChar $ Stream.intersperseM (putChar '.' &gt;&gt; return ',') $ Stream.fromList &quot;hello&quot;
</code></strong>h.,e.,l.,l.,o&quot;h,e,l,l,o&quot;
</pre><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:intersperseBySpan" class="def">intersperseBySpan</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#intersperseBySpan" class="link">Source</a> <a href="#v:intersperseBySpan" class="selflink">#</a></p><div class="doc"><p>Intersperse a monadic action into the input stream after every <code>n</code>
 elements.</p><pre>&gt; Stream.toList $ Stream.intersperseBySpan 2 (return ',') $ Stream.fromList &quot;hello&quot;
&quot;he,ll,o&quot;

</pre><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:intersperseSuffix" class="def">intersperseSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#intersperseSuffix" class="link">Source</a> <a href="#v:intersperseSuffix" class="selflink">#</a></p><div class="doc"><p>Insert an effect and its output after consuming an element of a stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.trace putChar $ intersperseSuffix (putChar '.' &gt;&gt; return ',') $ Stream.fromList &quot;hello&quot;
</code></strong>h.,e.,l.,l.,o.,&quot;h,e,l,l,o,&quot;
</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:intersperseSuffixBySpan" class="def">intersperseSuffixBySpan</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#intersperseSuffixBySpan" class="link">Source</a> <a href="#v:intersperseSuffixBySpan" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:intersperseSuffix" title="Streamly.Internal.Data.Stream.IsStream.Transform">intersperseSuffix</a></code> but intersperses an effectful action into the
 input stream after every <code>n</code> elements and after the last element.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.intersperseSuffixBySpan 2 (return ',') $ Stream.fromList &quot;hello&quot;
</code></strong>&quot;he,ll,o,&quot;
</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:interjectSuffix" class="def">interjectSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#interjectSuffix" class="link">Source</a> <a href="#v:interjectSuffix" class="selflink">#</a></p><div class="doc"><p>Intersperse a monadic action into the input stream after every <code>n</code>
 seconds.</p><pre>&gt; import Control.Concurrent (threadDelay)
&gt; Stream.drain $ Stream.interjectSuffix 1 (putChar ',') $ Stream.mapM (x -&gt; threadDelay 1000000 &gt;&gt; putChar x) $ Stream.fromList &quot;hello&quot;
h,e,l,l,o
</pre><p><em>Pre-release</em></p></div></div><a href="#g:10" id="g:10"><h1>Inserting Side Effects/Time</h1></a><div class="top"><p class="src"><a id="v:intersperseM_" class="def">intersperseM_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#intersperseM_" class="link">Source</a> <a href="#v:intersperseM_" class="selflink">#</a></p><div class="doc"><p>Insert a side effect before consuming an element of a stream except the
 first one.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.drain $ Stream.trace putChar $ Stream.intersperseM_ (putChar '.') $ Stream.fromList &quot;hello&quot;
</code></strong>h.e.l.l.o
</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:delay" class="def">delay</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#delay" class="link">Source</a> <a href="#v:delay" class="selflink">#</a></p><div class="doc"><p>Introduce a delay of specified seconds before consuming an element of the
 stream except the first one.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.mapM_ print $ Stream.timestamped $ Stream.delay 1 $ Stream.enumerateFromTo 1 3
</code></strong>(AbsTime (TimeSpec {sec = ..., nsec = ...}),1)
(AbsTime (TimeSpec {sec = ..., nsec = ...}),2)
(AbsTime (TimeSpec {sec = ..., nsec = ...}),3)
</pre><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:intersperseSuffix_" class="def">intersperseSuffix_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#intersperseSuffix_" class="link">Source</a> <a href="#v:intersperseSuffix_" class="selflink">#</a></p><div class="doc"><p>Insert a side effect after consuming an element of a stream.</p><pre>&gt;&gt;&gt; Stream.mapM_ putChar $ Stream.intersperseSuffix_ (threadDelay 1000000) $ Stream.fromList &quot;hello&quot;
hello

</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:delayPost" class="def">delayPost</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#delayPost" class="link">Source</a> <a href="#v:delayPost" class="selflink">#</a></p><div class="doc"><p>Introduce a delay of specified seconds after consuming an element of a
 stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.mapM_ print $ Stream.timestamped $ Stream.delayPost 1 $ Stream.enumerateFromTo 1 3
</code></strong>(AbsTime (TimeSpec {sec = ..., nsec = ...}),1)
(AbsTime (TimeSpec {sec = ..., nsec = ...}),2)
(AbsTime (TimeSpec {sec = ..., nsec = ...}),3)
</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:interspersePrefix_" class="def">interspersePrefix_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#interspersePrefix_" class="link">Source</a> <a href="#v:interspersePrefix_" class="selflink">#</a></p><div class="doc"><p>Insert a side effect before consuming an element of a stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.trace putChar $ Stream.interspersePrefix_ (putChar '.' &gt;&gt; return ',') $ Stream.fromList &quot;hello&quot;
</code></strong>.h.e.l.l.o&quot;hello&quot;
</pre><p>Same as <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:trace_" title="Streamly.Internal.Data.Stream.IsStream.Transform">trace_</a></code> but may be concurrent.</p><p><em>Concurrent</em></p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:delayPre" class="def">delayPre</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#delayPre" class="link">Source</a> <a href="#v:delayPre" class="selflink">#</a></p><div class="doc"><p>Introduce a delay of specified seconds before consuming an element of a
 stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.mapM_ print $ Stream.timestamped $ Stream.delayPre 1 $ Stream.enumerateFromTo 1 3
</code></strong>(AbsTime (TimeSpec {sec = ..., nsec = ...}),1)
(AbsTime (TimeSpec {sec = ..., nsec = ...}),2)
(AbsTime (TimeSpec {sec = ..., nsec = ...}),3)
</pre><p><em>Pre-release</em></p></div></div><a href="#g:11" id="g:11"><h1>Element Aware Insertion</h1></a><div class="doc"><p>Opposite of filtering</p></div><div class="top"><p class="src"><a id="v:insertBy" class="def">insertBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#insertBy" class="link">Source</a> <a href="#v:insertBy" class="selflink">#</a></p><div class="doc"><p><code>insertBy cmp elem stream</code> inserts <code>elem</code> before the first element in
 <code>stream</code> that is less than <code>elem</code> when compared using <code>cmp</code>.</p><pre>insertBy cmp x = <code>mergeBy</code> cmp (<code>fromPure</code> x)
</pre><pre>&gt;&gt;&gt; Stream.toList $ Stream.insertBy compare 2 $ Stream.fromList [1,3,5]
[1,2,3,5]

</pre><p><em>Since: 0.6.0</em></p></div></div><a href="#g:12" id="g:12"><h1>Reordering</h1></a><div class="top"><p class="src"><a id="v:reverse" class="def">reverse</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#reverse" class="link">Source</a> <a href="#v:reverse" class="selflink">#</a></p><div class="doc"><p>Returns the elements of the stream in reverse order.  The stream must be
 finite. Note that this necessarily buffers the entire stream in memory.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>reverse = Stream.foldlT (flip Stream.cons) Stream.nil
</code></strong></pre><p><em>Since 0.7.0 (Monad m constraint)</em></p><p><em>Since: 0.1.1</em></p></div></div><div class="top"><p class="src"><a id="v:reverse-39-" class="def">reverse'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="../base-4.16.4.0/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#reverse%27" class="link">Source</a> <a href="#v:reverse-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:reverse" title="Streamly.Internal.Data.Stream.IsStream.Transform">reverse</a></code> but several times faster, requires a <code><a href="../base-4.16.4.0/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a></code> instance.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:reassembleBy" class="def">reassembleBy</a> :: <a href="Streamly-Internal-Data-Fold-Type.html#t:Fold" title="Streamly.Internal.Data.Fold.Type">Fold</a> m a b -&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#reassembleBy" class="link">Source</a> <a href="#v:reassembleBy" class="selflink">#</a></p><div class="doc"><p>Buffer until the next element in sequence arrives. The function argument
 determines the difference in sequence numbers. This could be useful in
 implementing sequenced streams, for example, TCP reassembly.</p><p><em>Unimplemented</em></p></div></div><a href="#g:13" id="g:13"><h1>Position Indexing</h1></a><div class="top"><p class="src"><a id="v:indexed" class="def">indexed</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m (<a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>, a) <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#indexed" class="link">Source</a> <a href="#v:indexed" class="selflink">#</a></p><div class="doc"><pre>indexed = Stream.postscanl' (\(i, _) x -&gt; (i + 1, x)) (-1,undefined)
indexed = Stream.zipWith (,) (Stream.enumerateFrom 0)</pre><p>Pair each element in a stream with its index, starting from index 0.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.indexed $ Stream.fromList &quot;hello&quot;
</code></strong>[(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:indexedR" class="def">indexedR</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m (<a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>, a) <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#indexedR" class="link">Source</a> <a href="#v:indexedR" class="selflink">#</a></p><div class="doc"><pre>indexedR n = Stream.postscanl' (\(i, _) x -&gt; (i - 1, x)) (n + 1,undefined)
indexedR n = Stream.zipWith (,) (Stream.enumerateFromThen n (n - 1))</pre><p>Pair each element in a stream with its index, starting from the
 given index <code>n</code> and counting down.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.indexedR 10 $ Stream.fromList &quot;hello&quot;
</code></strong>[(10,'h'),(9,'e'),(8,'l'),(7,'l'),(6,'o')]
</pre><p><em>Since: 0.6.0</em></p></div></div><a href="#g:14" id="g:14"><h1>Time Indexing</h1></a><div class="top"><p class="src"><a id="v:timestamped" class="def">timestamped</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m a -&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>, a) <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#timestamped" class="link">Source</a> <a href="#v:timestamped" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:timestampWith" class="def">timestampWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>, a) <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#timestampWith" class="link">Source</a> <a href="#v:timestampWith" class="selflink">#</a></p><div class="doc"><p>Pair each element in a stream with an absolute timestamp, using a clock of
 specified granularity.  The timestamp is generated just before the element
 is consumed.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.mapM_ print $ Stream.timestampWith 0.01 $ Stream.delay 1 $ Stream.enumerateFromTo 1 3
</code></strong>(AbsTime (TimeSpec {sec = ..., nsec = ...}),1)
(AbsTime (TimeSpec {sec = ..., nsec = ...}),2)
(AbsTime (TimeSpec {sec = ..., nsec = ...}),3)
</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:timeIndexed" class="def">timeIndexed</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m a -&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:RelTime64" title="Streamly.Internal.Data.Time.Units">RelTime64</a>, a) <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#timeIndexed" class="link">Source</a> <a href="#v:timeIndexed" class="selflink">#</a></p><div class="doc"><p>Pair each element in a stream with relative times starting from 0, using a
 10 ms granularity clock. The time is measured just before the element is
 consumed.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.mapM_ print $ Stream.timeIndexed $ Stream.delay 1 $ Stream.enumerateFromTo 1 3
</code></strong>(RelTime64 (NanoSecond64 ...),1)
(RelTime64 (NanoSecond64 ...),2)
(RelTime64 (NanoSecond64 ...),3)
</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:timeIndexWith" class="def">timeIndexWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:RelTime64" title="Streamly.Internal.Data.Time.Units">RelTime64</a>, a) <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#timeIndexWith" class="link">Source</a> <a href="#v:timeIndexWith" class="selflink">#</a></p><div class="doc"><p>Pair each element in a stream with relative times starting from 0, using a
 clock with the specified granularity. The time is measured just before the
 element is consumed.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.mapM_ print $ Stream.timeIndexWith 0.01 $ Stream.delay 1 $ Stream.enumerateFromTo 1 3
</code></strong>(RelTime64 (NanoSecond64 ...),1)
(RelTime64 (NanoSecond64 ...),2)
(RelTime64 (NanoSecond64 ...),3)
</pre><p><em>Pre-release</em></p></div></div><a href="#g:15" id="g:15"><h1>Searching</h1></a><div class="top"><p class="src"><a id="v:findIndices" class="def">findIndices</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#findIndices" class="link">Source</a> <a href="#v:findIndices" class="selflink">#</a></p><div class="doc"><p>Find all the indices where the element in the stream satisfies the given
 predicate.</p><pre>findIndices = fold Fold.findIndices</pre><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:elemIndices" class="def">elemIndices</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; t m a -&gt; t m <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#elemIndices" class="link">Source</a> <a href="#v:elemIndices" class="selflink">#</a></p><div class="doc"><p>Find all the indices where the value of the element in the stream is equal
 to the given value.</p><pre>elemIndices a = findIndices (== a)</pre><p><em>Since: 0.5.0</em></p></div></div><a href="#g:16" id="g:16"><h1>Rolling map</h1></a><div class="doc"><p>Map using the previous element.</p></div><div class="top"><p class="src"><a id="v:rollingMapM" class="def">rollingMapM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#rollingMapM" class="link">Source</a> <a href="#v:rollingMapM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:rollingMap" title="Streamly.Internal.Data.Stream.IsStream.Transform">rollingMap</a></code> but with an effectful map function.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:rollingMap" class="def">rollingMap</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#rollingMap" class="link">Source</a> <a href="#v:rollingMap" class="selflink">#</a></p><div class="doc"><p>Apply a function on every two successive elements of a stream. If the
 stream consists of a single element the output is an empty stream.</p><p>This is the stream equivalent of the list idiom <code>zipWith f xs (tail xs)</code>.</p><p><em>Pre-release</em></p></div></div><a href="#g:17" id="g:17"><h1>Maybe Streams</h1></a><div class="top"><p class="src"><a id="v:catMaybes" class="def">catMaybes</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m (<a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#catMaybes" class="link">Source</a> <a href="#v:catMaybes" class="selflink">#</a></p><div class="doc"><p>In a stream of <code><a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code>s, discard <code><a href="../base-4.16.4.0/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>s and unwrap <code><a href="../base-4.16.4.0/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code>s.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:mapMaybe" class="def">mapMaybe</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#mapMaybe" class="link">Source</a> <a href="#v:mapMaybe" class="selflink">#</a></p><div class="doc"><p>Map a <code><a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> returning function to a stream, filter out the <code><a href="../base-4.16.4.0/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>
 elements, and return a stream of values extracted from <code><a href="../base-4.16.4.0/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code>.</p><p>Equivalent to:</p><pre>mapMaybe f = Stream.map <code><a href="../base-4.16.4.0/Data-Maybe.html#v:fromJust" title="Data.Maybe">fromJust</a></code> . Stream.filter <code><a href="../base-4.16.4.0/Data-Maybe.html#v:isJust" title="Data.Maybe">isJust</a></code> . Stream.map f
</pre><p><em>Since: 0.3.0</em></p></div></div><div class="top"><p class="src"><a id="v:mapMaybeM" class="def">mapMaybeM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; (a -&gt; m (<a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b)) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#mapMaybeM" class="link">Source</a> <a href="#v:mapMaybeM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:mapMaybe" title="Streamly.Internal.Data.Stream.IsStream.Transform">mapMaybe</a></code> but maps a monadic function.</p><p>Equivalent to:</p><pre>mapMaybeM f = Stream.map <code><a href="../base-4.16.4.0/Data-Maybe.html#v:fromJust" title="Data.Maybe">fromJust</a></code> . Stream.filter <code><a href="../base-4.16.4.0/Data-Maybe.html#v:isJust" title="Data.Maybe">isJust</a></code> . Stream.mapM f
</pre><p><em>Concurrent (do not use with <code>fromParallel</code> on infinite streams)</em></p><p><em>Since: 0.3.0</em></p></div></div><a href="#g:18" id="g:18"><h1>Either Streams</h1></a><div class="top"><p class="src"><a id="v:lefts" class="def">lefts</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#lefts" class="link">Source</a> <a href="#v:lefts" class="selflink">#</a></p><div class="doc"><p>Discard <code><a href="../base-4.16.4.0/Data-Either.html#v:Right" title="Data.Either">Right</a></code>s and unwrap <code><a href="../base-4.16.4.0/Data-Either.html#v:Left" title="Data.Either">Left</a></code>s in an <code><a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a></code> stream.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:rights" class="def">rights</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#rights" class="link">Source</a> <a href="#v:rights" class="selflink">#</a></p><div class="doc"><p>Discard <code><a href="../base-4.16.4.0/Data-Either.html#v:Left" title="Data.Either">Left</a></code>s and unwrap <code><a href="../base-4.16.4.0/Data-Either.html#v:Right" title="Data.Either">Right</a></code>s in an <code><a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a></code> stream.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:both" class="def">both</a> :: <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m) =&gt; t m (<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#both" class="link">Source</a> <a href="#v:both" class="selflink">#</a></p><div class="doc"><p>Remove the either wrapper and flatten both lefts and as well as rights in
 the output stream.</p><p><em>Pre-release</em></p></div></div><a href="#g:19" id="g:19"><h1>Concurrent Evaluation</h1></a><a href="#g:20" id="g:20"><h2>Concurrent Pipelines</h2></a><div class="doc"><p>Run streaming stages concurrently.</p></div><div class="top"><p class="src"><a id="v:mkAsync" class="def">mkAsync</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#mkAsync" class="link">Source</a> <a href="#v:mkAsync" class="selflink">#</a></p><div class="doc"><p>Make the stream producer and consumer run concurrently by introducing a
 buffer between them. The producer thread evaluates the input stream until
 the buffer fills, it terminates if the buffer is full and a worker thread is
 kicked off again to evaluate the remaining stream when there is space in the
 buffer.  The consumer consumes the stream lazily from the buffer.</p><p><em>Since: 0.2.0 (Streamly)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:mkParallel" class="def">mkParallel</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Common.html#mkParallel" class="link">Source</a> <a href="#v:mkParallel" class="selflink">#</a></p><div class="doc"><p>Make the stream producer and consumer run concurrently by introducing a
 buffer between them. The producer thread evaluates the input stream until
 the buffer fills, it blocks if the buffer is full until there is space in
 the buffer. The consumer consumes the stream lazily from the buffer.</p><pre>mkParallel = IsStream.fromStreamD . mkParallelD . IsStream.toStreamD</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:applyAsync" class="def">applyAsync</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; (t m a -&gt; t m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#applyAsync" class="link">Source</a> <a href="#v:applyAsync" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:-124--36-" title="Streamly.Internal.Data.Stream.IsStream.Transform">|$</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:-124--36-" class="def">(|$)</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; (t m a -&gt; t m b) -&gt; t m a -&gt; t m b <span class="fixity">infixr 0</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#%7C%24" class="link">Source</a> <a href="#v:-124--36-" class="selflink">#</a></p><div class="doc"><p>Parallel transform application operator; applies a stream transformation
 function <code>t m a -&gt; t m b</code> to a stream <code>t m a</code> concurrently; the input stream
 is evaluated asynchronously in an independent thread yielding elements to a
 buffer and the transformation function runs in another thread consuming the
 input from the buffer.  <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:-124--36-" title="Streamly.Internal.Data.Stream.IsStream.Transform">|$</a></code> is just like regular function application
 operator <code><a href="../base-4.16.4.0/Data-Function.html#v:-36-" title="Data.Function">$</a></code> except that it is concurrent.</p><p>If you read the signature as <code>(t m a -&gt; t m b) -&gt; (t m a -&gt; t m b)</code> you can
 look at it as a transformation that converts a transform function to a
 buffered concurrent transform function.</p><p>The following code prints a value every second even though each stage adds a
 1 second delay.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>Stream.drain $
   Stream.mapM (\x -&gt; threadDelay 1000000 &gt;&gt; print x)
     |$ Stream.replicateM 3 (threadDelay 1000000 &gt;&gt; return 1)
:}
1
1
1
</pre><p><em>Concurrent</em></p><p><em>Since: 0.3.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:-124--38-" class="def">(|&amp;)</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m) =&gt; t m a -&gt; (t m a -&gt; t m b) -&gt; t m b <span class="fixity">infixl 1</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#%7C%26" class="link">Source</a> <a href="#v:-124--38-" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:-124--36-" title="Streamly.Internal.Data.Stream.IsStream.Transform">|$</a></code> but with arguments reversed.</p><p>(|&amp;) = flip (|$)</p><p><em>Concurrent</em></p><p><em>Since: 0.3.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><a href="#g:21" id="g:21"><h2>Concurrency Control</h2></a><div class="top"><p class="src"><a id="v:maxThreads" class="def">maxThreads</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Combinators.html#maxThreads" class="link">Source</a> <a href="#v:maxThreads" class="selflink">#</a></p><div class="doc"><p>Specify the maximum number of threads that can be spawned concurrently for
 any concurrent combinator in a stream.
 A value of 0 resets the thread limit to default, a negative value means
 there is no limit. The default value is 1500. <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:maxThreads" title="Streamly.Internal.Data.Stream.IsStream.Transform">maxThreads</a></code> does not affect
 <code>ParallelT</code> streams as they can use unbounded number of threads.</p><p>When the actions in a stream are IO bound, having blocking IO calls, this
 option can be used to control the maximum number of in-flight IO requests.
 When the actions are CPU bound this option can be used to
 control the amount of CPU used by the stream.</p><p><em>Since: 0.4.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><a href="#g:22" id="g:22"><h2>Buffering and Sampling</h2></a><div class="doc"><p>Evaluate strictly using a buffer of results.  When the buffer becomes
 full we can block, drop the new elements, drop the oldest element and
 insert the new at the end or keep dropping elements uniformly to match
 the rate of the consumer.</p></div><div class="top"><p class="src"><a id="v:maxBuffer" class="def">maxBuffer</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Combinators.html#maxBuffer" class="link">Source</a> <a href="#v:maxBuffer" class="selflink">#</a></p><div class="doc"><p>Specify the maximum size of the buffer for storing the results from
 concurrent computations. If the buffer becomes full we stop spawning more
 concurrent tasks until there is space in the buffer.
 A value of 0 resets the buffer size to default, a negative value means
 there is no limit. The default value is 1500.</p><p>CAUTION! using an unbounded <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:maxBuffer" title="Streamly.Internal.Data.Stream.IsStream.Transform">maxBuffer</a></code> value (i.e. a negative value)
 coupled with an unbounded <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:maxThreads" title="Streamly.Internal.Data.Stream.IsStream.Transform">maxThreads</a></code> value is a recipe for disaster in
 presence of infinite streams, or very large streams.  Especially, it must
 not be used when <code><a href="../base-4.16.4.0/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> is used in <code>ZipAsyncM</code> streams as <code><a href="../base-4.16.4.0/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> in
 applicative zip streams generates an infinite stream causing unbounded
 concurrent generation with no limit on the buffer or threads.</p><p><em>Since: 0.4.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:sampleOld" class="def">sampleOld</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#sampleOld" class="link">Source</a> <a href="#v:sampleOld" class="selflink">#</a></p><div class="doc"><p>Evaluate the input stream continuously and keep only the oldest <code>n</code>
 elements in the buffer, discard the new ones when the buffer is full.  When
 the output stream is evaluated it consumes the values from the buffer in a
 FIFO manner.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:sampleNew" class="def">sampleNew</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#sampleNew" class="link">Source</a> <a href="#v:sampleNew" class="selflink">#</a></p><div class="doc"><p>Evaluate the input stream continuously and keep only the latest <code>n</code>
 elements in a ring buffer, keep discarding the older ones to make space for
 the new ones.  When the output stream is evaluated it consumes the values
 from the buffer in a FIFO manner.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:sampleRate" class="def">sampleRate</a> :: <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#sampleRate" class="link">Source</a> <a href="#v:sampleRate" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:sampleNew" title="Streamly.Internal.Data.Stream.IsStream.Transform">sampleNew</a></code> but samples at uniform intervals to match the consumer
 rate. Note that <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:sampleNew" title="Streamly.Internal.Data.Stream.IsStream.Transform">sampleNew</a></code> leads to non-uniform sampling depending on the
 consumer pattern.</p><p><em>Unimplemented</em></p></div></div><a href="#g:23" id="g:23"><h2>Rate Limiting</h2></a><div class="doc"><p>Evaluate the stream at uniform intervals to maintain a specified
 evaluation rate.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Rate" class="def">Rate</a> <a href="src/Streamly.Internal.Data.SVar.Type.html#Rate" class="link">Source</a> <a href="#t:Rate" class="selflink">#</a></p><div class="doc"><p>Specifies the stream yield rate in yields per second (<code>Hertz</code>).
 We keep accumulating yield credits at <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:rateGoal" title="Streamly.Internal.Data.Stream.IsStream.Transform">rateGoal</a></code>. At any point of time we
 allow only as many yields as we have accumulated as per <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:rateGoal" title="Streamly.Internal.Data.Stream.IsStream.Transform">rateGoal</a></code> since the
 start of time. If the consumer or the producer is slower or faster, the
 actual rate may fall behind or exceed <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:rateGoal" title="Streamly.Internal.Data.Stream.IsStream.Transform">rateGoal</a></code>.  We try to recover the gap
 between the two by increasing or decreasing the pull rate from the producer.
 However, if the gap becomes more than <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:rateBuffer" title="Streamly.Internal.Data.Stream.IsStream.Transform">rateBuffer</a></code> we try to recover only as
 much as <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:rateBuffer" title="Streamly.Internal.Data.Stream.IsStream.Transform">rateBuffer</a></code>.</p><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:rateLow" title="Streamly.Internal.Data.Stream.IsStream.Transform">rateLow</a></code> puts a bound on how low the instantaneous rate can go when
 recovering the rate gap.  In other words, it determines the maximum yield
 latency.  Similarly, <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:rateHigh" title="Streamly.Internal.Data.Stream.IsStream.Transform">rateHigh</a></code> puts a bound on how high the instantaneous
 rate can go when recovering the rate gap.  In other words, it determines the
 minimum yield latency. We reduce the latency by increasing concurrency,
 therefore we can say that it puts an upper bound on concurrency.</p><p>If the <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:rateGoal" title="Streamly.Internal.Data.Stream.IsStream.Transform">rateGoal</a></code> is 0 or negative the stream never yields a value.
 If the <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:rateBuffer" title="Streamly.Internal.Data.Stream.IsStream.Transform">rateBuffer</a></code> is 0 or negative we do not attempt to recover.</p><p><em>Since: 0.5.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Rate" class="def">Rate</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:rateLow" class="def">rateLow</a> :: <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a></dfn><div class="doc"><p>The lower rate limit</p></div></li><li><dfn class="src"><a id="v:rateGoal" class="def">rateGoal</a> :: <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a></dfn><div class="doc"><p>The target rate we want to achieve</p></div></li><li><dfn class="src"><a id="v:rateHigh" class="def">rateHigh</a> :: <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a></dfn><div class="doc"><p>The upper rate limit</p></div></li><li><dfn class="src"><a id="v:rateBuffer" class="def">rateBuffer</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a></dfn><div class="doc"><p>Maximum slack from the goal</p></div></li></ul></div></td></tr></table></div></div><div class="top"><p class="src"><a id="v:rate" class="def">rate</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#t:Rate" title="Streamly.Internal.Data.Stream.IsStream.Transform">Rate</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Combinators.html#rate" class="link">Source</a> <a href="#v:rate" class="selflink">#</a></p><div class="doc"><p>Specify the pull rate of a stream.
 A <code><a href="../base-4.16.4.0/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> value resets the rate to default which is unlimited.  When the
 rate is specified, concurrent production may be ramped up or down
 automatically to achieve the specified yield rate. The specific behavior for
 different styles of <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#t:Rate" title="Streamly.Internal.Data.Stream.IsStream.Transform">Rate</a></code> specifications is documented under <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#t:Rate" title="Streamly.Internal.Data.Stream.IsStream.Transform">Rate</a></code>.  The
 effective maximum production rate achieved by a stream is governed by:</p><ul><li>The <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:maxThreads" title="Streamly.Internal.Data.Stream.IsStream.Transform">maxThreads</a></code> limit</li><li>The <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:maxBuffer" title="Streamly.Internal.Data.Stream.IsStream.Transform">maxBuffer</a></code> limit</li><li>The maximum rate that the stream producer can achieve</li><li>The maximum rate that the stream consumer can achieve</li></ul><p><em>Since: 0.5.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:avgRate" class="def">avgRate</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Combinators.html#avgRate" class="link">Source</a> <a href="#v:avgRate" class="selflink">#</a></p><div class="doc"><p>Same as <code>rate (Just $ Rate (r/2) r (2*r) maxBound)</code></p><p>Specifies the average production rate of a stream in number of yields
 per second (i.e.  <code>Hertz</code>).  Concurrent production is ramped up or down
 automatically to achieve the specified average yield rate. The rate can
 go down to half of the specified rate on the lower side and double of
 the specified rate on the higher side.</p><p><em>Since: 0.5.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:minRate" class="def">minRate</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Combinators.html#minRate" class="link">Source</a> <a href="#v:minRate" class="selflink">#</a></p><div class="doc"><p>Same as <code>rate (Just $ Rate r r (2*r) maxBound)</code></p><p>Specifies the minimum rate at which the stream should yield values. As
 far as possible the yield rate would never be allowed to go below the
 specified rate, even though it may possibly go above it at times, the
 upper limit is double of the specified rate.</p><p><em>Since: 0.5.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:maxRate" class="def">maxRate</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Combinators.html#maxRate" class="link">Source</a> <a href="#v:maxRate" class="selflink">#</a></p><div class="doc"><p>Same as <code>rate (Just $ Rate (r/2) r r maxBound)</code></p><p>Specifies the maximum rate at which the stream should yield values. As
 far as possible the yield rate would never be allowed to go above the
 specified rate, even though it may possibly go below it at times, the
 lower limit is half of the specified rate. This can be useful in
 applications where certain resource usage must not be allowed to go
 beyond certain limits.</p><p><em>Since: 0.5.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:constRate" class="def">constRate</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Combinators.html#constRate" class="link">Source</a> <a href="#v:constRate" class="selflink">#</a></p><div class="doc"><p>Same as <code>rate (Just $ Rate r r r 0)</code></p><p>Specifies a constant yield rate. If for some reason the actual rate
 goes above or below the specified rate we do not try to recover it by
 increasing or decreasing the rate in future.  This can be useful in
 applications like graphics frame refresh where we need to maintain a
 constant refresh rate.</p><p><em>Since: 0.5.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><a href="#g:24" id="g:24"><h1>Diagnostics</h1></a><div class="top"><p class="src"><a id="v:inspectMode" class="def">inspectMode</a> :: <a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Combinators.html#inspectMode" class="link">Source</a> <a href="#v:inspectMode" class="selflink">#</a></p><div class="doc"><p>Print debug information about an SVar when the stream ends</p><p><em>Pre-release</em></p></div></div><a href="#g:25" id="g:25"><h1>Deprecated</h1></a><div class="top"><p class="src"><a id="v:scanx" class="def">scanx</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (x -&gt; a -&gt; x) -&gt; x -&gt; (x -&gt; b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.Transform.html#scanx" class="link">Source</a> <a href="#v:scanx" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use scanl followed by map instead.</p></div><p>Strict left scan with an extraction function. Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Transform.html#v:scanl-39-" title="Streamly.Internal.Data.Stream.IsStream.Transform">scanl'</a></code>, but applies a
 user supplied extraction function (the third argument) at each step. This is
 designed to work with the <code>foldl</code> library. The suffix <code>x</code> is a mnemonic for
 extraction.</p><p><em>Since 0.2.0</em></p><p><em>Since: 0.7.0 (Monad m constraint)</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.26.0</p></div></body></html>