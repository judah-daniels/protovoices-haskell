<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Streamly.Internal.Data.Stream.IsStream.Top</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">streamly-0.8.1.1: Dataflow programming and declarative concurrency</span><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2020 Composewell Technologies</td></tr><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Stream.IsStream.Top</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Transformation</a><ul><li><a href="#g:2">Sampling</a></li><li><a href="#g:3">Reordering</a></li></ul></li><li><a href="#g:4">Nesting</a><ul><li><a href="#g:5">Set like operations</a></li><li><a href="#g:6">Join operations</a></li></ul></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Top level IsStream module that can use all other lower level IsStream
 modules.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:sampleFromThen">sampleFromThen</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:sampleIntervalStart">sampleIntervalStart</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:sampleIntervalEnd">sampleIntervalEnd</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:sampleBurstStart">sampleBurstStart</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:sampleBurstEnd">sampleBurstEnd</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:sortBy">sortBy</a> :: <a href="../exceptions-0.10.4/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a</li><li class="src short"><a href="#v:intersectBy">intersectBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mergeIntersectBy">mergeIntersectBy</a> :: (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:differenceBy">differenceBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mergeDifferenceBy">mergeDifferenceBy</a> :: (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:unionBy">unionBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a> (t m a)) =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mergeUnionBy">mergeUnionBy</a> :: (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:crossJoin">crossJoin</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (t m) =&gt; t m a -&gt; t m b -&gt; t m (a, b)</li><li class="src short"><a href="#v:innerJoin">innerJoin</a> :: <span class="keyword">forall</span> (t :: (<a href="../base-4.16.4.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.16.4.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="../base-4.16.4.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.16.4.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) m a b. (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (t m)) =&gt; (a -&gt; b -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m b -&gt; t m (a, b)</li><li class="src short"><a href="#v:mergeInnerJoin">mergeInnerJoin</a> :: (a -&gt; b -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m b -&gt; t m (a, b)</li><li class="src short"><a href="#v:hashInnerJoin">hashInnerJoin</a> :: (a -&gt; b -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m b -&gt; t m (a, b)</li><li class="src short"><a href="#v:leftJoin">leftJoin</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m (a, <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b)</li><li class="src short"><a href="#v:mergeLeftJoin">mergeLeftJoin</a> :: (a -&gt; b -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m b -&gt; t m (a, <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b)</li><li class="src short"><a href="#v:hashLeftJoin">hashLeftJoin</a> :: (a -&gt; b -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m b -&gt; t m (a, <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b)</li><li class="src short"><a href="#v:outerJoin">outerJoin</a> :: <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; (a -&gt; b -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m (<a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a, <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b)</li><li class="src short"><a href="#v:mergeOuterJoin">mergeOuterJoin</a> :: (a -&gt; b -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m b -&gt; t m (<a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a, <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b)</li><li class="src short"><a href="#v:hashOuterJoin">hashOuterJoin</a> :: (a -&gt; b -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m b -&gt; t m (<a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a, <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b)</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Transformation</h1></a><a href="#g:2" id="g:2"><h2>Sampling</h2></a><div class="doc"><p>Value agnostic filtering.</p></div><div class="top"><p class="src"><a id="v:sampleFromThen" class="def">sampleFromThen</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#sampleFromThen" class="link">Source</a> <a href="#v:sampleFromThen" class="selflink">#</a></p><div class="doc"><p><code>sampleFromthen offset stride</code> samples the element at <code>offset</code> index and
 then every element at strides of <code>stride</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.sampleFromThen 2 3 $ Stream.enumerateFromTo 0 10
</code></strong>[2,5,8]
</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:sampleIntervalStart" class="def">sampleIntervalStart</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#sampleIntervalStart" class="link">Source</a> <a href="#v:sampleIntervalStart" class="selflink">#</a></p><div class="doc"><p>Like <code>sampleInterval</code> but samples at the beginning of the time window.</p><pre>sampleIntervalStart n = Stream.catMaybes . Stream.intervalsOf n Fold.head
</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:sampleIntervalEnd" class="def">sampleIntervalEnd</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#sampleIntervalEnd" class="link">Source</a> <a href="#v:sampleIntervalEnd" class="selflink">#</a></p><div class="doc"><p>Continuously evaluate the input stream and sample the last event in time
 window of <code>n</code> seconds.</p><p>This is also known as <code>throttle</code> in some libraries.</p><pre>sampleIntervalEnd n = Stream.catMaybes . Stream.intervalsOf n Fold.last
</pre><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:sampleBurstStart" class="def">sampleBurstStart</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#sampleBurstStart" class="link">Source</a> <a href="#v:sampleBurstStart" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Top.html#v:sampleBurstEnd" title="Streamly.Internal.Data.Stream.IsStream.Top">sampleBurstEnd</a></code> but samples the event at the beginning of the burst
 instead of at the end of it.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:sampleBurstEnd" class="def">sampleBurstEnd</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="../base-4.16.4.0/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#sampleBurstEnd" class="link">Source</a> <a href="#v:sampleBurstEnd" class="selflink">#</a></p><div class="doc"><p>Sample one event at the end of each burst of events.  A burst is a group
 of events close together in time, it ends when an event is spaced by more
 than the specified time interval from the previous event.</p><p>This is known as <code>debounce</code> in some libraries.</p><p>The clock granularity is 10 ms.</p><p><em>Pre-release</em></p></div></div><a href="#g:3" id="g:3"><h2>Reordering</h2></a><div class="top"><p class="src"><a id="v:sortBy" class="def">sortBy</a> :: <a href="../exceptions-0.10.4/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#sortBy" class="link">Source</a> <a href="#v:sortBy" class="selflink">#</a></p><div class="doc"><p>Sort the input stream using a supplied comparison function.</p><p><em>O(n) space</em></p><p>Note: this is not the fastest possible implementation as of now.</p><p><em>Pre-release</em></p></div></div><a href="#g:4" id="g:4"><h1>Nesting</h1></a><a href="#g:5" id="g:5"><h2>Set like operations</h2></a><div class="doc"><p>These are not exactly set operations because streams are not
 necessarily sets, they may have duplicated elements.</p></div><div class="top"><p class="src"><a id="v:intersectBy" class="def">intersectBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#intersectBy" class="link">Source</a> <a href="#v:intersectBy" class="selflink">#</a></p><div class="doc"><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Top.html#v:intersectBy" title="Streamly.Internal.Data.Stream.IsStream.Top">intersectBy</a></code> is essentially a filtering operation that retains only those
 elements in the first stream that are present in the second stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.intersectBy (==) (Stream.fromList [1,2,2,4]) (Stream.fromList [2,1,1,3])
</code></strong>[1,2,2]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.intersectBy (==) (Stream.fromList [2,1,1,3]) (Stream.fromList [1,2,2,4])
</code></strong>[2,1,1]
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream-Top.html#v:intersectBy" title="Streamly.Internal.Data.Stream.IsStream.Top">intersectBy</a></code> is similar to but not the same as <code><a href="Streamly-Internal-Data-Stream-IsStream-Top.html#v:innerJoin" title="Streamly.Internal.Data.Stream.IsStream.Top">innerJoin</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ fmap fst $ Stream.innerJoin (==) (Stream.fromList [1,2,2,4]) (Stream.fromList [2,1,1,3])
</code></strong>[1,1,2,2]
</pre><p>Space: O(n) where <code>n</code> is the number of elements in the second stream.</p><p>Time: O(m x n) where <code>m</code> is the number of elements in the first stream and
 <code>n</code> is the number of elements in the second stream.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:mergeIntersectBy" class="def">mergeIntersectBy</a> :: (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#mergeIntersectBy" class="link">Source</a> <a href="#v:mergeIntersectBy" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Top.html#v:intersectBy" title="Streamly.Internal.Data.Stream.IsStream.Top">intersectBy</a></code> but works only on sorted streams.</p><p>Space: O(1)</p><p>Time: O(m+n)</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:differenceBy" class="def">differenceBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#differenceBy" class="link">Source</a> <a href="#v:differenceBy" class="selflink">#</a></p><div class="doc"><p>Delete first occurrences of those elements from the first stream that are
 present in the second stream. If an element occurs multiple times in the
 second stream as many occurrences of it are deleted from the first stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.differenceBy (==) (Stream.fromList [1,2,2]) (Stream.fromList [1,2,3])
</code></strong>[2]
</pre><p>The following laws hold:</p><pre>(s1 <code>serial</code> s2) `differenceBy eq` s1 === s2
(s1 <code>wSerial</code> s2) `differenceBy eq` s1 === s2
</pre><p>Same as the list <code><a href="../base-4.16.4.0/Data-List.html#v:-47--47-" title="Data.List">//</a></code> operation.</p><p>Space: O(m) where <code>m</code> is the number of elements in the first stream.</p><p>Time: O(m x n) where <code>m</code> is the number of elements in the first stream and
 <code>n</code> is the number of elements in the second stream.</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:mergeDifferenceBy" class="def">mergeDifferenceBy</a> :: (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#mergeDifferenceBy" class="link">Source</a> <a href="#v:mergeDifferenceBy" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Top.html#v:differenceBy" title="Streamly.Internal.Data.Stream.IsStream.Top">differenceBy</a></code> but works only on sorted streams.</p><p>Space: O(1)</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:unionBy" class="def">unionBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="Streamly-Internal-Control-Concurrent.html#t:MonadAsync" title="Streamly.Internal.Control.Concurrent">MonadAsync</a> m, <a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a> (t m a)) =&gt; (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#unionBy" class="link">Source</a> <a href="#v:unionBy" class="selflink">#</a></p><div class="doc"><p>This is essentially an append operation that appends all the extra
 occurrences of elements from the second stream that are not already present
 in the first stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Stream.toList $ Stream.unionBy (==) (Stream.fromList [1,2,2,4]) (Stream.fromList [1,1,2,3])
</code></strong>[1,2,2,4,3]
</pre><p>Equivalent to the following except that <code>s1</code> is evaluated only once:</p><pre>unionBy eq s1 s2 = s1 `serial` (s2 `differenceBy eq` s1)
</pre><p>Similar to <code><a href="Streamly-Internal-Data-Stream-IsStream-Top.html#v:outerJoin" title="Streamly.Internal.Data.Stream.IsStream.Top">outerJoin</a></code> but not the same.</p><p>Space: O(n)</p><p>Time: O(m x n)</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:mergeUnionBy" class="def">mergeUnionBy</a> :: (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#mergeUnionBy" class="link">Source</a> <a href="#v:mergeUnionBy" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Top.html#v:unionBy" title="Streamly.Internal.Data.Stream.IsStream.Top">unionBy</a></code> but works only on sorted streams.</p><p>Space: O(1)</p><p><em>Unimplemented</em></p></div></div><a href="#g:6" id="g:6"><h2>Join operations</h2></a><div class="top"><p class="src"><a id="v:crossJoin" class="def">crossJoin</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (t m) =&gt; t m a -&gt; t m b -&gt; t m (a, b) <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#crossJoin" class="link">Source</a> <a href="#v:crossJoin" class="selflink">#</a></p><div class="doc"><p>This is the same as <code><a href="Streamly-Internal-Data-Unfold.html#v:outerProduct" title="Streamly.Internal.Data.Unfold">outerProduct</a></code> but less
 efficient.</p><p>The second stream is evaluated multiple times. If the second stream is
 consume-once stream then it can be cached in an <code><a href="../array-0.5.4.0/Data-Array.html#v:Array" title="Data.Array">Array</a></code> before
 calling this function. Caching may also improve performance if the stream is
 expensive to evaluate.</p><p>Time: O(m x n)</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:innerJoin" class="def">innerJoin</a> :: <span class="keyword">forall</span> (t :: (<a href="../base-4.16.4.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.16.4.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) -&gt; <a href="../base-4.16.4.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.16.4.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) m a b. (<a href="Streamly-Internal-Data-Stream-IsStream-Type.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream.Type">IsStream</a> t, <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (t m)) =&gt; (a -&gt; b -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m b -&gt; t m (a, b) <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#innerJoin" class="link">Source</a> <a href="#v:innerJoin" class="selflink">#</a></p><div class="doc"><p>For all elements in <code>t m a</code>, for all elements in <code>t m b</code> if <code>a</code> and <code>b</code>
 are equal by the given equality pedicate then return the tuple (a, b).</p><p>The second stream is evaluated multiple times. If the stream is a
 consume-once stream then the caller should cache it in an <code><a href="../array-0.5.4.0/Data-Array.html#v:Array" title="Data.Array">Array</a></code>
 before calling this function. Caching may also improve performance if the
 stream is expensive to evaluate.</p><p>For space efficiency use the smaller stream as the second stream.</p><p>Space: O(n) assuming the second stream is cached in memory.</p><p>Time: O(m x n)</p><p><em>Pre-release</em></p></div></div><div class="top"><p class="src"><a id="v:mergeInnerJoin" class="def">mergeInnerJoin</a> :: (a -&gt; b -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m b -&gt; t m (a, b) <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#mergeInnerJoin" class="link">Source</a> <a href="#v:mergeInnerJoin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Top.html#v:innerJoin" title="Streamly.Internal.Data.Stream.IsStream.Top">innerJoin</a></code> but works only on sorted streams.</p><p>Space: O(1)</p><p>Time: O(m + n)</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:hashInnerJoin" class="def">hashInnerJoin</a> :: (a -&gt; b -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m b -&gt; t m (a, b) <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#hashInnerJoin" class="link">Source</a> <a href="#v:hashInnerJoin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Top.html#v:innerJoin" title="Streamly.Internal.Data.Stream.IsStream.Top">innerJoin</a></code> but uses a hashmap for efficiency.</p><p>For space efficiency use the smaller stream as the second stream.</p><p>Space: O(n)</p><p>Time: O(m + n)</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:leftJoin" class="def">leftJoin</a> :: <a href="../base-4.16.4.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m (a, <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#leftJoin" class="link">Source</a> <a href="#v:leftJoin" class="selflink">#</a></p><div class="doc"><p>For all elements in <code>t m a</code>, for all elements in <code>t m b</code> if <code>a</code> and <code>b</code>
 are equal then return the tuple <code>(a, Just b)</code>.  If <code>a</code> is not present in <code>t
 m b</code> then return <code>(a, Nothing)</code>.</p><p>The second stream is evaluated multiple times. If the stream is a
 consume-once stream then the caller should cache it in an <code><a href="../array-0.5.4.0/Data-Array.html#v:Array" title="Data.Array">Array</a></code>
 before calling this function. Caching may also improve performance if the
 stream is expensive to evaluate.</p><pre>rightJoin = flip leftJoin
</pre><p>Space: O(n) assuming the second stream is cached in memory.</p><p>Time: O(m x n)</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:mergeLeftJoin" class="def">mergeLeftJoin</a> :: (a -&gt; b -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m b -&gt; t m (a, <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#mergeLeftJoin" class="link">Source</a> <a href="#v:mergeLeftJoin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Top.html#v:leftJoin" title="Streamly.Internal.Data.Stream.IsStream.Top">leftJoin</a></code> but works only on sorted streams.</p><p>Space: O(1)</p><p>Time: O(m + n)</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:hashLeftJoin" class="def">hashLeftJoin</a> :: (a -&gt; b -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m b -&gt; t m (a, <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#hashLeftJoin" class="link">Source</a> <a href="#v:hashLeftJoin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Top.html#v:outerJoin" title="Streamly.Internal.Data.Stream.IsStream.Top">outerJoin</a></code> but uses a hashmap for efficiency.</p><p>Space: O(n)</p><p>Time: O(m + n)</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:outerJoin" class="def">outerJoin</a> :: <a href="../base-4.16.4.0/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; (a -&gt; b -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-Serial.html#t:SerialT" title="Streamly.Internal.Data.Stream.Serial">SerialT</a> m (<a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a, <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#outerJoin" class="link">Source</a> <a href="#v:outerJoin" class="selflink">#</a></p><div class="doc"><p>For all elements in <code>t m a</code>, for all elements in <code>t m b</code> if <code>a</code> and <code>b</code>
 are equal by the given equality pedicate then return the tuple (Just a, Just
 b).  If <code>a</code> is not found in <code>t m b</code> then return (a, Nothing), return
 (Nothing, b) for vice-versa.</p><p>For space efficiency use the smaller stream as the second stream.</p><p>Space: O(n)</p><p>Time: O(m x n)</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:mergeOuterJoin" class="def">mergeOuterJoin</a> :: (a -&gt; b -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m b -&gt; t m (<a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a, <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#mergeOuterJoin" class="link">Source</a> <a href="#v:mergeOuterJoin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Top.html#v:outerJoin" title="Streamly.Internal.Data.Stream.IsStream.Top">outerJoin</a></code> but works only on sorted streams.</p><p>Space: O(1)</p><p>Time: O(m + n)</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:hashOuterJoin" class="def">hashOuterJoin</a> :: (a -&gt; b -&gt; <a href="../base-4.16.4.0/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m b -&gt; t m (<a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a, <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) <a href="src/Streamly.Internal.Data.Stream.IsStream.Top.html#hashOuterJoin" class="link">Source</a> <a href="#v:hashOuterJoin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream-Top.html#v:outerJoin" title="Streamly.Internal.Data.Stream.IsStream.Top">outerJoin</a></code> but uses a hashmap for efficiency.</p><p>For space efficiency use the smaller stream as the second stream.</p><p>Space: O(n)</p><p>Time: O(m + n)</p><p><em>Unimplemented</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.26.0</p></div></body></html>