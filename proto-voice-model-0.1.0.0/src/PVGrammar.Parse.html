<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE DeriveAnyClass #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE TypeFamilies #-}</span><span>
</span><span id="line-3"></span><span>
</span><span id="line-4"></span><span class="hs-comment">{- | This module contains code that is specific to parsing the protovoice grammar.
 It implements a number of evaluators ('Eval') that can be used with the various parsers.
-}</span><span>
</span><span id="line-7"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">PVGrammar.Parse</span><span>
</span><span id="line-8"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-comment">-- * Generic Parsing</span></span><span>
</span><span id="line-9"></span><span>
</span><span id="line-10"></span><span>    </span><span class="hs-comment">-- | Evaluators that directly return protovoice operations.</span><span>
</span><span id="line-11"></span><span>    </span><span class="hs-comment">-- They can be embedded into a semiring using 'mapEvalScore'.</span><span>
</span><span id="line-12"></span><span>    </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier">IsNote</span></a></span><span>
</span><span id="line-13"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#protoVoiceEvaluator"><span class="hs-identifier">protoVoiceEvaluator</span></a></span><span>
</span><span id="line-14"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#protoVoiceEvaluatorNoRepSplit"><span class="hs-identifier">protoVoiceEvaluatorNoRepSplit</span></a></span><span>
</span><span id="line-15"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#protoVoiceEvaluatorLimitedSize"><span class="hs-identifier">protoVoiceEvaluatorLimitedSize</span></a></span><span>
</span><span id="line-16"></span><span>
</span><span id="line-17"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Parsing Derivations</span></span><span>
</span><span id="line-18"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#pvDerivUnrestricted"><span class="hs-identifier">pvDerivUnrestricted</span></a></span><span>
</span><span id="line-19"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#pvDerivRightBranch"><span class="hs-identifier">pvDerivRightBranch</span></a></span><span>
</span><span id="line-20"></span><span>
</span><span id="line-21"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Counting Parses</span></span><span>
</span><span id="line-22"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#pvCountUnrestricted"><span class="hs-identifier">pvCountUnrestricted</span></a></span><span>
</span><span id="line-23"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#pvCountNoRepSplit"><span class="hs-identifier">pvCountNoRepSplit</span></a></span><span>
</span><span id="line-24"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#pvCountNoRepSplitRightBranch"><span class="hs-identifier">pvCountNoRepSplitRightBranch</span></a></span><span>
</span><span id="line-25"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#pvCountNoRepSplitRightBranchSplitFirst"><span class="hs-identifier">pvCountNoRepSplitRightBranchSplitFirst</span></a></span><span>
</span><span id="line-26"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-27"></span><span>
</span><span id="line-28"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Common.html"><span class="hs-identifier">Common</span></a></span><span>
</span><span id="line-29"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="PVGrammar.html"><span class="hs-identifier">PVGrammar</span></a></span><span>
</span><span id="line-30"></span><span>
</span><span id="line-31"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Musicology.Pitch</span></span><span>
</span><span id="line-32"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">Diatonic</span></span><span>
</span><span id="line-33"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Interval</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-34"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Notation</span></span><span>
</span><span id="line-35"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">pc</span></span><span>
</span><span id="line-36"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">pto</span></span><span>
</span><span id="line-37"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-38"></span><span>
</span><span id="line-39"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.DeepSeq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">NFData</span></span><span class="hs-special">)</span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">foldM</span></span><span class="hs-special">)</span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Foldable</span></span><span>
</span><span id="line-42"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">foldl'</span></span><span>
</span><span id="line-43"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">toList</span></span><span>
</span><span id="line-44"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-45"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.HashMap.Strict</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">HM</span></span><span>
</span><span id="line-46"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.HashSet</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">S</span></span><span>
</span><span id="line-47"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Hashable</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Hashable</span></span><span class="hs-special">)</span><span>
</span><span id="line-48"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Kind</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Constraint</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Type</span></span><span class="hs-special">)</span><span>
</span><span id="line-49"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.List</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">L</span></span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map.Strict</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">M</span></span><span>
</span><span id="line-51"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span>
</span><span id="line-52"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">catMaybes</span></span><span>
</span><span id="line-53"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">mapMaybe</span></span><span>
</span><span id="line-54"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">maybeToList</span></span><span>
</span><span id="line-55"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-56"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Generics</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-57"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Internal.MultiSet.html"><span class="hs-identifier">Internal.MultiSet</span></a></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">MS</span></span><span>
</span><span id="line-58"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Musicology.Core</span></span><span>
</span><span id="line-59"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">HasPitch</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-60"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Pitch</span></span><span>
</span><span id="line-61"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Pitched</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-62"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">isStep</span></span><span>
</span><span id="line-63"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-64"></span><span>
</span><span id="line-65"></span><span class="hs-comment">-- helper type: Either for terminal and non-terminal edges</span><span>
</span><span id="line-66"></span><span class="hs-comment">-- -------------------------------------------------------</span><span>
</span><span id="line-67"></span><span>
</span><span id="line-68"></span><span class="hs-comment">{- | A tag that distinguishes between objects related to terminal and non-terminal edges.
 Like 'Either', but with semantic constructor names to avoid confusion.
-}</span><span>
</span><span id="line-71"></span><span id="local-6989586621679509038"><span id="local-6989586621679509039"></span></span><span class="hs-keyword">data</span><span> </span><span id="EdgeEither"><span class="annot"><a href="PVGrammar.Parse.html#EdgeEither"><span class="hs-identifier hs-var">EdgeEither</span></a></span></span><span> </span><span id="local-6989586621679509522"><span class="annot"><a href="#local-6989586621679509522"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679509521"><span class="annot"><a href="#local-6989586621679509521"><span class="hs-identifier hs-type">b</span></a></span></span><span>
</span><span id="line-72"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- | marks an terminal edge (or some related object)</span><span>
</span><span id="line-73"></span><span>    </span><span id="Reg"><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><a href="#local-6989586621679509522"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-74"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-comment">-- | marks a non-terminal edge (or some related object)</span><span>
</span><span id="line-75"></span><span>    </span><span id="Pass"><span class="annot"><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-var">Pass</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><a href="#local-6989586621679509521"><span class="hs-identifier hs-type">b</span></a></span><span>
</span><span id="line-76"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679509030"><span id="local-6989586621679509034"><span class="annot"><span class="annottext">EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall a b.
(Eq a, Eq b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
/= :: EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
$c/= :: forall a b.
(Eq a, Eq b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
== :: EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
$c== :: forall a b.
(Eq a, Eq b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679509006"><span id="local-6989586621679509008"><span id="local-6989586621679509011"><span id="local-6989586621679509014"><span id="local-6989586621679509017"><span id="local-6989586621679509021"><span id="local-6989586621679509025"><span class="annot"><span class="annottext">EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
EdgeEither a b -&gt; EdgeEither a b -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {a} {b}. (Ord a, Ord b) =&gt; Eq (EdgeEither a b)
forall a b.
(Ord a, Ord b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
forall a b.
(Ord a, Ord b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; Ordering
forall a b.
(Ord a, Ord b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; EdgeEither a b
min :: EdgeEither a b -&gt; EdgeEither a b -&gt; EdgeEither a b
$cmin :: forall a b.
(Ord a, Ord b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; EdgeEither a b
max :: EdgeEither a b -&gt; EdgeEither a b -&gt; EdgeEither a b
$cmax :: forall a b.
(Ord a, Ord b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; EdgeEither a b
&gt;= :: EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
$c&gt;= :: forall a b.
(Ord a, Ord b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
&gt; :: EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
$c&gt; :: forall a b.
(Ord a, Ord b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
&lt;= :: EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
$c&lt;= :: forall a b.
(Ord a, Ord b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
&lt; :: EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
$c&lt; :: forall a b.
(Ord a, Ord b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
compare :: EdgeEither a b -&gt; EdgeEither a b -&gt; Ordering
$ccompare :: forall a b.
(Ord a, Ord b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508994"><span id="local-6989586621679508996"><span id="local-6989586621679509003"><span class="annot"><span class="annottext">Int -&gt; EdgeEither a b -&gt; ShowS
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall a b. (Show a, Show b) =&gt; Int -&gt; EdgeEither a b -&gt; ShowS
forall a b. (Show a, Show b) =&gt; [EdgeEither a b] -&gt; ShowS
forall a b. (Show a, Show b) =&gt; EdgeEither a b -&gt; String
showList :: [EdgeEither a b] -&gt; ShowS
$cshowList :: forall a b. (Show a, Show b) =&gt; [EdgeEither a b] -&gt; ShowS
show :: EdgeEither a b -&gt; String
$cshow :: forall a b. (Show a, Show b) =&gt; EdgeEither a b -&gt; String
showsPrec :: Int -&gt; EdgeEither a b -&gt; ShowS
$cshowsPrec :: forall a b. (Show a, Show b) =&gt; Int -&gt; EdgeEither a b -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall a b x. Rep (EdgeEither a b) x -&gt; EdgeEither a b
forall a b x. EdgeEither a b -&gt; Rep (EdgeEither a b) x
$cto :: forall a b x. Rep (EdgeEither a b) x -&gt; EdgeEither a b
$cfrom :: forall a b x. EdgeEither a b -&gt; Rep (EdgeEither a b) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508984"><span id="local-6989586621679508986"><span class="annot"><span class="annottext">forall a. Eq a -&gt; (Int -&gt; a -&gt; Int) -&gt; (a -&gt; Int) -&gt; Hashable a
forall {a} {b}. (Hashable a, Hashable b) =&gt; Eq (EdgeEither a b)
forall a b.
(Hashable a, Hashable b) =&gt;
Int -&gt; EdgeEither a b -&gt; Int
forall a b. (Hashable a, Hashable b) =&gt; EdgeEither a b -&gt; Int
hash :: EdgeEither a b -&gt; Int
$chash :: forall a b. (Hashable a, Hashable b) =&gt; EdgeEither a b -&gt; Int
hashWithSalt :: Int -&gt; EdgeEither a b -&gt; Int
$chashWithSalt :: forall a b.
(Hashable a, Hashable b) =&gt;
Int -&gt; EdgeEither a b -&gt; Int
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Hashable</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508981"><span class="annot"><span class="annottext">forall a. (a -&gt; ()) -&gt; NFData a
forall a b. (NFData a, NFData b) =&gt; EdgeEither a b -&gt; ()
rnf :: EdgeEither a b -&gt; ()
$crnf :: forall a b. (NFData a, NFData b) =&gt; EdgeEither a b -&gt; ()
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">NFData</span></span></span><span class="hs-special">)</span><span>
</span><span id="line-77"></span><span>
</span><span id="line-78"></span><span class="hs-comment">-- helper type: enum for possible operations</span><span>
</span><span id="line-79"></span><span class="hs-comment">-- -----------------------------------------</span><span>
</span><span id="line-80"></span><span>
</span><span id="line-81"></span><span class="hs-comment">{- | A tag that distinguishes four different types of operations:
  regular split, passing split, left ornament, and right ornament
-}</span><span>
</span><span id="line-84"></span><span id="local-6989586621679508978"><span id="local-6989586621679508979"></span></span><span class="hs-keyword">data</span><span> </span><span id="Elaboration"><span class="annot"><a href="PVGrammar.Parse.html#Elaboration"><span class="hs-identifier hs-var">Elaboration</span></a></span></span><span> </span><span id="local-6989586621679509510"><span class="annot"><a href="#local-6989586621679509510"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679509509"><span class="annot"><a href="#local-6989586621679509509"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span id="local-6989586621679509508"><span class="annot"><a href="#local-6989586621679509508"><span class="hs-identifier hs-type">c</span></a></span></span><span> </span><span id="local-6989586621679509507"><span class="annot"><a href="#local-6989586621679509507"><span class="hs-identifier hs-type">d</span></a></span></span><span>
</span><span id="line-85"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- | marks a terminal split</span><span>
</span><span id="line-86"></span><span>    </span><span id="EReg"><span class="annot"><a href="PVGrammar.Parse.html#EReg"><span class="hs-identifier hs-var">EReg</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><a href="#local-6989586621679509510"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-87"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-comment">-- | marks a non-terminal split</span><span>
</span><span id="line-88"></span><span>    </span><span id="EPass"><span class="annot"><a href="PVGrammar.Parse.html#EPass"><span class="hs-identifier hs-var">EPass</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><a href="#local-6989586621679509509"><span class="hs-identifier hs-type">b</span></a></span><span>
</span><span id="line-89"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-comment">-- | marks a right ornament</span><span>
</span><span id="line-90"></span><span>    </span><span id="ER"><span class="annot"><a href="PVGrammar.Parse.html#ER"><span class="hs-identifier hs-var">ER</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><a href="#local-6989586621679509508"><span class="hs-identifier hs-type">c</span></a></span><span>
</span><span id="line-91"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-comment">-- | marks a left ornament</span><span>
</span><span id="line-92"></span><span>    </span><span id="EL"><span class="annot"><a href="PVGrammar.Parse.html#EL"><span class="hs-identifier hs-var">EL</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><a href="#local-6989586621679509507"><span class="hs-identifier hs-type">d</span></a></span><span>
</span><span id="line-93"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679508966"><span id="local-6989586621679508972"><span class="annot"><span class="annottext">Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall a b c d.
(Eq a, Eq b, Eq c, Eq d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
/= :: Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
$c/= :: forall a b c d.
(Eq a, Eq b, Eq c, Eq d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
== :: Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
$c== :: forall a b c d.
(Eq a, Eq b, Eq c, Eq d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508946"><span id="local-6989586621679508948"><span id="local-6989586621679508950"><span id="local-6989586621679508952"><span id="local-6989586621679508954"><span id="local-6989586621679508956"><span id="local-6989586621679508962"><span class="annot"><span class="annottext">Elaboration a b c d -&gt; Elaboration a b c d -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {a} {b} {c} {d}.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Eq (Elaboration a b c d)
forall a b c d.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
forall a b c d.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Ordering
forall a b c d.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Elaboration a b c d
min :: Elaboration a b c d -&gt; Elaboration a b c d -&gt; Elaboration a b c d
$cmin :: forall a b c d.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Elaboration a b c d
max :: Elaboration a b c d -&gt; Elaboration a b c d -&gt; Elaboration a b c d
$cmax :: forall a b c d.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Elaboration a b c d
&gt;= :: Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
$c&gt;= :: forall a b c d.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
&gt; :: Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
$c&gt; :: forall a b c d.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
&lt;= :: Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
$c&lt;= :: forall a b c d.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
&lt; :: Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
$c&lt; :: forall a b c d.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
compare :: Elaboration a b c d -&gt; Elaboration a b c d -&gt; Ordering
$ccompare :: forall a b c d.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508932"><span id="local-6989586621679508934"><span id="local-6989586621679508944"><span class="annot"><span class="annottext">Int -&gt; Elaboration a b c d -&gt; ShowS
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall a b c d.
(Show a, Show b, Show c, Show d) =&gt;
Int -&gt; Elaboration a b c d -&gt; ShowS
forall a b c d.
(Show a, Show b, Show c, Show d) =&gt;
[Elaboration a b c d] -&gt; ShowS
forall a b c d.
(Show a, Show b, Show c, Show d) =&gt;
Elaboration a b c d -&gt; String
showList :: [Elaboration a b c d] -&gt; ShowS
$cshowList :: forall a b c d.
(Show a, Show b, Show c, Show d) =&gt;
[Elaboration a b c d] -&gt; ShowS
show :: Elaboration a b c d -&gt; String
$cshow :: forall a b c d.
(Show a, Show b, Show c, Show d) =&gt;
Elaboration a b c d -&gt; String
showsPrec :: Int -&gt; Elaboration a b c d -&gt; ShowS
$cshowsPrec :: forall a b c d.
(Show a, Show b, Show c, Show d) =&gt;
Int -&gt; Elaboration a b c d -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall a b c d x.
Rep (Elaboration a b c d) x -&gt; Elaboration a b c d
forall a b c d x.
Elaboration a b c d -&gt; Rep (Elaboration a b c d) x
$cto :: forall a b c d x.
Rep (Elaboration a b c d) x -&gt; Elaboration a b c d
$cfrom :: forall a b c d x.
Elaboration a b c d -&gt; Rep (Elaboration a b c d) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508924"><span id="local-6989586621679508926"><span class="annot"><span class="annottext">forall a. Eq a -&gt; (Int -&gt; a -&gt; Int) -&gt; (a -&gt; Int) -&gt; Hashable a
forall {a} {b} {c} {d}.
(Hashable a, Hashable b, Hashable c, Hashable d) =&gt;
Eq (Elaboration a b c d)
forall a b c d.
(Hashable a, Hashable b, Hashable c, Hashable d) =&gt;
Int -&gt; Elaboration a b c d -&gt; Int
forall a b c d.
(Hashable a, Hashable b, Hashable c, Hashable d) =&gt;
Elaboration a b c d -&gt; Int
hash :: Elaboration a b c d -&gt; Int
$chash :: forall a b c d.
(Hashable a, Hashable b, Hashable c, Hashable d) =&gt;
Elaboration a b c d -&gt; Int
hashWithSalt :: Int -&gt; Elaboration a b c d -&gt; Int
$chashWithSalt :: forall a b c d.
(Hashable a, Hashable b, Hashable c, Hashable d) =&gt;
Int -&gt; Elaboration a b c d -&gt; Int
</span><a href="#local-6989586621679508924"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Hashable</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508922"><span class="annot"><span class="annottext">forall a. (a -&gt; ()) -&gt; NFData a
forall a b c d.
(NFData a, NFData b, NFData c, NFData d) =&gt;
Elaboration a b c d -&gt; ()
rnf :: Elaboration a b c d -&gt; ()
$crnf :: forall a b c d.
(NFData a, NFData b, NFData c, NFData d) =&gt;
Elaboration a b c d -&gt; ()
</span><a href="#local-6989586621679508922"><span class="hs-identifier hs-var hs-var hs-var hs-var">NFData</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-94"></span><span>
</span><span id="line-95"></span><span class="hs-comment">{- | Takes a collection of 'Elaboration'
 and splits it into lists for each elaboration type.
-}</span><span>
</span><span id="line-98"></span><span id="local-6989586621679509502"><span id="local-6989586621679509503"><span id="local-6989586621679509504"><span id="local-6989586621679509505"><span id="local-6989586621679509506"><span class="annot"><a href="PVGrammar.Parse.html#partitionElaborations"><span class="hs-identifier hs-type">partitionElaborations</span></a></span><span>
</span><span id="line-99"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509506"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679509506"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Elaboration"><span class="hs-identifier hs-type">Elaboration</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509505"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509504"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509503"><span class="hs-identifier hs-type">c</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509502"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679509505"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679509504"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679509503"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679509502"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span></span></span></span></span></span><span>
</span><span id="line-100"></span><span id="partitionElaborations"><span class="annot"><span class="annottext">partitionElaborations :: forall (t :: * -&gt; *) a b c d.
Foldable t =&gt;
t (Elaboration a b c d) -&gt; ([a], [b], [c], [d])
</span><a href="PVGrammar.Parse.html#partitionElaborations"><span class="hs-identifier hs-var hs-var">partitionElaborations</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl'</span></span><span> </span><span class="annot"><span class="annottext">forall {a} {a} {a} {a}.
([a], [a], [a], [a]) -&gt; Elaboration a a a a -&gt; ([a], [a], [a], [a])
</span><a href="#local-6989586621679508918"><span class="hs-identifier hs-var">select</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-101"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-102"></span><span>  </span><span id="local-6989586621679508918"><span class="annot"><span class="annottext">select :: ([a], [a], [a], [a]) -&gt; Elaboration a a a a -&gt; ([a], [a], [a], [a])
</span><a href="#local-6989586621679508918"><span class="hs-identifier hs-var hs-var">select</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679508917"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508917"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508916"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508916"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508915"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508915"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508914"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508914"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#EReg"><span class="hs-identifier hs-type">EReg</span></a></span><span> </span><span id="local-6989586621679508913"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508913"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508913"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508917"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508916"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508915"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508914"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-103"></span><span>  </span><span class="annot"><a href="#local-6989586621679508918"><span class="hs-identifier hs-var">select</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679508912"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508912"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508911"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508911"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508910"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508910"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508909"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508909"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#EPass"><span class="hs-identifier hs-type">EPass</span></a></span><span> </span><span id="local-6989586621679508908"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508908"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508912"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508908"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508911"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508910"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508909"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-104"></span><span>  </span><span class="annot"><a href="#local-6989586621679508918"><span class="hs-identifier hs-var">select</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679508907"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508907"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508906"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508906"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508905"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508905"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508904"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508904"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#ER"><span class="hs-identifier hs-type">ER</span></a></span><span> </span><span id="local-6989586621679508903"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508903"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508907"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508906"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508903"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508905"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508904"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-105"></span><span>  </span><span class="annot"><a href="#local-6989586621679508918"><span class="hs-identifier hs-var">select</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679508902"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508902"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508901"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508901"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508900"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508900"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508899"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508899"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#EL"><span class="hs-identifier hs-type">EL</span></a></span><span> </span><span id="local-6989586621679508898"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508898"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508902"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508901"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508900"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508898"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508899"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-106"></span><span>
</span><span id="line-107"></span><span class="hs-comment">-- parsing Ornamentations</span><span>
</span><span id="line-108"></span><span class="hs-comment">-- ======================</span><span>
</span><span id="line-109"></span><span>
</span><span id="line-110"></span><span class="hs-comment">-- | A constraint alias for note types.</span><span>
</span><span id="line-111"></span><span class="hs-keyword">type</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Constraint</span></span><span>
</span><span id="line-112"></span><span class="hs-keyword">type</span><span> </span><span id="IsNote"><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-var">IsNote</span></a></span></span><span> </span><span id="local-6989586621679508897"><span class="annot"><a href="#local-6989586621679508897"><span class="hs-identifier hs-type">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-113"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">HasPitch</span></span><span> </span><span class="annot"><a href="#local-6989586621679508897"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Diatonic</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ICOf</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">IntervalOf</span></span><span> </span><span class="annot"><a href="#local-6989586621679508897"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ICOf</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">IntervalOf</span></span><span> </span><span class="annot"><a href="#local-6989586621679508897"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-114"></span><span>
</span><span id="line-115"></span><span class="hs-comment">-- | Checks if the middle pitch is between the left and the right pitch.</span><span>
</span><span id="line-116"></span><span id="local-6989586621679509492"><span class="annot"><a href="PVGrammar.Parse.html#between"><span class="hs-identifier hs-type">between</span></a></span><span>
</span><span id="line-117"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679509492"><span class="hs-identifier hs-type">i</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Interval</span></span><span> </span><span class="annot"><a href="#local-6989586621679509492"><span class="hs-identifier hs-type">i</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-118"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pitch</span></span><span> </span><span class="annot"><a href="#local-6989586621679509492"><span class="hs-identifier hs-type">i</span></a></span><span>
</span><span id="line-119"></span><span>  </span><span class="hs-comment">-- ^ left pitch</span><span>
</span><span id="line-120"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pitch</span></span><span> </span><span class="annot"><a href="#local-6989586621679509492"><span class="hs-identifier hs-type">i</span></a></span><span>
</span><span id="line-121"></span><span>  </span><span class="hs-comment">-- ^ middle pitch</span><span>
</span><span id="line-122"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pitch</span></span><span> </span><span class="annot"><a href="#local-6989586621679509492"><span class="hs-identifier hs-type">i</span></a></span><span>
</span><span id="line-123"></span><span>  </span><span class="hs-comment">-- ^ right pitch</span><span>
</span><span id="line-124"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-125"></span><span id="between"><span class="annot"><span class="annottext">between :: forall i.
(Eq i, Interval i) =&gt;
Pitch i -&gt; Pitch i -&gt; Pitch i -&gt; Bool
</span><a href="PVGrammar.Parse.html#between"><span class="hs-identifier hs-var hs-var">between</span></a></span></span><span> </span><span id="local-6989586621679508876"><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679508876"><span class="hs-identifier hs-var">pl</span></a></span></span><span> </span><span id="local-6989586621679508875"><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679508875"><span class="hs-identifier hs-var">pm</span></a></span></span><span> </span><span id="local-6989586621679508874"><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679508874"><span class="hs-identifier hs-var">pr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-126"></span><span>  </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679508876"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679508875"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679508875"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679508874"><span class="hs-identifier hs-var">pr</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679508876"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679508874"><span class="hs-identifier hs-var">pr</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><a href="#local-6989586621679508871"><span class="hs-identifier hs-var">dir1</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><a href="#local-6989586621679508870"><span class="hs-identifier hs-var">odir</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><a href="#local-6989586621679508869"><span class="hs-identifier hs-var">dir2</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><a href="#local-6989586621679508870"><span class="hs-identifier hs-var">odir</span></a></span><span>
</span><span id="line-127"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-128"></span><span>  </span><span id="local-6989586621679508870"><span class="annot"><span class="annottext">odir :: Ordering
</span><a href="#local-6989586621679508870"><span class="hs-identifier hs-var hs-var">odir</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall i. Interval i =&gt; i -&gt; Ordering
</span><span class="hs-identifier hs-var">direction</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679508876"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall {v}. AdditiveGroup v =&gt; Pitch v -&gt; Pitch v -&gt; v
</span><span class="hs-operator hs-var">`pto`</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679508874"><span class="hs-identifier hs-var">pr</span></a></span><span>
</span><span id="line-129"></span><span>  </span><span id="local-6989586621679508871"><span class="annot"><span class="annottext">dir1 :: Ordering
</span><a href="#local-6989586621679508871"><span class="hs-identifier hs-var hs-var">dir1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall i. Interval i =&gt; i -&gt; Ordering
</span><span class="hs-identifier hs-var">direction</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679508876"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall {v}. AdditiveGroup v =&gt; Pitch v -&gt; Pitch v -&gt; v
</span><span class="hs-operator hs-var">`pto`</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679508875"><span class="hs-identifier hs-var">pm</span></a></span><span>
</span><span id="line-130"></span><span>  </span><span id="local-6989586621679508869"><span class="annot"><span class="annottext">dir2 :: Ordering
</span><a href="#local-6989586621679508869"><span class="hs-identifier hs-var hs-var">dir2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall i. Interval i =&gt; i -&gt; Ordering
</span><span class="hs-identifier hs-var">direction</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679508875"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">forall {v}. AdditiveGroup v =&gt; Pitch v -&gt; Pitch v -&gt; v
</span><span class="hs-operator hs-var">`pto`</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679508874"><span class="hs-identifier hs-var">pr</span></a></span><span>
</span><span id="line-131"></span><span>
</span><span id="line-132"></span><span class="hs-comment">{- | Attempts to reduce three nodes using an ornamentation operation.
 If succesfull, returns the ornament type and the parent edge,
 which is either a non-terminal edge for passing notes,
 or a terminal edge for all other operations.
-}</span><span>
</span><span id="line-137"></span><span id="local-6989586621679509479"><span class="annot"><a href="PVGrammar.Parse.html#findOrnament"><span class="hs-identifier hs-type">findOrnament</span></a></span><span>
</span><span id="line-138"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509479"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-139"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#StartStop"><span class="hs-identifier hs-type">StartStop</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509479"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-140"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Common.html#StartStop"><span class="hs-identifier hs-type">StartStop</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509479"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-141"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Common.html#StartStop"><span class="hs-identifier hs-type">StartStop</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509479"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-142"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-143"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-144"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span>
</span><span id="line-145"></span><span>      </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#EdgeEither"><span class="hs-identifier hs-type">EdgeEither</span></a></span><span>
</span><span id="line-146"></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#DoubleOrnament"><span class="hs-identifier hs-type">DoubleOrnament</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509479"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-147"></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#PassingOrnament"><span class="hs-identifier hs-type">PassingOrnament</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#InnerEdge"><span class="hs-identifier hs-type">InnerEdge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509479"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-148"></span><span>      </span><span class="hs-special">)</span></span><span>
</span><span id="line-149"></span><span id="findOrnament"><span class="annot"><span class="annottext">findOrnament :: forall n.
IsNote n =&gt;
StartStop n
-&gt; StartStop n
-&gt; StartStop n
-&gt; Bool
-&gt; Bool
-&gt; Maybe
     (EdgeEither
        (DoubleOrnament, Edge n) (PassingOrnament, InnerEdge n))
</span><a href="PVGrammar.Parse.html#findOrnament"><span class="hs-identifier hs-var hs-var">findOrnament</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679508828"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508828"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679508827"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508827"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679508826"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508826"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-150"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508825"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508824"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508824"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508823"><span class="hs-identifier hs-var">pr</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DoubleOrnament
</span><a href="PVGrammar.html#FullRepeat"><span class="hs-identifier hs-var">FullRepeat</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508828"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508826"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-151"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508825"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508824"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679508821"><span class="hs-identifier hs-var">so</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DoubleOrnament
</span><a href="PVGrammar.html#RightRepeatOfLeft"><span class="hs-identifier hs-var">RightRepeatOfLeft</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508828"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508826"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-152"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508824"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508823"><span class="hs-identifier hs-var">pr</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679508821"><span class="hs-identifier hs-var">so</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DoubleOrnament
</span><a href="PVGrammar.html#LeftRepeatOfRight"><span class="hs-identifier hs-var">LeftRepeatOfRight</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508828"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508826"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-153"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-154"></span><span>  </span><span id="local-6989586621679508825"><span class="annot"><span class="annottext">pl :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508825"><span class="hs-identifier hs-var hs-var">pl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508828"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-155"></span><span>  </span><span id="local-6989586621679508824"><span class="annot"><span class="annottext">pm :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508824"><span class="hs-identifier hs-var hs-var">pm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508827"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-156"></span><span>  </span><span id="local-6989586621679508823"><span class="annot"><span class="annottext">pr :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508823"><span class="hs-identifier hs-var hs-var">pr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508826"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-157"></span><span>  </span><span id="local-6989586621679508821"><span class="annot"><span class="annottext">so :: Bool
</span><a href="#local-6989586621679508821"><span class="hs-identifier hs-var hs-var">so</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall i. Diatonic i =&gt; i -&gt; Bool
</span><span class="hs-identifier hs-var">isStep</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508825"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall {v}. AdditiveGroup v =&gt; Pitch v -&gt; Pitch v -&gt; v
</span><span class="hs-operator hs-var">`pto`</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508823"><span class="hs-identifier hs-var">pr</span></a></span><span>
</span><span id="line-158"></span><span class="annot"><a href="PVGrammar.Parse.html#findOrnament"><span class="hs-identifier hs-var">findOrnament</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679508817"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508817"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679508816"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508816"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679508815"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508815"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span>
</span><span id="line-159"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508814"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508813"><span class="hs-identifier hs-var">pr</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679508812"><span class="hs-identifier hs-var">s1</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DoubleOrnament
</span><a href="PVGrammar.html#FullNeighbor"><span class="hs-identifier hs-var">FullNeighbor</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508817"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508815"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-160"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679508812"><span class="hs-identifier hs-var">s1</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679508810"><span class="hs-identifier hs-var">s2</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">forall i.
(Eq i, Interval i) =&gt;
Pitch i -&gt; Pitch i -&gt; Pitch i -&gt; Bool
</span><a href="PVGrammar.Parse.html#between"><span class="hs-identifier hs-var">between</span></a></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508814"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508809"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508813"><span class="hs-identifier hs-var">pr</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b. b -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-var">Pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="PVGrammar.html#PassingMid"><span class="hs-identifier hs-var">PassingMid</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508817"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508815"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-161"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-162"></span><span>  </span><span id="local-6989586621679508814"><span class="annot"><span class="annottext">pl :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508814"><span class="hs-identifier hs-var hs-var">pl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508817"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-163"></span><span>  </span><span id="local-6989586621679508809"><span class="annot"><span class="annottext">pm :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508809"><span class="hs-identifier hs-var hs-var">pm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508816"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-164"></span><span>  </span><span id="local-6989586621679508813"><span class="annot"><span class="annottext">pr :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508813"><span class="hs-identifier hs-var hs-var">pr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508815"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-165"></span><span>  </span><span id="local-6989586621679508812"><span class="annot"><span class="annottext">s1 :: Bool
</span><a href="#local-6989586621679508812"><span class="hs-identifier hs-var hs-var">s1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall i. Diatonic i =&gt; i -&gt; Bool
</span><span class="hs-identifier hs-var">isStep</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508814"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall {v}. AdditiveGroup v =&gt; Pitch v -&gt; Pitch v -&gt; v
</span><span class="hs-operator hs-var">`pto`</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508809"><span class="hs-identifier hs-var">pm</span></a></span><span>
</span><span id="line-166"></span><span>  </span><span id="local-6989586621679508810"><span class="annot"><span class="annottext">s2 :: Bool
</span><a href="#local-6989586621679508810"><span class="hs-identifier hs-var hs-var">s2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall i. Diatonic i =&gt; i -&gt; Bool
</span><span class="hs-identifier hs-var">isStep</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508809"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">forall {v}. AdditiveGroup v =&gt; Pitch v -&gt; Pitch v -&gt; v
</span><span class="hs-operator hs-var">`pto`</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508813"><span class="hs-identifier hs-var">pr</span></a></span><span>
</span><span id="line-167"></span><span class="annot"><a href="PVGrammar.Parse.html#findOrnament"><span class="hs-identifier hs-var">findOrnament</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><a href="Common.html#Start"><span class="hs-identifier hs-var">Start</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><a href="Common.html#Stop"><span class="hs-identifier hs-var">Stop</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DoubleOrnament
</span><a href="PVGrammar.html#RootNote"><span class="hs-identifier hs-var">RootNote</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. StartStop a
</span><a href="Common.html#Start"><span class="hs-identifier hs-var">Start</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. StartStop a
</span><a href="Common.html#Stop"><span class="hs-identifier hs-var">Stop</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-168"></span><span class="annot"><a href="PVGrammar.Parse.html#findOrnament"><span class="hs-identifier hs-var">findOrnament</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-169"></span><span>
</span><span id="line-170"></span><span class="hs-comment">{- | Attempts to reduce three notes as a passing motion
 where one of the child edges is a non-terminal edge.

 Since one of the edges is a terminal edge,
 the corresponding outer note could be start/stop symbol, in which case the reduction fails.
 The side with the terminal edge is thus a @StartStop Pitch i@ within a 'Reg',
 while the non-terminal side is a @Pitch i@ within an 'Pass'.
 Exactly one side must be a 'Reg' and the other an 'Pass', otherwise the reduction fails.
-}</span><span>
</span><span id="line-179"></span><span id="local-6989586621679509459"><span class="annot"><a href="PVGrammar.Parse.html#findPassing"><span class="hs-identifier hs-type">findPassing</span></a></span><span>
</span><span id="line-180"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509459"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-181"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#EdgeEither"><span class="hs-identifier hs-type">EdgeEither</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#StartStop"><span class="hs-identifier hs-type">StartStop</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509459"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679509459"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-182"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679509459"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-183"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#EdgeEither"><span class="hs-identifier hs-type">EdgeEither</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#StartStop"><span class="hs-identifier hs-type">StartStop</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509459"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679509459"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-184"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#InnerEdge"><span class="hs-identifier hs-type">InnerEdge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509459"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#PassingOrnament"><span class="hs-identifier hs-type">PassingOrnament</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-185"></span><span id="findPassing"><span class="annot"><span class="annottext">findPassing :: forall n.
IsNote n =&gt;
EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe (InnerEdge n, PassingOrnament)
</span><a href="PVGrammar.Parse.html#findPassing"><span class="hs-identifier hs-var hs-var">findPassing</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679508774"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508774"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span id="local-6989586621679508773"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508773"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-type">Pass</span></a></span><span> </span><span id="local-6989586621679508772"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508772"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-186"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">forall i. Diatonic i =&gt; i -&gt; Bool
</span><span class="hs-identifier hs-var">isStep</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508771"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall {v}. AdditiveGroup v =&gt; Pitch v -&gt; Pitch v -&gt; v
</span><span class="hs-operator hs-var">`pto`</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508770"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">forall i.
(Eq i, Interval i) =&gt;
Pitch i -&gt; Pitch i -&gt; Pitch i -&gt; Bool
</span><a href="PVGrammar.Parse.html#between"><span class="hs-identifier hs-var">between</span></a></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508771"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508770"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508769"><span class="hs-identifier hs-var">pr</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-187"></span><span>      </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508774"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508772"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="PVGrammar.html#PassingLeft"><span class="hs-identifier hs-var">PassingLeft</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-188"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-189"></span><span>  </span><span id="local-6989586621679508771"><span class="annot"><span class="annottext">pl :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508771"><span class="hs-identifier hs-var hs-var">pl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508774"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-190"></span><span>  </span><span id="local-6989586621679508770"><span class="annot"><span class="annottext">pm :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508770"><span class="hs-identifier hs-var hs-var">pm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508773"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-191"></span><span>  </span><span id="local-6989586621679508769"><span class="annot"><span class="annottext">pr :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508769"><span class="hs-identifier hs-var hs-var">pr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508772"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-192"></span><span class="annot"><a href="PVGrammar.Parse.html#findPassing"><span class="hs-identifier hs-var">findPassing</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-type">Pass</span></a></span><span> </span><span id="local-6989586621679508767"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508767"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679508766"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508766"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679508765"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508765"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-193"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">forall i. Diatonic i =&gt; i -&gt; Bool
</span><span class="hs-identifier hs-var">isStep</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508764"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">forall {v}. AdditiveGroup v =&gt; Pitch v -&gt; Pitch v -&gt; v
</span><span class="hs-operator hs-var">`pto`</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508763"><span class="hs-identifier hs-var">pr</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">forall i.
(Eq i, Interval i) =&gt;
Pitch i -&gt; Pitch i -&gt; Pitch i -&gt; Bool
</span><a href="PVGrammar.Parse.html#between"><span class="hs-identifier hs-var">between</span></a></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508762"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508764"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508763"><span class="hs-identifier hs-var">pr</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-194"></span><span>      </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508767"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508765"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="PVGrammar.html#PassingRight"><span class="hs-identifier hs-var">PassingRight</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-195"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-196"></span><span>  </span><span id="local-6989586621679508762"><span class="annot"><span class="annottext">pl :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508762"><span class="hs-identifier hs-var hs-var">pl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508767"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-197"></span><span>  </span><span id="local-6989586621679508764"><span class="annot"><span class="annottext">pm :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508764"><span class="hs-identifier hs-var hs-var">pm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508766"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-198"></span><span>  </span><span id="local-6989586621679508763"><span class="annot"><span class="annottext">pr :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508763"><span class="hs-identifier hs-var hs-var">pr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508765"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-199"></span><span class="annot"><a href="PVGrammar.Parse.html#findPassing"><span class="hs-identifier hs-var">findPassing</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-200"></span><span>
</span><span id="line-201"></span><span id="local-6989586621679509457"><span class="annot"><a href="PVGrammar.Parse.html#findRightOrnament"><span class="hs-identifier hs-type">findRightOrnament</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509457"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679509457"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679509457"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="PVGrammar.html#RightOrnament"><span class="hs-identifier hs-type">RightOrnament</span></a></span></span><span>
</span><span id="line-202"></span><span id="findRightOrnament"><span class="annot"><span class="annottext">findRightOrnament :: forall n. IsNote n =&gt; n -&gt; n -&gt; Maybe RightOrnament
</span><a href="PVGrammar.Parse.html#findRightOrnament"><span class="hs-identifier hs-var hs-var">findRightOrnament</span></a></span></span><span> </span><span id="local-6989586621679508743"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508743"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679508742"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508742"><span class="hs-identifier hs-var">m</span></a></span></span><span>
</span><span id="line-203"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508741"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508740"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">RightOrnament
</span><a href="PVGrammar.html#RightRepeat"><span class="hs-identifier hs-var">RightRepeat</span></a></span><span>
</span><span id="line-204"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">forall i. Diatonic i =&gt; i -&gt; Bool
</span><span class="hs-identifier hs-var">isStep</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508741"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall {v}. AdditiveGroup v =&gt; Pitch v -&gt; Pitch v -&gt; v
</span><span class="hs-operator hs-var">`pto`</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508740"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">RightOrnament
</span><a href="PVGrammar.html#RightNeighbor"><span class="hs-identifier hs-var">RightNeighbor</span></a></span><span>
</span><span id="line-205"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-206"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-207"></span><span>  </span><span id="local-6989586621679508741"><span class="annot"><span class="annottext">pl :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508741"><span class="hs-identifier hs-var hs-var">pl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508743"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-208"></span><span>  </span><span id="local-6989586621679508740"><span class="annot"><span class="annottext">pm :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508740"><span class="hs-identifier hs-var hs-var">pm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508742"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-209"></span><span>
</span><span id="line-210"></span><span id="local-6989586621679509454"><span class="annot"><a href="PVGrammar.Parse.html#findLeftOrnament"><span class="hs-identifier hs-type">findLeftOrnament</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509454"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679509454"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679509454"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="PVGrammar.html#LeftOrnament"><span class="hs-identifier hs-type">LeftOrnament</span></a></span></span><span>
</span><span id="line-211"></span><span id="findLeftOrnament"><span class="annot"><span class="annottext">findLeftOrnament :: forall n. IsNote n =&gt; n -&gt; n -&gt; Maybe LeftOrnament
</span><a href="PVGrammar.Parse.html#findLeftOrnament"><span class="hs-identifier hs-var hs-var">findLeftOrnament</span></a></span></span><span> </span><span id="local-6989586621679508720"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508720"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679508719"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508719"><span class="hs-identifier hs-var">r</span></a></span></span><span>
</span><span id="line-212"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508718"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508717"><span class="hs-identifier hs-var">pr</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">LeftOrnament
</span><a href="PVGrammar.html#LeftRepeat"><span class="hs-identifier hs-var">LeftRepeat</span></a></span><span>
</span><span id="line-213"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">forall i. Diatonic i =&gt; i -&gt; Bool
</span><span class="hs-identifier hs-var">isStep</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508718"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">forall {v}. AdditiveGroup v =&gt; Pitch v -&gt; Pitch v -&gt; v
</span><span class="hs-operator hs-var">`pto`</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508717"><span class="hs-identifier hs-var">pr</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">LeftOrnament
</span><a href="PVGrammar.html#LeftNeighbor"><span class="hs-identifier hs-var">LeftNeighbor</span></a></span><span>
</span><span id="line-214"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-215"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-216"></span><span>  </span><span id="local-6989586621679508718"><span class="annot"><span class="annottext">pm :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508718"><span class="hs-identifier hs-var hs-var">pm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508720"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-217"></span><span>  </span><span id="local-6989586621679508717"><span class="annot"><span class="annottext">pr :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679508717"><span class="hs-identifier hs-var hs-var">pr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508719"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-218"></span><span>
</span><span id="line-219"></span><span class="hs-comment">-- evaluator interface</span><span>
</span><span id="line-220"></span><span class="hs-comment">-- ===================</span><span>
</span><span id="line-221"></span><span>
</span><span id="line-222"></span><span class="hs-comment">{- | The evaluator that represents the proto-voice grammar.
 As scores it returns a representation of each operation.
 These scores do not form a semiring,
 but can be embedded into different semirings using 'mapEvalScore'.
-}</span><span>
</span><span id="line-227"></span><span id="local-6989586621679509449"><span id="local-6989586621679509450"><span id="local-6989586621679509451"><span class="annot"><a href="PVGrammar.Parse.html#protoVoiceEvaluator"><span class="hs-identifier hs-type">protoVoiceEvaluator</span></a></span><span>
</span><span id="line-228"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509451"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509450"><span class="hs-identifier hs-type">t2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679509449"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679509449"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509449"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679509449"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509449"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-229"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509449"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679509451"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509449"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509449"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679509450"><span class="hs-identifier hs-type">t2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509449"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#PVLeftmost"><span class="hs-identifier hs-type">PVLeftmost</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509449"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-230"></span><span id="protoVoiceEvaluator"><span class="annot"><span class="annottext">protoVoiceEvaluator :: forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
</span><a href="PVGrammar.Parse.html#protoVoiceEvaluator"><span class="hs-identifier hs-var hs-var">protoVoiceEvaluator</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-231"></span><span>  </span><span class="annot"><span class="annottext">forall tr slc h s tr' f slc'.
UnspreadMiddle tr slc h
-&gt; UnspreadLeft tr slc
-&gt; UnspreadRight tr slc
-&gt; (StartStop slc -&gt; tr -&gt; slc -&gt; tr -&gt; StartStop slc -&gt; [(tr, s)])
-&gt; (StartStop slc -&gt; Maybe tr' -&gt; StartStop slc -&gt; [(tr, f)])
-&gt; (slc' -&gt; slc)
-&gt; Eval tr tr' slc slc' (Leftmost s f h)
</span><a href="Common.html#mkLeftmostEval"><span class="hs-identifier hs-var">mkLeftmostEval</span></a></span><span>
</span><span id="line-232"></span><span>    </span><span class="annot"><span class="annottext">forall n.
(Eq n, Ord n, Hashable n, IsNote n) =&gt;
UnspreadMiddle (Edges n) (Notes n) (Spread n)
</span><a href="PVGrammar.Parse.html#pvUnspreadMiddle"><span class="hs-identifier hs-var">pvUnspreadMiddle</span></a></span><span>
</span><span id="line-233"></span><span>    </span><span class="annot"><span class="annottext">forall n. UnspreadLeft (Edges n) (Notes n)
</span><a href="PVGrammar.Parse.html#pvUnspreadLeft"><span class="hs-identifier hs-var">pvUnspreadLeft</span></a></span><span>
</span><span id="line-234"></span><span>    </span><span class="annot"><span class="annottext">forall n. UnspreadRight (Edges n) (Notes n)
</span><a href="PVGrammar.Parse.html#pvUnspreadRight"><span class="hs-identifier hs-var">pvUnspreadRight</span></a></span><span>
</span><span id="line-235"></span><span>    </span><span class="annot"><span class="annottext">forall n.
(IsNote n, Notation n, Ord n, Hashable n) =&gt;
StartStop (Notes n)
-&gt; Edges n
-&gt; Notes n
-&gt; Edges n
-&gt; StartStop (Notes n)
-&gt; [(Edges n, Split n)]
</span><a href="PVGrammar.Parse.html#pvUnsplit"><span class="hs-identifier hs-var">pvUnsplit</span></a></span><span>
</span><span id="line-236"></span><span>    </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) n.
(Foldable t, Ord n, Hashable n) =&gt;
StartStop (Notes n)
-&gt; Maybe (t (Edge n)) -&gt; StartStop (Notes n) -&gt; [(Edges n, Freeze)]
</span><a href="PVGrammar.Parse.html#pvThaw"><span class="hs-identifier hs-var">pvThaw</span></a></span><span>
</span><span id="line-237"></span><span>    </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) n.
(Foldable t, Eq n, Hashable n) =&gt;
t n -&gt; Notes n
</span><a href="PVGrammar.Parse.html#pvSlice"><span class="hs-identifier hs-var">pvSlice</span></a></span><span>
</span><span id="line-238"></span><span>
</span><span id="line-239"></span><span class="hs-comment">{- | Computes the verticalization (unspread) of a middle transition.
 If the verticalization is admitted, returns the corresponding operation.
-}</span><span>
</span><span id="line-242"></span><span id="local-6989586621679509429"><span class="annot"><a href="PVGrammar.Parse.html#pvUnspreadMiddle"><span class="hs-identifier hs-type">pvUnspreadMiddle</span></a></span><span>
</span><span id="line-243"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679509429"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679509429"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509429"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509429"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-244"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#UnspreadMiddle"><span class="hs-identifier hs-type">UnspreadMiddle</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509429"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509429"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Spread"><span class="hs-identifier hs-type">Spread</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509429"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-245"></span><span id="pvUnspreadMiddle"><span class="annot"><span class="annottext">pvUnspreadMiddle :: forall n.
(Eq n, Ord n, Hashable n, IsNote n) =&gt;
UnspreadMiddle (Edges n) (Notes n) (Spread n)
</span><a href="PVGrammar.Parse.html#pvUnspreadMiddle"><span class="hs-identifier hs-var hs-var">pvUnspreadMiddle</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span id="local-6989586621679508642"><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508642"><span class="hs-identifier hs-var">nl</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508641"><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679508641"><span class="hs-identifier hs-var">edges</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span id="local-6989586621679508640"><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508640"><span class="hs-identifier hs-var">nr</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-246"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">any</span></span><span> </span><span class="annot"><span class="annottext">forall {a} {a} {f :: * -&gt; *}.
(ICOf (IntervalOf a) ~ ICOf (IntervalOf a),
 Eq (f (Pitch (ICOf (IntervalOf a)))), Functor f, HasPitch a,
 HasPitch a) =&gt;
(f a, f a) -&gt; Bool
</span><a href="#local-6989586621679508638"><span class="hs-identifier hs-var">notARepetition</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall n. Edges n -&gt; HashSet (Edge n)
</span><a href="PVGrammar.html#edgesReg"><span class="hs-identifier hs-var">edgesReg</span></a></span><span> </span><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679508641"><span class="hs-identifier hs-var">edges</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-247"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall n. MultiSet n -&gt; Notes n
</span><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-var">Notes</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508636"><span class="hs-identifier hs-var">top</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Spread n
</span><a href="#local-6989586621679508635"><span class="hs-identifier hs-var">op</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-248"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-249"></span><span>  </span><span id="local-6989586621679508638"><span class="annot"><span class="annottext">notARepetition :: (f a, f a) -&gt; Bool
</span><a href="#local-6989586621679508638"><span class="hs-identifier hs-var hs-var">notARepetition</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679508617"><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679508617"><span class="hs-identifier hs-var">p1</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508616"><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679508616"><span class="hs-identifier hs-var">p2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679508617"><span class="hs-identifier hs-var">p1</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679508616"><span class="hs-identifier hs-var">p2</span></a></span><span>
</span><span id="line-250"></span><span>  </span><span id="local-6989586621679508636"><span class="annot"><span class="annottext">top :: MultiSet n
</span><a href="#local-6989586621679508636"><span class="hs-identifier hs-var hs-var">top</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a.
(Eq a, Hashable a) =&gt;
MultiSet a -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#maxUnion"><span class="hs-identifier hs-var">MS.maxUnion</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508642"><span class="hs-identifier hs-var">nl</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508640"><span class="hs-identifier hs-var">nr</span></a></span><span>
</span><span id="line-251"></span><span>  </span><span id="local-6989586621679508613"><span class="annot"><span class="annottext">leftMS :: MultiSet n
</span><a href="#local-6989586621679508613"><span class="hs-identifier hs-var hs-var">leftMS</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508642"><span class="hs-identifier hs-var">nl</span></a></span><span> </span><span class="annot"><span class="annottext">forall a.
(Eq a, Hashable a) =&gt;
MultiSet a -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#%5C%5C"><span class="hs-operator hs-var">MS.\\</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508640"><span class="hs-identifier hs-var">nr</span></a></span><span>
</span><span id="line-252"></span><span>  </span><span id="local-6989586621679508611"><span class="annot"><span class="annottext">left :: HashMap n SpreadDirection
</span><a href="#local-6989586621679508611"><span class="hs-identifier hs-var hs-var">left</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall k v. (Eq k, Hashable k) =&gt; [(k, v)] -&gt; HashMap k v
</span><span class="hs-identifier hs-var">HM.fromList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; SpreadDirection
</span><a href="PVGrammar.html#ToLeft"><span class="hs-identifier hs-var">ToLeft</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall k. MultiSet k -&gt; [(k, Int)]
</span><a href="Internal.MultiSet.html#toOccurList"><span class="hs-identifier hs-var">MS.toOccurList</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508613"><span class="hs-identifier hs-var">leftMS</span></a></span><span>
</span><span id="line-253"></span><span>  </span><span id="local-6989586621679508606"><span class="annot"><span class="annottext">rightMS :: MultiSet n
</span><a href="#local-6989586621679508606"><span class="hs-identifier hs-var hs-var">rightMS</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508640"><span class="hs-identifier hs-var">nr</span></a></span><span> </span><span class="annot"><span class="annottext">forall a.
(Eq a, Hashable a) =&gt;
MultiSet a -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#%5C%5C"><span class="hs-operator hs-var">MS.\\</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508642"><span class="hs-identifier hs-var">nl</span></a></span><span>
</span><span id="line-254"></span><span>  </span><span id="local-6989586621679508605"><span class="annot"><span class="annottext">right :: HashMap n SpreadDirection
</span><a href="#local-6989586621679508605"><span class="hs-identifier hs-var hs-var">right</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall k v. (Eq k, Hashable k) =&gt; [(k, v)] -&gt; HashMap k v
</span><span class="hs-identifier hs-var">HM.fromList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; SpreadDirection
</span><a href="PVGrammar.html#ToRight"><span class="hs-identifier hs-var">ToRight</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall k. MultiSet k -&gt; [(k, Int)]
</span><a href="Internal.MultiSet.html#toOccurList"><span class="hs-identifier hs-var">MS.toOccurList</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508606"><span class="hs-identifier hs-var">rightMS</span></a></span><span>
</span><span id="line-255"></span><span>  </span><span id="local-6989586621679508603"><span class="annot"><span class="annottext">bothSet :: HashSet n
</span><a href="#local-6989586621679508603"><span class="hs-identifier hs-var hs-var">bothSet</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-256"></span><span>    </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; HashSet a -&gt; HashSet a -&gt; HashSet a
</span><span class="hs-identifier hs-var">S.intersection</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k. MultiSet k -&gt; HashSet k
</span><a href="Internal.MultiSet.html#toSet"><span class="hs-identifier hs-var">MS.toSet</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508642"><span class="hs-identifier hs-var">nl</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k. MultiSet k -&gt; HashSet k
</span><a href="Internal.MultiSet.html#toSet"><span class="hs-identifier hs-var">MS.toSet</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508640"><span class="hs-identifier hs-var">nr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-257"></span><span>      </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; HashSet a -&gt; HashSet a -&gt; HashSet a
</span><span class="hs-operator hs-var">`S.difference`</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k. MultiSet k -&gt; HashSet k
</span><a href="Internal.MultiSet.html#toSet"><span class="hs-identifier hs-var">MS.toSet</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508613"><span class="hs-identifier hs-var">leftMS</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; HashSet a -&gt; HashSet a -&gt; HashSet a
</span><span class="hs-operator hs-var">`S.union`</span></span><span> </span><span class="annot"><span class="annottext">forall k. MultiSet k -&gt; HashSet k
</span><a href="Internal.MultiSet.html#toSet"><span class="hs-identifier hs-var">MS.toSet</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508606"><span class="hs-identifier hs-var">rightMS</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-258"></span><span>  </span><span id="local-6989586621679508598"><span class="annot"><span class="annottext">both :: HashMap n SpreadDirection
</span><a href="#local-6989586621679508598"><span class="hs-identifier hs-var hs-var">both</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b -&gt; a) -&gt; a -&gt; HashSet b -&gt; a
</span><span class="hs-identifier hs-var">S.foldl'</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679508596"><span class="annot"><span class="annottext">HashMap n SpreadDirection
</span><a href="#local-6989586621679508596"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679508595"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508595"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall k v.
(Eq k, Hashable k) =&gt;
k -&gt; v -&gt; HashMap k v -&gt; HashMap k v
</span><span class="hs-identifier hs-var">HM.insert</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508595"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">SpreadDirection
</span><a href="PVGrammar.html#ToBoth"><span class="hs-identifier hs-var">ToBoth</span></a></span><span> </span><span class="annot"><span class="annottext">HashMap n SpreadDirection
</span><a href="#local-6989586621679508596"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall k v. HashMap k v
</span><span class="hs-identifier hs-var">HM.empty</span></span><span> </span><span class="annot"><span class="annottext">HashSet n
</span><a href="#local-6989586621679508603"><span class="hs-identifier hs-var">bothSet</span></a></span><span>
</span><span id="line-259"></span><span>  </span><span id="local-6989586621679508635"><span class="annot"><span class="annottext">op :: Spread n
</span><a href="#local-6989586621679508635"><span class="hs-identifier hs-var hs-var">op</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall n. HashMap n SpreadDirection -&gt; Edges n -&gt; Spread n
</span><a href="PVGrammar.html#SpreadOp"><span class="hs-identifier hs-var">SpreadOp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HashMap n SpreadDirection
</span><a href="#local-6989586621679508611"><span class="hs-identifier hs-var">left</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">HashMap n SpreadDirection
</span><a href="#local-6989586621679508605"><span class="hs-identifier hs-var">right</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">HashMap n SpreadDirection
</span><a href="#local-6989586621679508598"><span class="hs-identifier hs-var">both</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679508641"><span class="hs-identifier hs-var">edges</span></a></span><span>
</span><span id="line-260"></span><span>
</span><span id="line-261"></span><span class="hs-comment">{- | Computes all left parent transitions for a verticalization and a left child transition.
 Here, this operation is always admitted and unique,
 so the edges from the child transition are just passed through.
-}</span><span>
</span><span id="line-265"></span><span id="local-6989586621679509427"><span class="annot"><a href="PVGrammar.Parse.html#pvUnspreadLeft"><span class="hs-identifier hs-type">pvUnspreadLeft</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Common.html#UnspreadLeft"><span class="hs-identifier hs-type">UnspreadLeft</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509427"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509427"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-266"></span><span id="pvUnspreadLeft"><span class="annot"><span class="annottext">pvUnspreadLeft :: forall n. UnspreadLeft (Edges n) (Notes n)
</span><a href="PVGrammar.Parse.html#pvUnspreadLeft"><span class="hs-identifier hs-var hs-var">pvUnspreadLeft</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679508590"><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679508590"><span class="hs-identifier hs-var">el</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Notes n
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Notes n
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679508590"><span class="hs-identifier hs-var">el</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-267"></span><span>
</span><span id="line-268"></span><span class="hs-comment">{- | Computes all right parent transition for a verticalization and a right child transition.
 Here, this operation is always admitted and unique,
 so the edges from the child transition are just passed through.
-}</span><span>
</span><span id="line-272"></span><span id="local-6989586621679509426"><span class="annot"><a href="PVGrammar.Parse.html#pvUnspreadRight"><span class="hs-identifier hs-type">pvUnspreadRight</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Common.html#UnspreadRight"><span class="hs-identifier hs-type">UnspreadRight</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509426"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509426"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-273"></span><span id="pvUnspreadRight"><span class="annot"><span class="annottext">pvUnspreadRight :: forall n. UnspreadRight (Edges n) (Notes n)
</span><a href="PVGrammar.Parse.html#pvUnspreadRight"><span class="hs-identifier hs-var hs-var">pvUnspreadRight</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Notes n
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508589"><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679508589"><span class="hs-identifier hs-var">er</span></a></span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Notes n
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679508589"><span class="hs-identifier hs-var">er</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-274"></span><span>
</span><span id="line-275"></span><span class="hs-comment">{- | Computes all possible unsplits of two child transitions.
 Since transitions here only represent the certain edges,
 'pvUnsplit' must also take into account unelaborated edges,
 which are not present in the child transitions.
-}</span><span>
</span><span id="line-280"></span><span id="local-6989586621679509425"><span class="annot"><a href="PVGrammar.Parse.html#pvUnsplit"><span class="hs-identifier hs-type">pvUnsplit</span></a></span><span>
</span><span id="line-281"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509425"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679509425"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679509425"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509425"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-282"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#StartStop"><span class="hs-identifier hs-type">StartStop</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509425"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-283"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509425"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-284"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509425"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-285"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509425"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-286"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Common.html#StartStop"><span class="hs-identifier hs-type">StartStop</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509425"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-287"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509425"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Split"><span class="hs-identifier hs-type">Split</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509425"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span></span><span>
</span><span id="line-288"></span><span id="pvUnsplit"><span class="annot"><span class="annottext">pvUnsplit :: forall n.
(IsNote n, Notation n, Ord n, Hashable n) =&gt;
StartStop (Notes n)
-&gt; Edges n
-&gt; Notes n
-&gt; Edges n
-&gt; StartStop (Notes n)
-&gt; [(Edges n, Split n)]
</span><a href="PVGrammar.Parse.html#pvUnsplit"><span class="hs-identifier hs-var hs-var">pvUnsplit</span></a></span></span><span> </span><span id="local-6989586621679508423"><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679508423"><span class="hs-identifier hs-var">notesl</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span id="local-6989586621679508421"><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679508421"><span class="hs-identifier hs-var">leftRegs</span></a></span></span><span> </span><span id="local-6989586621679508420"><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679508420"><span class="hs-identifier hs-var">leftPass</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span id="local-6989586621679508419"><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508419"><span class="hs-identifier hs-var">notesm</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span id="local-6989586621679508418"><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679508418"><span class="hs-identifier hs-var">rightRegs</span></a></span></span><span> </span><span id="local-6989586621679508417"><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679508417"><span class="hs-identifier hs-var">rightPass</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679508416"><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679508416"><span class="hs-identifier hs-var">notesr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-289"></span><span>  </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">([(Edge n, (n, DoubleOrnament))],
 [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
 [(n, (n, LeftOrnament))])
-&gt; (Edges n, Split n)
</span><a href="#local-6989586621679508415"><span class="hs-identifier hs-var">mkTop</span></a></span><span> </span><span class="annot"><span class="annottext">[([(Edge n, (n, DoubleOrnament))],
  [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
  [(n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679508414"><span class="hs-identifier hs-var">combinations</span></a></span><span>
</span><span id="line-290"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-291"></span><span>  </span><span class="hs-comment">-- preprocessing of the notes left and right of the unsplit</span><span>
</span><span id="line-292"></span><span>  </span><span class="hs-glyph">!</span><span id="local-6989586621679508413"><span class="annot"><span class="annottext">innerL :: [EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679508413"><span class="hs-identifier hs-var hs-var">innerL</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall n. StartStop (Notes n) -&gt; [StartStop n]
</span><a href="PVGrammar.html#innerNotes"><span class="hs-identifier hs-var">innerNotes</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679508423"><span class="hs-identifier hs-var">notesl</span></a></span><span>
</span><span id="line-293"></span><span>  </span><span class="hs-glyph">!</span><span id="local-6989586621679508411"><span class="annot"><span class="annottext">innerR :: [EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679508411"><span class="hs-identifier hs-var hs-var">innerR</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall n. StartStop (Notes n) -&gt; [StartStop n]
</span><a href="PVGrammar.html#innerNotes"><span class="hs-identifier hs-var">innerNotes</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679508416"><span class="hs-identifier hs-var">notesr</span></a></span><span>
</span><span id="line-294"></span><span>
</span><span id="line-295"></span><span>  </span><span class="hs-comment">-- find all reduction options for every pitch</span><span>
</span><span id="line-296"></span><span>  </span><span class="hs-glyph">!</span><span id="local-6989586621679508410"><span class="annot"><span class="annottext">options :: [[([(Edge n, (n, DoubleOrnament))],
   [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
   [(n, (n, LeftOrnament))])]]
</span><a href="#local-6989586621679508410"><span class="hs-identifier hs-var hs-var">options</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(n, Int)
-&gt; [([(Edge n, (n, DoubleOrnament))],
     [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
     [(n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679508409"><span class="hs-identifier hs-var">noteOptions</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall k. MultiSet k -&gt; [(k, Int)]
</span><a href="Internal.MultiSet.html#toOccurList"><span class="hs-identifier hs-var">MS.toOccurList</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508419"><span class="hs-identifier hs-var">notesm</span></a></span><span>
</span><span id="line-297"></span><span>  </span><span id="local-6989586621679508409"><span class="annot"><span class="annottext">noteOptions :: (n, Int)
-&gt; [([(Edge n, (n, DoubleOrnament))],
     [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
     [(n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679508409"><span class="hs-identifier hs-var hs-var">noteOptions</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679508408"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508408"><span class="hs-identifier hs-var">note</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508407"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508407"><span class="hs-identifier hs-var">nocc</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-298"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508407"><span class="hs-identifier hs-var">nocc</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. MultiSet a -&gt; Int
</span><a href="Internal.MultiSet.html#size"><span class="hs-identifier hs-var">MS.size</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508404"><span class="hs-identifier hs-var">mandatoryLeft</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508407"><span class="hs-identifier hs-var">nocc</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. MultiSet a -&gt; Int
</span><a href="Internal.MultiSet.html#size"><span class="hs-identifier hs-var">MS.size</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508402"><span class="hs-identifier hs-var">mandatoryRight</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-299"></span><span>        </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-300"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-301"></span><span>        </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b c d.
Foldable t =&gt;
t (Elaboration a b c d) -&gt; ([a], [b], [c], [d])
</span><a href="PVGrammar.Parse.html#partitionElaborations"><span class="hs-identifier hs-var">partitionElaborations</span></a></span><span>
</span><span id="line-302"></span><span>          </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
-&gt; MultiSet (EdgeEither (StartStop n) n)
-&gt; Int
-&gt; [[Elaboration
       (Edge n, (n, DoubleOrnament))
       (InnerEdge n, (n, PassingOrnament))
       (n, (n, RightOrnament))
       (n, (n, LeftOrnament))]]
</span><a href="#local-6989586621679508401"><span class="hs-identifier hs-var">enumerateOptions</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508404"><span class="hs-identifier hs-var">mandatoryLeft</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508402"><span class="hs-identifier hs-var">mandatoryRight</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508407"><span class="hs-identifier hs-var">nocc</span></a></span><span>
</span><span id="line-303"></span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-304"></span><span>    </span><span class="hs-comment">-- compute the mandatory edges for the current pitch:</span><span>
</span><span id="line-305"></span><span>    </span><span id="local-6989586621679508400"><span class="annot"><span class="annottext">mleftRegs :: HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508400"><span class="hs-identifier hs-var hs-var">mleftRegs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall b a.
(Hashable b, Eq b) =&gt;
(a -&gt; b) -&gt; HashSet a -&gt; HashSet b
</span><span class="hs-identifier hs-var">S.map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; Bool) -&gt; HashSet a -&gt; HashSet a
</span><span class="hs-identifier hs-var">S.filter</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508408"><span class="hs-identifier hs-var">note</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679508421"><span class="hs-identifier hs-var">leftRegs</span></a></span><span>
</span><span id="line-306"></span><span>    </span><span id="local-6989586621679508397"><span class="annot"><span class="annottext">mleftPass :: MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508397"><span class="hs-identifier hs-var hs-var">mleftPass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall b a.
(Eq b, Hashable b) =&gt;
(a -&gt; b) -&gt; MultiSet a -&gt; MultiSet b
</span><a href="Internal.MultiSet.html#map"><span class="hs-identifier hs-var">MS.map</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. b -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-var">Pass</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; Bool) -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#filter"><span class="hs-identifier hs-var">MS.filter</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508408"><span class="hs-identifier hs-var">note</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679508420"><span class="hs-identifier hs-var">leftPass</span></a></span><span>
</span><span id="line-307"></span><span>    </span><span id="local-6989586621679508394"><span class="annot"><span class="annottext">mrightRegs :: HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508394"><span class="hs-identifier hs-var hs-var">mrightRegs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall b a.
(Hashable b, Eq b) =&gt;
(a -&gt; b) -&gt; HashSet a -&gt; HashSet b
</span><span class="hs-identifier hs-var">S.map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; Bool) -&gt; HashSet a -&gt; HashSet a
</span><span class="hs-identifier hs-var">S.filter</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508408"><span class="hs-identifier hs-var">note</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679508418"><span class="hs-identifier hs-var">rightRegs</span></a></span><span>
</span><span id="line-308"></span><span>    </span><span id="local-6989586621679508393"><span class="annot"><span class="annottext">mrightPass :: MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508393"><span class="hs-identifier hs-var hs-var">mrightPass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall b a.
(Eq b, Hashable b) =&gt;
(a -&gt; b) -&gt; MultiSet a -&gt; MultiSet b
</span><a href="Internal.MultiSet.html#map"><span class="hs-identifier hs-var">MS.map</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. b -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-var">Pass</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; Bool) -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#filter"><span class="hs-identifier hs-var">MS.filter</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508408"><span class="hs-identifier hs-var">note</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679508417"><span class="hs-identifier hs-var">rightPass</span></a></span><span>
</span><span id="line-309"></span><span>    </span><span id="local-6989586621679508404"><span class="annot"><span class="annottext">mandatoryLeft :: MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508404"><span class="hs-identifier hs-var hs-var">mandatoryLeft</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a.
(Foldable t, Eq a, Hashable a) =&gt;
t a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#fromSet"><span class="hs-identifier hs-var">MS.fromSet</span></a></span><span> </span><span class="annot"><span class="annottext">HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508400"><span class="hs-identifier hs-var">mleftRegs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508397"><span class="hs-identifier hs-var">mleftPass</span></a></span><span>
</span><span id="line-310"></span><span>    </span><span id="local-6989586621679508402"><span class="annot"><span class="annottext">mandatoryRight :: MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508402"><span class="hs-identifier hs-var hs-var">mandatoryRight</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a.
(Foldable t, Eq a, Hashable a) =&gt;
t a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#fromSet"><span class="hs-identifier hs-var">MS.fromSet</span></a></span><span> </span><span class="annot"><span class="annottext">HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508394"><span class="hs-identifier hs-var">mrightRegs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508393"><span class="hs-identifier hs-var">mrightPass</span></a></span><span>
</span><span id="line-311"></span><span>
</span><span id="line-312"></span><span>    </span><span class="hs-comment">-- the possible reductions of a (multiple) pitch are enumerated in three stages:</span><span>
</span><span id="line-313"></span><span>
</span><span id="line-314"></span><span>    </span><span class="hs-comment">-- stage 1: consume all mandatory edges on the left</span><span>
</span><span id="line-315"></span><span>    </span><span id="local-6989586621679508401"><span class="annot"><span class="annottext">enumerateOptions :: MultiSet (EdgeEither (StartStop n) n)
-&gt; MultiSet (EdgeEither (StartStop n) n)
-&gt; Int
-&gt; [[Elaboration
       (Edge n, (n, DoubleOrnament))
       (InnerEdge n, (n, PassingOrnament))
       (n, (n, RightOrnament))
       (n, (n, LeftOrnament))]]
</span><a href="#local-6989586621679508401"><span class="hs-identifier hs-var hs-var">enumerateOptions</span></a></span></span><span> </span><span id="local-6989586621679508391"><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508391"><span class="hs-identifier hs-var">ml</span></a></span></span><span> </span><span id="local-6989586621679508390"><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508390"><span class="hs-identifier hs-var">mr</span></a></span></span><span> </span><span id="local-6989586621679508389"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508389"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-316"></span><span>      </span><span class="hs-special">(</span><span id="local-6989586621679508388"><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508388"><span class="hs-identifier hs-var">mr'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508387"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508387"><span class="hs-identifier hs-var">n'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508386"><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508386"><span class="hs-identifier hs-var">acc</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) b a.
Monad m =&gt;
(b -&gt; a -&gt; m b) -&gt; b -&gt; MultiSet a -&gt; m b
</span><a href="Internal.MultiSet.html#foldM"><span class="hs-identifier hs-var">MS.foldM</span></a></span><span> </span><span class="annot"><span class="annottext">(MultiSet (EdgeEither (StartStop n) n), Int,
 [Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament))])
-&gt; EdgeEither (StartStop n) n
-&gt; [(MultiSet (EdgeEither (StartStop n) n), Int,
     [Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679508384"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508390"><span class="hs-identifier hs-var">mr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508389"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508391"><span class="hs-identifier hs-var">ml</span></a></span><span>
</span><span id="line-317"></span><span>      </span><span class="hs-special">(</span><span id="local-6989586621679508383"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508383"><span class="hs-identifier hs-var">n''</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508382"><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508382"><span class="hs-identifier hs-var">acc'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) b a.
Monad m =&gt;
(b -&gt; a -&gt; m b) -&gt; b -&gt; MultiSet a -&gt; m b
</span><a href="Internal.MultiSet.html#foldM"><span class="hs-identifier hs-var">MS.foldM</span></a></span><span> </span><span class="annot"><span class="annottext">(Int,
 [Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament))])
-&gt; EdgeEither (StartStop n) n
-&gt; [(Int,
     [Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679508381"><span class="hs-identifier hs-var">goR</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508387"><span class="hs-identifier hs-var">n'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508386"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508388"><span class="hs-identifier hs-var">mr'</span></a></span><span>
</span><span id="line-318"></span><span>      </span><span class="annot"><span class="annottext">forall {a}. [a] -&gt; Int -&gt; [a] -&gt; [[a]]
</span><a href="#local-6989586621679508380"><span class="hs-identifier hs-var">goFree</span></a></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508379"><span class="hs-identifier hs-var">freeOptions</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508383"><span class="hs-identifier hs-var">n''</span></a></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508382"><span class="hs-identifier hs-var">acc'</span></a></span><span>
</span><span id="line-319"></span><span>    </span><span id="local-6989586621679508384"><span class="annot"><span class="annottext">goL :: (MultiSet (EdgeEither (StartStop n) n), Int,
 [Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament))])
-&gt; EdgeEither (StartStop n) n
-&gt; [(MultiSet (EdgeEither (StartStop n) n), Int,
     [Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679508384"><span class="hs-identifier hs-var hs-var">goL</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-320"></span><span>    </span><span class="annot"><a href="#local-6989586621679508384"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679508378"><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508378"><span class="hs-identifier hs-var">mr</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508377"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508377"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508376"><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508376"><span class="hs-identifier hs-var">acc</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679508375"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508375"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-321"></span><span>      </span><span class="hs-special">(</span><span id="local-6989586621679508374"><span class="annot"><span class="annottext">Elaboration
  (Edge n, (n, DoubleOrnament))
  (InnerEdge n, (n, PassingOrnament))
  (n, (n, RightOrnament))
  (n, (n, LeftOrnament))
</span><a href="#local-6989586621679508374"><span class="hs-identifier hs-var">new</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508373"><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508373"><span class="hs-identifier hs-var">mr'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Int
-&gt; EdgeEither (StartStop n) n
-&gt; MultiSet (EdgeEither (StartStop n) n)
-&gt; [(Elaboration
       (Edge n, (n, DoubleOrnament))
       (InnerEdge n, (n, PassingOrnament))
       (n, (n, RightOrnament))
       (n, (n, LeftOrnament)),
     MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679508372"><span class="hs-identifier hs-var">pickLeft</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508377"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508375"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508378"><span class="hs-identifier hs-var">mr</span></a></span><span>
</span><span id="line-322"></span><span>      </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508373"><span class="hs-identifier hs-var">mr'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508377"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Elaboration
  (Edge n, (n, DoubleOrnament))
  (InnerEdge n, (n, PassingOrnament))
  (n, (n, RightOrnament))
  (n, (n, LeftOrnament))
</span><a href="#local-6989586621679508374"><span class="hs-identifier hs-var">new</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508376"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-323"></span><span>    </span><span class="hs-comment">-- combine a mandatory left with a mandatory right or free right edge</span><span>
</span><span id="line-324"></span><span>    </span><span id="local-6989586621679508372"><span class="annot"><span class="annottext">pickLeft :: Int
-&gt; EdgeEither (StartStop n) n
-&gt; MultiSet (EdgeEither (StartStop n) n)
-&gt; [(Elaboration
       (Edge n, (n, DoubleOrnament))
       (InnerEdge n, (n, PassingOrnament))
       (n, (n, RightOrnament))
       (n, (n, LeftOrnament)),
     MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679508372"><span class="hs-identifier hs-var hs-var">pickLeft</span></a></span></span><span> </span><span id="local-6989586621679508371"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508371"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679508370"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508370"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679508369"><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508369"><span class="hs-identifier hs-var">mr</span></a></span></span><span>
</span><span id="line-325"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508371"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. MultiSet a -&gt; Int
</span><a href="Internal.MultiSet.html#size"><span class="hs-identifier hs-var">MS.size</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508369"><span class="hs-identifier hs-var">mr</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679508367"><span class="hs-identifier hs-var">mand</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679508366"><span class="hs-identifier hs-var">opt</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679508365"><span class="hs-identifier hs-var">single</span></a></span><span>
</span><span id="line-326"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679508367"><span class="hs-identifier hs-var">mand</span></a></span><span>
</span><span id="line-327"></span><span>     </span><span class="hs-keyword">where</span><span>
</span><span id="line-328"></span><span>      </span><span id="local-6989586621679508367"><span class="annot"><span class="annottext">mand :: [(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679508367"><span class="hs-identifier hs-var hs-var">mand</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-329"></span><span>        </span><span id="local-6989586621679508364"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508364"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall k. MultiSet k -&gt; [k]
</span><a href="Internal.MultiSet.html#distinctElems"><span class="hs-identifier hs-var">MS.distinctElems</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508369"><span class="hs-identifier hs-var">mr</span></a></span><span>
</span><span id="line-330"></span><span>        </span><span id="local-6989586621679508362"><span class="annot"><span class="annottext">Elaboration
  (Edge n, (n, DoubleOrnament))
  (InnerEdge n, (n, PassingOrnament))
  (n, (n, RightOrnament))
  (n, (n, LeftOrnament))
</span><a href="#local-6989586621679508362"><span class="hs-identifier hs-var">red</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; [a]
</span><span class="hs-identifier hs-var">maybeToList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall {n} {c} {d}.
(HasPitch n, Diatonic (ICOf (IntervalOf n)),
 Eq (ICOf (IntervalOf n))) =&gt;
Bool
-&gt; Bool
-&gt; EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        c
        d)
</span><a href="#local-6989586621679508361"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508370"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508408"><span class="hs-identifier hs-var">note</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508364"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-331"></span><span>        </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Elaboration
  (Edge n, (n, DoubleOrnament))
  (InnerEdge n, (n, PassingOrnament))
  (n, (n, RightOrnament))
  (n, (n, LeftOrnament))
</span><a href="#local-6989586621679508362"><span class="hs-identifier hs-var">red</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#delete"><span class="hs-identifier hs-var">MS.delete</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508364"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508369"><span class="hs-identifier hs-var">mr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-332"></span><span>      </span><span class="hs-comment">-- TODO: remove mr options here?</span><span>
</span><span id="line-333"></span><span>      </span><span id="local-6989586621679508359"><span class="annot"><span class="annottext">tryOpt :: EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament)))
</span><a href="#local-6989586621679508359"><span class="hs-identifier hs-var hs-var">tryOpt</span></a></span></span><span> </span><span id="local-6989586621679508358"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508358"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall {n} {c} {d}.
(HasPitch n, Diatonic (ICOf (IntervalOf n)),
 Eq (ICOf (IntervalOf n))) =&gt;
Bool
-&gt; Bool
-&gt; EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        c
        d)
</span><a href="#local-6989586621679508361"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508358"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; HashSet a -&gt; Bool
</span><span class="hs-operator hs-var">`S.member`</span></span><span> </span><span class="annot"><span class="annottext">HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508394"><span class="hs-identifier hs-var">mrightRegs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508370"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508408"><span class="hs-identifier hs-var">note</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508358"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-334"></span><span>      </span><span id="local-6989586621679508366"><span class="annot"><span class="annottext">opt :: [(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679508366"><span class="hs-identifier hs-var hs-var">opt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508369"><span class="hs-identifier hs-var">mr</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament)))
</span><a href="#local-6989586621679508359"><span class="hs-identifier hs-var">tryOpt</span></a></span><span> </span><span class="annot"><span class="annottext">[EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679508411"><span class="hs-identifier hs-var">innerR</span></a></span><span>
</span><span id="line-335"></span><span>      </span><span id="local-6989586621679508365"><span class="annot"><span class="annottext">single :: [(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679508365"><span class="hs-identifier hs-var hs-var">single</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508369"><span class="hs-identifier hs-var">mr</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; [a]
</span><span class="hs-identifier hs-var">maybeToList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall {a} {b} {a} {b} {d}.
(HasPitch a, Diatonic (ICOf (IntervalOf a)),
 Eq (ICOf (IntervalOf a))) =&gt;
a
-&gt; EdgeEither (StartStop a) b
-&gt; Maybe (Elaboration a b (a, (a, RightOrnament)) d)
</span><a href="#local-6989586621679508356"><span class="hs-identifier hs-var">tryLeftReduction</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508408"><span class="hs-identifier hs-var">note</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508370"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-336"></span><span>
</span><span id="line-337"></span><span>    </span><span class="hs-comment">-- stage 2: consume all remaining mandatory edges on the right</span><span>
</span><span id="line-338"></span><span>    </span><span id="local-6989586621679508381"><span class="annot"><span class="annottext">goR :: (Int,
 [Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament))])
-&gt; EdgeEither (StartStop n) n
-&gt; [(Int,
     [Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679508381"><span class="hs-identifier hs-var hs-var">goR</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-339"></span><span>    </span><span class="annot"><a href="#local-6989586621679508381"><span class="hs-identifier hs-var">goR</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679508355"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508355"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508354"><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508354"><span class="hs-identifier hs-var">acc</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679508353"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508353"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-340"></span><span>      </span><span id="local-6989586621679508352"><span class="annot"><span class="annottext">Elaboration
  (Edge n, (n, DoubleOrnament))
  (InnerEdge n, (n, PassingOrnament))
  (n, (n, RightOrnament))
  (n, (n, LeftOrnament))
</span><a href="#local-6989586621679508352"><span class="hs-identifier hs-var">new</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
-&gt; [Elaboration
      (Edge n, (n, DoubleOrnament))
      (InnerEdge n, (n, PassingOrnament))
      (n, (n, RightOrnament))
      (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508351"><span class="hs-identifier hs-var">pickRight</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508353"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-341"></span><span>      </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508355"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Elaboration
  (Edge n, (n, DoubleOrnament))
  (InnerEdge n, (n, PassingOrnament))
  (n, (n, RightOrnament))
  (n, (n, LeftOrnament))
</span><a href="#local-6989586621679508352"><span class="hs-identifier hs-var">new</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508354"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-342"></span><span>    </span><span class="hs-comment">-- combine mandatory right with free left edge</span><span>
</span><span id="line-343"></span><span>    </span><span id="local-6989586621679508351"><span class="annot"><span class="annottext">pickRight :: EdgeEither (StartStop n) n
-&gt; [Elaboration
      (Edge n, (n, DoubleOrnament))
      (InnerEdge n, (n, PassingOrnament))
      (n, (n, RightOrnament))
      (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508351"><span class="hs-identifier hs-var hs-var">pickRight</span></a></span></span><span> </span><span id="local-6989586621679508350"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508350"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508349"><span class="hs-identifier hs-var">opt</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508348"><span class="hs-identifier hs-var">single</span></a></span><span>
</span><span id="line-344"></span><span>     </span><span class="hs-keyword">where</span><span>
</span><span id="line-345"></span><span>      </span><span id="local-6989586621679508347"><span class="annot"><span class="annottext">tryOpt :: EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament)))
</span><a href="#local-6989586621679508347"><span class="hs-identifier hs-var hs-var">tryOpt</span></a></span></span><span> </span><span id="local-6989586621679508346"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508346"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall {n} {c} {d}.
(HasPitch n, Diatonic (ICOf (IntervalOf n)),
 Eq (ICOf (IntervalOf n))) =&gt;
Bool
-&gt; Bool
-&gt; EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        c
        d)
</span><a href="#local-6989586621679508361"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508346"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; HashSet a -&gt; Bool
</span><span class="hs-operator hs-var">`S.member`</span></span><span> </span><span class="annot"><span class="annottext">HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508400"><span class="hs-identifier hs-var">mleftRegs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508346"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508408"><span class="hs-identifier hs-var">note</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508350"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-346"></span><span>      </span><span id="local-6989586621679508349"><span class="annot"><span class="annottext">opt :: [Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508349"><span class="hs-identifier hs-var hs-var">opt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament)))
</span><a href="#local-6989586621679508347"><span class="hs-identifier hs-var">tryOpt</span></a></span><span> </span><span class="annot"><span class="annottext">[EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679508413"><span class="hs-identifier hs-var">innerL</span></a></span><span>
</span><span id="line-347"></span><span>      </span><span id="local-6989586621679508348"><span class="annot"><span class="annottext">single :: [Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508348"><span class="hs-identifier hs-var hs-var">single</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; [a]
</span><span class="hs-identifier hs-var">maybeToList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall {a} {b} {a} {b} {c}.
(HasPitch a, Diatonic (ICOf (IntervalOf a)),
 Eq (ICOf (IntervalOf a))) =&gt;
a
-&gt; EdgeEither (StartStop a) b
-&gt; Maybe (Elaboration a b c (a, (a, LeftOrnament)))
</span><a href="#local-6989586621679508345"><span class="hs-identifier hs-var">tryRightReduction</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508408"><span class="hs-identifier hs-var">note</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508350"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-348"></span><span>
</span><span id="line-349"></span><span>    </span><span class="hs-comment">-- stage 3: explain all remaining notes through a combination of unknown edges</span><span>
</span><span id="line-350"></span><span>    </span><span id="local-6989586621679508380"><span class="annot"><span class="annottext">goFree :: [a] -&gt; Int -&gt; [a] -&gt; [[a]]
</span><a href="#local-6989586621679508380"><span class="hs-identifier hs-var hs-var">goFree</span></a></span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span id="local-6989586621679508333"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508333"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508333"><span class="hs-identifier hs-var">acc</span></a></span><span>
</span><span id="line-351"></span><span>    </span><span class="annot"><a href="#local-6989586621679508380"><span class="hs-identifier hs-var">goFree</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-352"></span><span>    </span><span class="annot"><a href="#local-6989586621679508380"><span class="hs-identifier hs-var">goFree</span></a></span><span> </span><span class="hs-special">[</span><span id="local-6989586621679508332"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508332"><span class="hs-identifier hs-var">lastOpt</span></a></span></span><span class="hs-special">]</span><span> </span><span id="local-6989586621679508331"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508331"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679508330"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508330"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. Int -&gt; a -&gt; [a]
</span><span class="hs-identifier hs-var">L.replicate</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508331"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508332"><span class="hs-identifier hs-var">lastOpt</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508330"><span class="hs-identifier hs-var">acc</span></a></span><span>
</span><span id="line-353"></span><span>    </span><span class="annot"><a href="#local-6989586621679508380"><span class="hs-identifier hs-var">goFree</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679508328"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508328"><span class="hs-identifier hs-var">opt</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621679508327"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508327"><span class="hs-identifier hs-var">opts</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679508326"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508326"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679508325"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508325"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-354"></span><span>      </span><span id="local-6989586621679508324"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508324"><span class="hs-identifier hs-var">nopt</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">..</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508326"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-355"></span><span>      </span><span class="annot"><span class="annottext">[a] -&gt; Int -&gt; [a] -&gt; [[a]]
</span><a href="#local-6989586621679508380"><span class="hs-identifier hs-var">goFree</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508327"><span class="hs-identifier hs-var">opts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508326"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508324"><span class="hs-identifier hs-var">nopt</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Int -&gt; a -&gt; [a]
</span><span class="hs-identifier hs-var">L.replicate</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508324"><span class="hs-identifier hs-var">nopt</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508328"><span class="hs-identifier hs-var">opt</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679508325"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-356"></span><span>    </span><span class="hs-comment">-- list all options for free reduction</span><span>
</span><span id="line-357"></span><span>    </span><span id="local-6989586621679508379"><span class="annot"><span class="annottext">freeOptions :: [Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508379"><span class="hs-identifier hs-var hs-var">freeOptions</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508323"><span class="hs-identifier hs-var">pickFreeBoth</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508322"><span class="hs-identifier hs-var">pickFreeLeft</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508321"><span class="hs-identifier hs-var">pickFreeRight</span></a></span><span>
</span><span id="line-358"></span><span>    </span><span class="hs-comment">-- combine two free edges</span><span>
</span><span id="line-359"></span><span>    </span><span id="local-6989586621679508323"><span class="annot"><span class="annottext">pickFreeBoth :: [Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508323"><span class="hs-identifier hs-var hs-var">pickFreeBoth</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-360"></span><span>      </span><span id="local-6989586621679508320"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508320"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679508413"><span class="hs-identifier hs-var">innerL</span></a></span><span>
</span><span id="line-361"></span><span>      </span><span id="local-6989586621679508319"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508319"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679508411"><span class="hs-identifier hs-var">innerR</span></a></span><span>
</span><span id="line-362"></span><span>      </span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; [a]
</span><span class="hs-identifier hs-var">maybeToList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-363"></span><span>        </span><span class="annot"><span class="annottext">forall {n} {c} {d}.
(HasPitch n, Diatonic (ICOf (IntervalOf n)),
 Eq (ICOf (IntervalOf n))) =&gt;
Bool
-&gt; Bool
-&gt; EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        c
        d)
</span><a href="#local-6989586621679508361"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508320"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; HashSet a -&gt; Bool
</span><span class="hs-operator hs-var">`S.member`</span></span><span> </span><span class="annot"><span class="annottext">HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508400"><span class="hs-identifier hs-var">mleftRegs</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508319"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; HashSet a -&gt; Bool
</span><span class="hs-operator hs-var">`S.member`</span></span><span> </span><span class="annot"><span class="annottext">HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679508394"><span class="hs-identifier hs-var">mrightRegs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508320"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508408"><span class="hs-identifier hs-var">note</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508319"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-364"></span><span>    </span><span class="hs-comment">-- reduce to left using free edge</span><span>
</span><span id="line-365"></span><span>    </span><span id="local-6989586621679508322"><span class="annot"><span class="annottext">pickFreeLeft :: [Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508322"><span class="hs-identifier hs-var hs-var">pickFreeLeft</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall {a} {b} {a} {b} {d}.
(HasPitch a, Diatonic (ICOf (IntervalOf a)),
 Eq (ICOf (IntervalOf a))) =&gt;
a
-&gt; EdgeEither (StartStop a) b
-&gt; Maybe (Elaboration a b (a, (a, RightOrnament)) d)
</span><a href="#local-6989586621679508356"><span class="hs-identifier hs-var">tryLeftReduction</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508408"><span class="hs-identifier hs-var">note</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679508413"><span class="hs-identifier hs-var">innerL</span></a></span><span>
</span><span id="line-366"></span><span>    </span><span class="hs-comment">-- reduce to right using free edge</span><span>
</span><span id="line-367"></span><span>    </span><span id="local-6989586621679508321"><span class="annot"><span class="annottext">pickFreeRight :: [Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508321"><span class="hs-identifier hs-var hs-var">pickFreeRight</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall {a} {b} {a} {b} {c}.
(HasPitch a, Diatonic (ICOf (IntervalOf a)),
 Eq (ICOf (IntervalOf a))) =&gt;
a
-&gt; EdgeEither (StartStop a) b
-&gt; Maybe (Elaboration a b c (a, (a, LeftOrnament)))
</span><a href="#local-6989586621679508345"><span class="hs-identifier hs-var">tryRightReduction</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508408"><span class="hs-identifier hs-var">note</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679508411"><span class="hs-identifier hs-var">innerR</span></a></span><span>
</span><span id="line-368"></span><span>
</span><span id="line-369"></span><span>  </span><span class="hs-comment">-- at all stages: try out potential reductions:</span><span>
</span><span id="line-370"></span><span>
</span><span id="line-371"></span><span>  </span><span class="hs-comment">-- two terminal edges: any ornament</span><span>
</span><span id="line-372"></span><span>  </span><span id="local-6989586621679508361"><span class="annot"><span class="annottext">tryReduction :: Bool
-&gt; Bool
-&gt; EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        c
        d)
</span><a href="#local-6989586621679508361"><span class="hs-identifier hs-var hs-var">tryReduction</span></a></span></span><span> </span><span id="local-6989586621679508301"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679508301"><span class="hs-identifier hs-var">lIsUsed</span></a></span></span><span> </span><span id="local-6989586621679508300"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679508300"><span class="hs-identifier hs-var">rIsUsed</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span id="local-6989586621679508299"><span class="annot"><span class="annottext">StartStop n
</span><a href="#local-6989586621679508299"><span class="hs-identifier hs-var">notel</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679508298"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508298"><span class="hs-identifier hs-var">notem</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span id="local-6989586621679508297"><span class="annot"><span class="annottext">StartStop n
</span><a href="#local-6989586621679508297"><span class="hs-identifier hs-var">noter</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-373"></span><span>    </span><span id="local-6989586621679508296"><span class="annot"><span class="annottext">EdgeEither (DoubleOrnament, Edge n) (PassingOrnament, InnerEdge n)
</span><a href="#local-6989586621679508296"><span class="hs-identifier hs-var">reduction</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall n.
IsNote n =&gt;
StartStop n
-&gt; StartStop n
-&gt; StartStop n
-&gt; Bool
-&gt; Bool
-&gt; Maybe
     (EdgeEither
        (DoubleOrnament, Edge n) (PassingOrnament, InnerEdge n))
</span><a href="PVGrammar.Parse.html#findOrnament"><span class="hs-identifier hs-var">findOrnament</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><a href="#local-6989586621679508299"><span class="hs-identifier hs-var">notel</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508298"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><a href="#local-6989586621679508297"><span class="hs-identifier hs-var">noter</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679508301"><span class="hs-identifier hs-var">lIsUsed</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679508300"><span class="hs-identifier hs-var">rIsUsed</span></a></span><span>
</span><span id="line-374"></span><span>    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">EdgeEither (DoubleOrnament, Edge n) (PassingOrnament, InnerEdge n)
</span><a href="#local-6989586621679508296"><span class="hs-identifier hs-var">reduction</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-375"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679508295"><span class="annot"><span class="annottext">DoubleOrnament
</span><a href="#local-6989586621679508295"><span class="hs-identifier hs-var">orn</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508294"><span class="annot"><span class="annottext">Edge n
</span><a href="#local-6989586621679508294"><span class="hs-identifier hs-var">parent</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a b c d. a -&gt; Elaboration a b c d
</span><a href="PVGrammar.Parse.html#EReg"><span class="hs-identifier hs-var">EReg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Edge n
</span><a href="#local-6989586621679508294"><span class="hs-identifier hs-var">parent</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508298"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">DoubleOrnament
</span><a href="#local-6989586621679508295"><span class="hs-identifier hs-var">orn</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-376"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-type">Pass</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679508293"><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679508293"><span class="hs-identifier hs-var">pass</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508292"><span class="annot"><span class="annottext">InnerEdge n
</span><a href="#local-6989586621679508292"><span class="hs-identifier hs-var">parent</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a b c d. b -&gt; Elaboration a b c d
</span><a href="PVGrammar.Parse.html#EPass"><span class="hs-identifier hs-var">EPass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">InnerEdge n
</span><a href="#local-6989586621679508292"><span class="hs-identifier hs-var">parent</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508298"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679508293"><span class="hs-identifier hs-var">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-377"></span><span>  </span><span class="hs-comment">-- a non-terminal edge left and a terminal edge right: passing note</span><span>
</span><span id="line-378"></span><span>  </span><span class="annot"><a href="#local-6989586621679508361"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679508291"><span class="annot"><span class="annottext">notel :: EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508291"><span class="hs-identifier hs-var">notel</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-type">Pass</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679508290"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508290"><span class="hs-identifier hs-var">notem</span></a></span></span><span> </span><span id="local-6989586621679508289"><span class="annot"><span class="annottext">noter :: EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508289"><span class="hs-identifier hs-var">noter</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-379"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679508288"><span class="annot"><span class="annottext">InnerEdge n
</span><a href="#local-6989586621679508288"><span class="hs-identifier hs-var">parent</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508287"><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679508287"><span class="hs-identifier hs-var">pass</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall n.
IsNote n =&gt;
EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe (InnerEdge n, PassingOrnament)
</span><a href="PVGrammar.Parse.html#findPassing"><span class="hs-identifier hs-var">findPassing</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508291"><span class="hs-identifier hs-var">notel</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508290"><span class="hs-identifier hs-var">notem</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508289"><span class="hs-identifier hs-var">noter</span></a></span><span>
</span><span id="line-380"></span><span>    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b c d. b -&gt; Elaboration a b c d
</span><a href="PVGrammar.Parse.html#EPass"><span class="hs-identifier hs-var">EPass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">InnerEdge n
</span><a href="#local-6989586621679508288"><span class="hs-identifier hs-var">parent</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508290"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679508287"><span class="hs-identifier hs-var">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-381"></span><span>  </span><span class="hs-comment">-- a terminal edge left and a non-terminal edge right: passing note</span><span>
</span><span id="line-382"></span><span>  </span><span class="annot"><a href="#local-6989586621679508361"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679508286"><span class="annot"><span class="annottext">notel :: EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508286"><span class="hs-identifier hs-var">notel</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679508285"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508285"><span class="hs-identifier hs-var">notem</span></a></span></span><span> </span><span id="local-6989586621679508284"><span class="annot"><span class="annottext">noter :: EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508284"><span class="hs-identifier hs-var">noter</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-type">Pass</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-383"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679508283"><span class="annot"><span class="annottext">InnerEdge n
</span><a href="#local-6989586621679508283"><span class="hs-identifier hs-var">parent</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508282"><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679508282"><span class="hs-identifier hs-var">pass</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall n.
IsNote n =&gt;
EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe (InnerEdge n, PassingOrnament)
</span><a href="PVGrammar.Parse.html#findPassing"><span class="hs-identifier hs-var">findPassing</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508286"><span class="hs-identifier hs-var">notel</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508285"><span class="hs-identifier hs-var">notem</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679508284"><span class="hs-identifier hs-var">noter</span></a></span><span>
</span><span id="line-384"></span><span>    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b c d. b -&gt; Elaboration a b c d
</span><a href="PVGrammar.Parse.html#EPass"><span class="hs-identifier hs-var">EPass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">InnerEdge n
</span><a href="#local-6989586621679508283"><span class="hs-identifier hs-var">parent</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679508285"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679508282"><span class="hs-identifier hs-var">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-385"></span><span>  </span><span class="hs-comment">-- all other combinations are forbidden</span><span>
</span><span id="line-386"></span><span>  </span><span class="annot"><a href="#local-6989586621679508361"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-387"></span><span>
</span><span id="line-388"></span><span>  </span><span class="hs-comment">-- single reduction to a left parent</span><span>
</span><span id="line-389"></span><span>  </span><span id="local-6989586621679508356"><span class="annot"><span class="annottext">tryLeftReduction :: a
-&gt; EdgeEither (StartStop a) b
-&gt; Maybe (Elaboration a b (a, (a, RightOrnament)) d)
</span><a href="#local-6989586621679508356"><span class="hs-identifier hs-var hs-var">tryLeftReduction</span></a></span></span><span> </span><span id="local-6989586621679508272"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508272"><span class="hs-identifier hs-var">notem</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679508271"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508271"><span class="hs-identifier hs-var">notel</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-390"></span><span>    </span><span id="local-6989586621679508270"><span class="annot"><span class="annottext">RightOrnament
</span><a href="#local-6989586621679508270"><span class="hs-identifier hs-var">orn</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall n. IsNote n =&gt; n -&gt; n -&gt; Maybe RightOrnament
</span><a href="PVGrammar.Parse.html#findRightOrnament"><span class="hs-identifier hs-var">findRightOrnament</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508271"><span class="hs-identifier hs-var">notel</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508272"><span class="hs-identifier hs-var">notem</span></a></span><span>
</span><span id="line-391"></span><span>    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b c d. c -&gt; Elaboration a b c d
</span><a href="PVGrammar.Parse.html#ER"><span class="hs-identifier hs-var">ER</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508271"><span class="hs-identifier hs-var">notel</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508272"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">RightOrnament
</span><a href="#local-6989586621679508270"><span class="hs-identifier hs-var">orn</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-392"></span><span>  </span><span class="annot"><a href="#local-6989586621679508356"><span class="hs-identifier hs-var">tryLeftReduction</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop a) b
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-393"></span><span>
</span><span id="line-394"></span><span>  </span><span class="hs-comment">-- single reduction to a right parent</span><span>
</span><span id="line-395"></span><span>  </span><span id="local-6989586621679508345"><span class="annot"><span class="annottext">tryRightReduction :: a
-&gt; EdgeEither (StartStop a) b
-&gt; Maybe (Elaboration a b c (a, (a, LeftOrnament)))
</span><a href="#local-6989586621679508345"><span class="hs-identifier hs-var hs-var">tryRightReduction</span></a></span></span><span> </span><span id="local-6989586621679508260"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508260"><span class="hs-identifier hs-var">notem</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679508259"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508259"><span class="hs-identifier hs-var">noter</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-396"></span><span>    </span><span id="local-6989586621679508258"><span class="annot"><span class="annottext">LeftOrnament
</span><a href="#local-6989586621679508258"><span class="hs-identifier hs-var">orn</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall n. IsNote n =&gt; n -&gt; n -&gt; Maybe LeftOrnament
</span><a href="PVGrammar.Parse.html#findLeftOrnament"><span class="hs-identifier hs-var">findLeftOrnament</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508260"><span class="hs-identifier hs-var">notem</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508259"><span class="hs-identifier hs-var">noter</span></a></span><span>
</span><span id="line-397"></span><span>    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b c d. d -&gt; Elaboration a b c d
</span><a href="PVGrammar.Parse.html#EL"><span class="hs-identifier hs-var">EL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508259"><span class="hs-identifier hs-var">noter</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508260"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">LeftOrnament
</span><a href="#local-6989586621679508258"><span class="hs-identifier hs-var">orn</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-398"></span><span>  </span><span class="annot"><a href="#local-6989586621679508345"><span class="hs-identifier hs-var">tryRightReduction</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop a) b
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-399"></span><span>
</span><span id="line-400"></span><span>  </span><span class="hs-comment">-- compute all possible combinations of reduction options</span><span>
</span><span id="line-401"></span><span>  </span><span class="hs-glyph">!</span><span id="local-6989586621679508414"><span class="annot"><span class="annottext">combinations :: [([(Edge n, (n, DoubleOrnament))],
  [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
  [(n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679508414"><span class="hs-identifier hs-var hs-var">combinations</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-402"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">any</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">L.null</span></span><span> </span><span class="annot"><span class="annottext">[[([(Edge n, (n, DoubleOrnament))],
   [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
   [(n, (n, LeftOrnament))])]]
</span><a href="#local-6989586621679508410"><span class="hs-identifier hs-var">options</span></a></span><span> </span><span class="hs-comment">-- check if any note has no options</span><span>
</span><span id="line-403"></span><span>      </span><span class="hs-keyword">then</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- if yes, then no reduction is possible at all</span><span>
</span><span id="line-404"></span><span>      </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (m :: * -&gt; *) b a.
(Foldable t, Monad m) =&gt;
(b -&gt; a -&gt; m b) -&gt; b -&gt; t a -&gt; m b
</span><span class="hs-identifier hs-var">foldM</span></span><span> </span><span class="annot"><span class="annottext">forall {m :: * -&gt; *} {a} {b} {c} {d}.
(Monad m, Semigroup a, Semigroup b, Semigroup c, Semigroup d) =&gt;
(a, b, c, d) -&gt; m (a, b, c, d) -&gt; m (a, b, c, d)
</span><a href="#local-6989586621679508256"><span class="hs-identifier hs-var">pickOption</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[[([(Edge n, (n, DoubleOrnament))],
   [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
   [(n, (n, LeftOrnament))])]]
</span><a href="#local-6989586621679508410"><span class="hs-identifier hs-var">options</span></a></span><span> </span><span class="hs-comment">-- otherwise, compute all combinations</span><span>
</span><span id="line-405"></span><span>      </span><span class="hs-comment">-- picks all different options for a single note in the list monad</span><span>
</span><span id="line-406"></span><span>  </span><span id="local-6989586621679508256"><span class="annot"><span class="annottext">pickOption :: (a, b, c, d) -&gt; m (a, b, c, d) -&gt; m (a, b, c, d)
</span><a href="#local-6989586621679508256"><span class="hs-identifier hs-var hs-var">pickOption</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679508242"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508242"><span class="hs-identifier hs-var">accReg</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508241"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679508241"><span class="hs-identifier hs-var">accPass</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508240"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679508240"><span class="hs-identifier hs-var">accL</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508239"><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679508239"><span class="hs-identifier hs-var">accR</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679508238"><span class="annot"><span class="annottext">m (a, b, c, d)
</span><a href="#local-6989586621679508238"><span class="hs-identifier hs-var">opts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-407"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679508237"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508237"><span class="hs-identifier hs-var">regs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508236"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679508236"><span class="hs-identifier hs-var">pass</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508235"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679508235"><span class="hs-identifier hs-var">ls</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508234"><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679508234"><span class="hs-identifier hs-var">rs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m (a, b, c, d)
</span><a href="#local-6989586621679508238"><span class="hs-identifier hs-var">opts</span></a></span><span>
</span><span id="line-408"></span><span>    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508237"><span class="hs-identifier hs-var">regs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508242"><span class="hs-identifier hs-var">accReg</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679508236"><span class="hs-identifier hs-var">pass</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679508241"><span class="hs-identifier hs-var">accPass</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679508235"><span class="hs-identifier hs-var">ls</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679508240"><span class="hs-identifier hs-var">accL</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679508234"><span class="hs-identifier hs-var">rs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679508239"><span class="hs-identifier hs-var">accR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-409"></span><span>
</span><span id="line-410"></span><span>  </span><span class="hs-comment">-- convert a combination into a derivation operation:</span><span>
</span><span id="line-411"></span><span>  </span><span class="hs-comment">-- turn the accumulated information into the format expected from the evaluator</span><span>
</span><span id="line-412"></span><span>  </span><span id="local-6989586621679508415"><span class="annot"><span class="annottext">mkTop :: ([(Edge n, (n, DoubleOrnament))],
 [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
 [(n, (n, LeftOrnament))])
-&gt; (Edges n, Split n)
</span><a href="#local-6989586621679508415"><span class="hs-identifier hs-var hs-var">mkTop</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679508233"><span class="annot"><span class="annottext">[(Edge n, (n, DoubleOrnament))]
</span><a href="#local-6989586621679508233"><span class="hs-identifier hs-var">regs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508232"><span class="annot"><span class="annottext">[(InnerEdge n, (n, PassingOrnament))]
</span><a href="#local-6989586621679508232"><span class="hs-identifier hs-var">pass</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508231"><span class="annot"><span class="annottext">[(n, (n, RightOrnament))]
</span><a href="#local-6989586621679508231"><span class="hs-identifier hs-var">rs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508230"><span class="annot"><span class="annottext">[(n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508230"><span class="hs-identifier hs-var">ls</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-413"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="hs-comment">-- validate</span><span>
</span><span id="line-414"></span><span>      </span><span class="hs-keyword">then</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679508229"><span class="hs-identifier hs-var">top</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall n.
Map (Edge n) [(n, DoubleOrnament)]
-&gt; Map (InnerEdge n) [(n, PassingOrnament)]
-&gt; Map n [(n, RightOrnament)]
-&gt; Map n [(n, LeftOrnament)]
-&gt; HashSet (Edge n)
-&gt; HashSet (Edge n)
-&gt; MultiSet (InnerEdge n)
-&gt; MultiSet (InnerEdge n)
-&gt; Split n
</span><a href="PVGrammar.html#SplitOp"><span class="hs-identifier hs-var">SplitOp</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Edge n) [(n, DoubleOrnament)]
</span><a href="#local-6989586621679508227"><span class="hs-identifier hs-var">tmap</span></a></span><span> </span><span class="annot"><span class="annottext">Map (InnerEdge n) [(n, PassingOrnament)]
</span><a href="#local-6989586621679508226"><span class="hs-identifier hs-var">ntmap</span></a></span><span> </span><span class="annot"><span class="annottext">Map n [(n, RightOrnament)]
</span><a href="#local-6989586621679508225"><span class="hs-identifier hs-var">rmap</span></a></span><span> </span><span class="annot"><span class="annottext">Map n [(n, LeftOrnament)]
</span><a href="#local-6989586621679508224"><span class="hs-identifier hs-var">lmap</span></a></span><span> </span><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679508421"><span class="hs-identifier hs-var">leftRegs</span></a></span><span> </span><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679508418"><span class="hs-identifier hs-var">rightRegs</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679508223"><span class="hs-identifier hs-var">passL</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679508222"><span class="hs-identifier hs-var">passR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-415"></span><span>      </span><span class="hs-keyword">else</span><span>
</span><span id="line-416"></span><span>        </span><span class="annot"><span class="annottext">forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-417"></span><span>          </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;invalid unsplit:\n  notesl=&quot;</span></span><span>
</span><span id="line-418"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679508423"><span class="hs-identifier hs-var">notesl</span></a></span><span>
</span><span id="line-419"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n  notesr=&quot;</span></span><span>
</span><span id="line-420"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679508416"><span class="hs-identifier hs-var">notesr</span></a></span><span>
</span><span id="line-421"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n  notesm=&quot;</span></span><span>
</span><span id="line-422"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall n. MultiSet n -&gt; Notes n
</span><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-var">Notes</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508419"><span class="hs-identifier hs-var">notesm</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-423"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n  left=&quot;</span></span><span>
</span><span id="line-424"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall n. HashSet (Edge n) -&gt; MultiSet (InnerEdge n) -&gt; Edges n
</span><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-var">Edges</span></a></span><span> </span><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679508421"><span class="hs-identifier hs-var">leftRegs</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679508420"><span class="hs-identifier hs-var">leftPass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-425"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n  right=&quot;</span></span><span>
</span><span id="line-426"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall n. HashSet (Edge n) -&gt; MultiSet (InnerEdge n) -&gt; Edges n
</span><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-var">Edges</span></a></span><span> </span><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679508418"><span class="hs-identifier hs-var">rightRegs</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679508417"><span class="hs-identifier hs-var">rightPass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-427"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n  top=&quot;</span></span><span>
</span><span id="line-428"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679508229"><span class="hs-identifier hs-var">top</span></a></span><span>
</span><span id="line-429"></span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-430"></span><span>    </span><span class="hs-comment">-- validate =</span><span>
</span><span id="line-431"></span><span>    </span><span class="hs-comment">--   all ((`L.elem` innerNotes notesl) . fst . fst) regs</span><span>
</span><span id="line-432"></span><span>    </span><span class="hs-comment">--     &amp;&amp; all ((`L.elem` innerNotes notesr) . snd . fst)   regs</span><span>
</span><span id="line-433"></span><span>    </span><span class="hs-comment">--     &amp;&amp; all ((`L.elem` innerNotes notesl) . Inner . fst) rs</span><span>
</span><span id="line-434"></span><span>    </span><span class="hs-comment">--     &amp;&amp; all ((`L.elem` innerNotes notesr) . Inner . fst) ls</span><span>
</span><span id="line-435"></span><span>
</span><span id="line-436"></span><span>    </span><span class="hs-comment">-- collect all operations</span><span>
</span><span id="line-437"></span><span>    </span><span id="local-6989586621679508214"><span class="annot"><span class="annottext">mapify :: [(k, a)] -&gt; Map k [a]
</span><a href="#local-6989586621679508214"><span class="hs-identifier hs-var hs-var">mapify</span></a></span></span><span> </span><span id="local-6989586621679508213"><span class="annot"><span class="annottext">[(k, a)]
</span><a href="#local-6989586621679508213"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; (a -&gt; a -&gt; a) -&gt; [(k, a)] -&gt; Map k a
</span><span class="hs-identifier hs-var">M.fromListWith</span></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">(&lt;&gt;)</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[(k, a)]
</span><a href="#local-6989586621679508213"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-438"></span><span>    </span><span id="local-6989586621679508227"><span class="annot"><span class="annottext">tmap :: Map (Edge n) [(n, DoubleOrnament)]
</span><a href="#local-6989586621679508227"><span class="hs-identifier hs-var hs-var">tmap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall {k} {a}. Ord k =&gt; [(k, a)] -&gt; Map k [a]
</span><a href="#local-6989586621679508214"><span class="hs-identifier hs-var">mapify</span></a></span><span> </span><span class="annot"><span class="annottext">[(Edge n, (n, DoubleOrnament))]
</span><a href="#local-6989586621679508233"><span class="hs-identifier hs-var">regs</span></a></span><span>
</span><span id="line-439"></span><span>    </span><span id="local-6989586621679508226"><span class="annot"><span class="annottext">ntmap :: Map (InnerEdge n) [(n, PassingOrnament)]
</span><a href="#local-6989586621679508226"><span class="hs-identifier hs-var hs-var">ntmap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall {k} {a}. Ord k =&gt; [(k, a)] -&gt; Map k [a]
</span><a href="#local-6989586621679508214"><span class="hs-identifier hs-var">mapify</span></a></span><span> </span><span class="annot"><span class="annottext">[(InnerEdge n, (n, PassingOrnament))]
</span><a href="#local-6989586621679508232"><span class="hs-identifier hs-var">pass</span></a></span><span>
</span><span id="line-440"></span><span>    </span><span id="local-6989586621679508224"><span class="annot"><span class="annottext">lmap :: Map n [(n, LeftOrnament)]
</span><a href="#local-6989586621679508224"><span class="hs-identifier hs-var hs-var">lmap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall {k} {a}. Ord k =&gt; [(k, a)] -&gt; Map k [a]
</span><a href="#local-6989586621679508214"><span class="hs-identifier hs-var">mapify</span></a></span><span> </span><span class="annot"><span class="annottext">[(n, (n, LeftOrnament))]
</span><a href="#local-6989586621679508230"><span class="hs-identifier hs-var">ls</span></a></span><span>
</span><span id="line-441"></span><span>    </span><span id="local-6989586621679508225"><span class="annot"><span class="annottext">rmap :: Map n [(n, RightOrnament)]
</span><a href="#local-6989586621679508225"><span class="hs-identifier hs-var hs-var">rmap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall {k} {a}. Ord k =&gt; [(k, a)] -&gt; Map k [a]
</span><a href="#local-6989586621679508214"><span class="hs-identifier hs-var">mapify</span></a></span><span> </span><span class="annot"><span class="annottext">[(n, (n, RightOrnament))]
</span><a href="#local-6989586621679508231"><span class="hs-identifier hs-var">rs</span></a></span><span>
</span><span id="line-442"></span><span>    </span><span id="local-6989586621679508229"><span class="annot"><span class="annottext">top :: Edges n
</span><a href="#local-6989586621679508229"><span class="hs-identifier hs-var hs-var">top</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall n. HashSet (Edge n) -&gt; MultiSet (InnerEdge n) -&gt; Edges n
</span><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-var">Edges</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; [a] -&gt; HashSet a
</span><span class="hs-identifier hs-var">S.fromList</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[(Edge n, (n, DoubleOrnament))]
</span><a href="#local-6989586621679508233"><span class="hs-identifier hs-var">regs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a.
(Foldable t, Eq a, Hashable a) =&gt;
t a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#fromList"><span class="hs-identifier hs-var">MS.fromList</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[(InnerEdge n, (n, PassingOrnament))]
</span><a href="#local-6989586621679508232"><span class="hs-identifier hs-var">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-443"></span><span>    </span><span id="local-6989586621679508223"><span class="annot"><span class="annottext">passL :: MultiSet (InnerEdge n)
</span><a href="#local-6989586621679508223"><span class="hs-identifier hs-var hs-var">passL</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#delete"><span class="hs-identifier hs-var">MS.delete</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679508420"><span class="hs-identifier hs-var">leftPass</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">forall {a} {b} {b}. ((a, b), (b, PassingOrnament)) -&gt; Maybe (a, b)
</span><a href="#local-6989586621679508208"><span class="hs-identifier hs-var">leftPassingChild</span></a></span><span> </span><span class="annot"><span class="annottext">[(InnerEdge n, (n, PassingOrnament))]
</span><a href="#local-6989586621679508232"><span class="hs-identifier hs-var">pass</span></a></span><span>
</span><span id="line-444"></span><span>    </span><span id="local-6989586621679508222"><span class="annot"><span class="annottext">passR :: MultiSet (InnerEdge n)
</span><a href="#local-6989586621679508222"><span class="hs-identifier hs-var hs-var">passR</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#delete"><span class="hs-identifier hs-var">MS.delete</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679508417"><span class="hs-identifier hs-var">rightPass</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">forall {a} {b} {a}. ((a, b), (a, PassingOrnament)) -&gt; Maybe (a, b)
</span><a href="#local-6989586621679508207"><span class="hs-identifier hs-var">rightPassingChild</span></a></span><span> </span><span class="annot"><span class="annottext">[(InnerEdge n, (n, PassingOrnament))]
</span><a href="#local-6989586621679508232"><span class="hs-identifier hs-var">pass</span></a></span><span>
</span><span id="line-445"></span><span>    </span><span id="local-6989586621679508208"><span class="annot"><span class="annottext">leftPassingChild :: ((a, b), (b, PassingOrnament)) -&gt; Maybe (a, b)
</span><a href="#local-6989586621679508208"><span class="hs-identifier hs-var hs-var">leftPassingChild</span></a></span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span id="local-6989586621679508204"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508204"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508203"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679508203"><span class="hs-identifier hs-var">_r</span></a></span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679508202"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679508202"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508201"><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679508201"><span class="hs-identifier hs-var">orn</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-446"></span><span>      </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679508201"><span class="hs-identifier hs-var">orn</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="PVGrammar.html#PassingRight"><span class="hs-identifier hs-var">PassingRight</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508204"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679508202"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-447"></span><span>    </span><span id="local-6989586621679508207"><span class="annot"><span class="annottext">rightPassingChild :: ((a, b), (a, PassingOrnament)) -&gt; Maybe (a, b)
</span><a href="#local-6989586621679508207"><span class="hs-identifier hs-var hs-var">rightPassingChild</span></a></span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span id="local-6989586621679508199"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508199"><span class="hs-identifier hs-var">_l</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508198"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679508198"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679508197"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508197"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508196"><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679508196"><span class="hs-identifier hs-var">orn</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-448"></span><span>      </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679508196"><span class="hs-identifier hs-var">orn</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="PVGrammar.html#PassingLeft"><span class="hs-identifier hs-var">PassingLeft</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679508197"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679508198"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-449"></span><span>
</span><span id="line-450"></span><span class="hs-comment">{- | Computes all potential ways a surface transition could have been frozen.
 In this grammar, this operation is unique and just turns ties into edges.
-}</span><span>
</span><span id="line-453"></span><span id="local-6989586621679509422"><span id="local-6989586621679509423"><span class="annot"><a href="PVGrammar.Parse.html#pvThaw"><span class="hs-identifier hs-type">pvThaw</span></a></span><span>
</span><span id="line-454"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509423"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679509422"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509422"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-455"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#StartStop"><span class="hs-identifier hs-type">StartStop</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509422"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-456"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679509423"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509422"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-457"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Common.html#StartStop"><span class="hs-identifier hs-type">StartStop</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509422"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-458"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509422"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Freeze"><span class="hs-identifier hs-type">Freeze</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span></span></span><span>
</span><span id="line-459"></span><span id="pvThaw"><span class="annot"><span class="annottext">pvThaw :: forall (t :: * -&gt; *) n.
(Foldable t, Ord n, Hashable n) =&gt;
StartStop (Notes n)
-&gt; Maybe (t (Edge n)) -&gt; StartStop (Notes n) -&gt; [(Edges n, Freeze)]
</span><a href="PVGrammar.Parse.html#pvThaw"><span class="hs-identifier hs-var hs-var">pvThaw</span></a></span></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679508184"><span class="annot"><span class="annottext">Maybe (t (Edge n))
</span><a href="#local-6989586621679508184"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall n. HashSet (Edge n) -&gt; MultiSet (InnerEdge n) -&gt; Edges n
</span><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-var">Edges</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; [a] -&gt; HashSet a
</span><span class="hs-identifier hs-var">S.fromList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; [a]
</span><span class="hs-identifier hs-var">toList</span></span><span> </span><span class="annot"><span class="annottext">Maybe (t (Edge n))
</span><a href="#local-6989586621679508184"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a. MultiSet a
</span><a href="Internal.MultiSet.html#empty"><span class="hs-identifier hs-var">MS.empty</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Freeze
</span><a href="PVGrammar.html#FreezeOp"><span class="hs-identifier hs-var">FreezeOp</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-460"></span><span>
</span><span id="line-461"></span><span id="local-6989586621679509419"><span id="local-6989586621679509420"><span class="annot"><a href="PVGrammar.Parse.html#pvSlice"><span class="hs-identifier hs-type">pvSlice</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509420"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679509419"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509419"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679509420"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509419"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509419"><span class="hs-identifier hs-type">n</span></a></span></span></span><span>
</span><span id="line-462"></span><span id="pvSlice"><span class="annot"><span class="annottext">pvSlice :: forall (t :: * -&gt; *) n.
(Foldable t, Eq n, Hashable n) =&gt;
t n -&gt; Notes n
</span><a href="PVGrammar.Parse.html#pvSlice"><span class="hs-identifier hs-var hs-var">pvSlice</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall n. MultiSet n -&gt; Notes n
</span><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-var">Notes</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a.
(Foldable t, Eq a, Hashable a) =&gt;
t a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#fromList"><span class="hs-identifier hs-var">MS.fromList</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; [a]
</span><span class="hs-identifier hs-var">toList</span></span><span>
</span><span id="line-463"></span><span>
</span><span id="line-464"></span><span class="hs-comment">-- evaluators in specific semirings</span><span>
</span><span id="line-465"></span><span class="hs-comment">-- ================================</span><span>
</span><span id="line-466"></span><span>
</span><span id="line-467"></span><span class="hs-comment">{- | A restricted version of the PV evaluator
 that prohibits split operations in which one of the parent slices is repeated entirely.
-}</span><span>
</span><span id="line-470"></span><span id="local-6989586621679508171"><span id="local-6989586621679508172"><span id="local-6989586621679508173"><span class="annot"><a href="PVGrammar.Parse.html#protoVoiceEvaluatorNoRepSplit"><span class="hs-identifier hs-type">protoVoiceEvaluatorNoRepSplit</span></a></span><span>
</span><span id="line-471"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679508173"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679508172"><span class="hs-identifier hs-type">t2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679508171"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679508171"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679508171"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679508171"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679508171"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-472"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679508171"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679508173"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679508171"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679508171"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679508172"><span class="hs-identifier hs-type">t2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679508171"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#PVLeftmost"><span class="hs-identifier hs-type">PVLeftmost</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679508171"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-473"></span><span id="protoVoiceEvaluatorNoRepSplit"><span class="annot"><span class="annottext">protoVoiceEvaluatorNoRepSplit :: forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
</span><a href="PVGrammar.Parse.html#protoVoiceEvaluatorNoRepSplit"><span class="hs-identifier hs-var hs-var">protoVoiceEvaluatorNoRepSplit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall tr tr' slc slc' v.
UnspreadMiddle tr slc v
-&gt; UnspreadLeft tr slc
-&gt; UnspreadRight tr slc
-&gt; Unsplit tr slc v
-&gt; (StartStop slc
    -&gt; Maybe tr' -&gt; StartStop slc -&gt; Bool -&gt; [(tr, v)])
-&gt; (slc' -&gt; slc)
-&gt; Eval tr tr' slc slc' v
</span><a href="Common.html#Eval"><span class="hs-identifier hs-var">Eval</span></a></span><span> </span><span class="annot"><span class="annottext">UnspreadMiddle (Edges n) (Notes n) (PVLeftmost n)
</span><a href="#local-6989586621679508159"><span class="hs-identifier hs-var">vm</span></a></span><span> </span><span class="annot"><span class="annottext">UnspreadLeft (Edges n) (Notes n)
</span><a href="#local-6989586621679508158"><span class="hs-identifier hs-var">vl</span></a></span><span> </span><span class="annot"><span class="annottext">UnspreadRight (Edges n) (Notes n)
</span><a href="#local-6989586621679508157"><span class="hs-identifier hs-var">vr</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
-&gt; Edges n
-&gt; Notes n
-&gt; Edges n
-&gt; StartStop (Notes n)
-&gt; SplitType
-&gt; [(Edges n, PVLeftmost n)]
</span><a href="#local-6989586621679508156"><span class="hs-identifier hs-var">filterSplit</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
-&gt; Maybe (t (Edge n))
-&gt; StartStop (Notes n)
-&gt; Bool
-&gt; [(Edges n, PVLeftmost n)]
</span><a href="#local-6989586621679508155"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">t2 n -&gt; Notes n
</span><a href="#local-6989586621679508154"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-474"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-475"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span> </span><span id="local-6989586621679508159"><span class="annot"><span class="annottext">UnspreadMiddle (Edges n) (Notes n) (PVLeftmost n)
</span><a href="#local-6989586621679508159"><span class="hs-identifier hs-var">vm</span></a></span></span><span> </span><span id="local-6989586621679508158"><span class="annot"><span class="annottext">UnspreadLeft (Edges n) (Notes n)
</span><a href="#local-6989586621679508158"><span class="hs-identifier hs-var">vl</span></a></span></span><span> </span><span id="local-6989586621679508157"><span class="annot"><span class="annottext">UnspreadRight (Edges n) (Notes n)
</span><a href="#local-6989586621679508157"><span class="hs-identifier hs-var">vr</span></a></span></span><span> </span><span id="local-6989586621679508143"><span class="annot"><span class="annottext">StartStop (Notes n)
-&gt; Edges n
-&gt; Notes n
-&gt; Edges n
-&gt; StartStop (Notes n)
-&gt; SplitType
-&gt; [(Edges n, PVLeftmost n)]
</span><a href="#local-6989586621679508143"><span class="hs-identifier hs-var">mg</span></a></span></span><span> </span><span id="local-6989586621679508155"><span class="annot"><span class="annottext">StartStop (Notes n)
-&gt; Maybe (t (Edge n))
-&gt; StartStop (Notes n)
-&gt; Bool
-&gt; [(Edges n, PVLeftmost n)]
</span><a href="#local-6989586621679508155"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679508154"><span class="annot"><span class="annottext">t2 n -&gt; Notes n
</span><a href="#local-6989586621679508154"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
</span><a href="PVGrammar.Parse.html#protoVoiceEvaluator"><span class="hs-identifier hs-var">protoVoiceEvaluator</span></a></span><span>
</span><span id="line-476"></span><span>  </span><span id="local-6989586621679508156"><span class="annot"><span class="annottext">filterSplit :: StartStop (Notes n)
-&gt; Edges n
-&gt; Notes n
-&gt; Edges n
-&gt; StartStop (Notes n)
-&gt; SplitType
-&gt; [(Edges n, PVLeftmost n)]
</span><a href="#local-6989586621679508156"><span class="hs-identifier hs-var hs-var">filterSplit</span></a></span></span><span> </span><span id="local-6989586621679508142"><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679508142"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679508141"><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679508141"><span class="hs-identifier hs-var">lt</span></a></span></span><span> </span><span id="local-6989586621679508140"><span class="annot"><span class="annottext">Notes n
</span><a href="#local-6989586621679508140"><span class="hs-identifier hs-var">mid</span></a></span></span><span> </span><span id="local-6989586621679508139"><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679508139"><span class="hs-identifier hs-var">rt</span></a></span></span><span> </span><span id="local-6989586621679508138"><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679508138"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span id="local-6989586621679508137"><span class="annot"><span class="annottext">SplitType
</span><a href="#local-6989586621679508137"><span class="hs-identifier hs-var">typ</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">filter</span></span><span> </span><span class="annot"><span class="annottext">forall {a} {a} {f} {h}. (a, Leftmost (Split a) f h) -&gt; Bool
</span><a href="#local-6989586621679508136"><span class="hs-identifier hs-var">ok</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
-&gt; Edges n
-&gt; Notes n
-&gt; Edges n
-&gt; StartStop (Notes n)
-&gt; SplitType
-&gt; [(Edges n, PVLeftmost n)]
</span><a href="#local-6989586621679508143"><span class="hs-identifier hs-var">mg</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679508142"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679508141"><span class="hs-identifier hs-var">lt</span></a></span><span> </span><span class="annot"><span class="annottext">Notes n
</span><a href="#local-6989586621679508140"><span class="hs-identifier hs-var">mid</span></a></span><span> </span><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679508139"><span class="hs-identifier hs-var">rt</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679508138"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">SplitType
</span><a href="#local-6989586621679508137"><span class="hs-identifier hs-var">typ</span></a></span><span>
</span><span id="line-477"></span><span>  </span><span id="local-6989586621679508136"><span class="annot"><span class="annottext">ok :: (a, Leftmost (Split a) f h) -&gt; Bool
</span><a href="#local-6989586621679508136"><span class="hs-identifier hs-var hs-var">ok</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Common.html#LMSplitLeft"><span class="hs-identifier hs-type">LMSplitLeft</span></a></span><span> </span><span id="local-6989586621679508134"><span class="annot"><span class="annottext">Split a
</span><a href="#local-6989586621679508134"><span class="hs-identifier hs-var">op</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall {a}. Split a -&gt; Bool
</span><a href="#local-6989586621679508132"><span class="hs-identifier hs-var">onlyRepeats</span></a></span><span> </span><span class="annot"><span class="annottext">Split a
</span><a href="#local-6989586621679508134"><span class="hs-identifier hs-var">op</span></a></span><span>
</span><span id="line-478"></span><span>  </span><span class="annot"><a href="#local-6989586621679508136"><span class="hs-identifier hs-var">ok</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Common.html#LMSplitOnly"><span class="hs-identifier hs-type">LMSplitOnly</span></a></span><span> </span><span id="local-6989586621679508130"><span class="annot"><span class="annottext">Split a
</span><a href="#local-6989586621679508130"><span class="hs-identifier hs-var">op</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall {a}. Split a -&gt; Bool
</span><a href="#local-6989586621679508132"><span class="hs-identifier hs-var">onlyRepeats</span></a></span><span> </span><span class="annot"><span class="annottext">Split a
</span><a href="#local-6989586621679508130"><span class="hs-identifier hs-var">op</span></a></span><span>
</span><span id="line-479"></span><span>  </span><span class="annot"><a href="#local-6989586621679508136"><span class="hs-identifier hs-var">ok</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Common.html#LMSplitRight"><span class="hs-identifier hs-type">LMSplitRight</span></a></span><span> </span><span id="local-6989586621679508128"><span class="annot"><span class="annottext">Split a
</span><a href="#local-6989586621679508128"><span class="hs-identifier hs-var">op</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall {a}. Split a -&gt; Bool
</span><a href="#local-6989586621679508132"><span class="hs-identifier hs-var">onlyRepeats</span></a></span><span> </span><span class="annot"><span class="annottext">Split a
</span><a href="#local-6989586621679508128"><span class="hs-identifier hs-var">op</span></a></span><span>
</span><span id="line-480"></span><span>  </span><span class="annot"><a href="#local-6989586621679508136"><span class="hs-identifier hs-var">ok</span></a></span><span> </span><span class="annot"><span class="annottext">(a, Leftmost (Split a) f h)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-481"></span><span>  </span><span id="local-6989586621679508132"><span class="annot"><span class="annottext">onlyRepeats :: Split a -&gt; Bool
</span><a href="#local-6989586621679508132"><span class="hs-identifier hs-var hs-var">onlyRepeats</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#SplitOp"><span class="hs-identifier hs-type">SplitOp</span></a></span><span> </span><span id="local-6989586621679508115"><span class="annot"><span class="annottext">Map (Edge a) [(a, DoubleOrnament)]
</span><a href="#local-6989586621679508115"><span class="hs-identifier hs-var">regs</span></a></span></span><span> </span><span id="local-6989586621679508114"><span class="annot"><span class="annottext">Map (InnerEdge a) [(a, PassingOrnament)]
</span><a href="#local-6989586621679508114"><span class="hs-identifier hs-var">pass</span></a></span></span><span> </span><span id="local-6989586621679508113"><span class="annot"><span class="annottext">Map a [(a, RightOrnament)]
</span><a href="#local-6989586621679508113"><span class="hs-identifier hs-var">rs</span></a></span></span><span> </span><span id="local-6989586621679508112"><span class="annot"><span class="annottext">Map a [(a, LeftOrnament)]
</span><a href="#local-6989586621679508112"><span class="hs-identifier hs-var">ls</span></a></span></span><span> </span><span class="annot"><span class="annottext">HashSet (Edge a)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">HashSet (Edge a)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge a)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge a)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-482"></span><span>    </span><span class="annot"><span class="annottext">forall k a. Map k a -&gt; Bool
</span><span class="hs-identifier hs-var">M.null</span></span><span> </span><span class="annot"><span class="annottext">Map (InnerEdge a) [(a, PassingOrnament)]
</span><a href="#local-6989586621679508114"><span class="hs-identifier hs-var">pass</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679508110"><span class="hs-identifier hs-var">allRepetitionsLeft</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679508109"><span class="hs-identifier hs-var">allRepetitionsRight</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-483"></span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-484"></span><span>    </span><span id="local-6989586621679508108"><span class="annot"><span class="annottext">allSinglesRepeat :: Bool
</span><a href="#local-6989586621679508108"><span class="hs-identifier hs-var hs-var">allSinglesRepeat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-485"></span><span>      </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall {t :: * -&gt; *} {b} {a} {a}.
Foldable t =&gt;
(b -&gt; Bool) -&gt; (a, t (a, b)) -&gt; Bool
</span><a href="#local-6989586621679508106"><span class="hs-identifier hs-var">check</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">RightOrnament
</span><a href="PVGrammar.html#RightRepeat"><span class="hs-identifier hs-var">RightRepeat</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">M.toList</span></span><span> </span><span class="annot"><span class="annottext">Map a [(a, RightOrnament)]
</span><a href="#local-6989586621679508113"><span class="hs-identifier hs-var">rs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-486"></span><span>        </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall {t :: * -&gt; *} {b} {a} {a}.
Foldable t =&gt;
(b -&gt; Bool) -&gt; (a, t (a, b)) -&gt; Bool
</span><a href="#local-6989586621679508106"><span class="hs-identifier hs-var">check</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">LeftOrnament
</span><a href="PVGrammar.html#LeftRepeat"><span class="hs-identifier hs-var">LeftRepeat</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">M.toList</span></span><span> </span><span class="annot"><span class="annottext">Map a [(a, LeftOrnament)]
</span><a href="#local-6989586621679508112"><span class="hs-identifier hs-var">ls</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-487"></span><span>    </span><span id="local-6989586621679508110"><span class="annot"><span class="annottext">allRepetitionsLeft :: Bool
</span><a href="#local-6989586621679508110"><span class="hs-identifier hs-var hs-var">allRepetitionsLeft</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-488"></span><span>      </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall {t :: * -&gt; *} {b} {a} {a}.
Foldable t =&gt;
(b -&gt; Bool) -&gt; (a, t (a, b)) -&gt; Bool
</span><a href="#local-6989586621679508106"><span class="hs-identifier hs-var">check</span></a></span><span> </span><span class="annot"><span class="annottext">DoubleOrnament -&gt; Bool
</span><a href="PVGrammar.html#isRepetitionOnLeft"><span class="hs-identifier hs-var">isRepetitionOnLeft</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">M.toList</span></span><span> </span><span class="annot"><span class="annottext">Map (Edge a) [(a, DoubleOrnament)]
</span><a href="#local-6989586621679508115"><span class="hs-identifier hs-var">regs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679508108"><span class="hs-identifier hs-var">allSinglesRepeat</span></a></span><span>
</span><span id="line-489"></span><span>    </span><span id="local-6989586621679508109"><span class="annot"><span class="annottext">allRepetitionsRight :: Bool
</span><a href="#local-6989586621679508109"><span class="hs-identifier hs-var hs-var">allRepetitionsRight</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-490"></span><span>      </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall {t :: * -&gt; *} {b} {a} {a}.
Foldable t =&gt;
(b -&gt; Bool) -&gt; (a, t (a, b)) -&gt; Bool
</span><a href="#local-6989586621679508106"><span class="hs-identifier hs-var">check</span></a></span><span> </span><span class="annot"><span class="annottext">DoubleOrnament -&gt; Bool
</span><a href="PVGrammar.html#isRepetitionOnRight"><span class="hs-identifier hs-var">isRepetitionOnRight</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">M.toList</span></span><span> </span><span class="annot"><span class="annottext">Map (Edge a) [(a, DoubleOrnament)]
</span><a href="#local-6989586621679508115"><span class="hs-identifier hs-var">regs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679508108"><span class="hs-identifier hs-var">allSinglesRepeat</span></a></span><span>
</span><span id="line-491"></span><span>  </span><span id="local-6989586621679508106"><span class="annot"><span class="annottext">check :: (b -&gt; Bool) -&gt; (a, t (a, b)) -&gt; Bool
</span><a href="#local-6989586621679508106"><span class="hs-identifier hs-var hs-var">check</span></a></span></span><span> </span><span id="local-6989586621679508100"><span class="annot"><span class="annottext">b -&gt; Bool
</span><a href="#local-6989586621679508100"><span class="hs-identifier hs-var">fpred</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508099"><span class="annot"><span class="annottext">t (a, b)
</span><a href="#local-6989586621679508099"><span class="hs-identifier hs-var">os</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">b -&gt; Bool
</span><a href="#local-6989586621679508100"><span class="hs-identifier hs-var">fpred</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">t (a, b)
</span><a href="#local-6989586621679508099"><span class="hs-identifier hs-var">os</span></a></span><span>
</span><span id="line-492"></span><span>
</span><span id="line-493"></span><span id="local-6989586621679509256"><span id="local-6989586621679509257"><span id="local-6989586621679509258"><span class="annot"><a href="PVGrammar.Parse.html#protoVoiceEvaluatorLimitedSize"><span class="hs-identifier hs-type">protoVoiceEvaluatorLimitedSize</span></a></span><span>
</span><span id="line-494"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509258"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509257"><span class="hs-identifier hs-type">t2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679509256"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679509256"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509256"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679509256"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509256"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-495"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span>
</span><span id="line-496"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509256"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679509258"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509256"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509256"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679509257"><span class="hs-identifier hs-type">t2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509256"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#PVLeftmost"><span class="hs-identifier hs-type">PVLeftmost</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509256"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-497"></span><span id="protoVoiceEvaluatorLimitedSize"><span class="annot"><span class="annottext">protoVoiceEvaluatorLimitedSize :: forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Int -&gt; Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
</span><a href="PVGrammar.Parse.html#protoVoiceEvaluatorLimitedSize"><span class="hs-identifier hs-var hs-var">protoVoiceEvaluatorLimitedSize</span></a></span></span><span> </span><span id="local-6989586621679508086"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508086"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall tr tr' slc slc' v.
UnspreadMiddle tr slc v
-&gt; UnspreadLeft tr slc
-&gt; UnspreadRight tr slc
-&gt; Unsplit tr slc v
-&gt; (StartStop slc
    -&gt; Maybe tr' -&gt; StartStop slc -&gt; Bool -&gt; [(tr, v)])
-&gt; (slc' -&gt; slc)
-&gt; Eval tr tr' slc slc' v
</span><a href="Common.html#Eval"><span class="hs-identifier hs-var">Eval</span></a></span><span> </span><span class="annot"><span class="annottext">(Notes n, Edges n, Notes n) -&gt; Maybe (Notes n, PVLeftmost n)
</span><a href="#local-6989586621679508085"><span class="hs-identifier hs-var">filterUnspreadM</span></a></span><span> </span><span class="annot"><span class="annottext">UnspreadLeft (Edges n) (Notes n)
</span><a href="#local-6989586621679508084"><span class="hs-identifier hs-var">vl</span></a></span><span> </span><span class="annot"><span class="annottext">UnspreadRight (Edges n) (Notes n)
</span><a href="#local-6989586621679508083"><span class="hs-identifier hs-var">vr</span></a></span><span> </span><span class="annot"><span class="annottext">Unsplit (Edges n) (Notes n) (PVLeftmost n)
</span><a href="#local-6989586621679508082"><span class="hs-identifier hs-var">mg</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
-&gt; Maybe (t (Edge n))
-&gt; StartStop (Notes n)
-&gt; Bool
-&gt; [(Edges n, PVLeftmost n)]
</span><a href="#local-6989586621679508081"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">t2 n -&gt; Notes n
</span><a href="#local-6989586621679508080"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-498"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-499"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span> </span><span id="local-6989586621679508069"><span class="annot"><span class="annottext">(Notes n, Edges n, Notes n) -&gt; Maybe (Notes n, PVLeftmost n)
</span><a href="#local-6989586621679508069"><span class="hs-identifier hs-var">vm</span></a></span></span><span> </span><span id="local-6989586621679508084"><span class="annot"><span class="annottext">UnspreadLeft (Edges n) (Notes n)
</span><a href="#local-6989586621679508084"><span class="hs-identifier hs-var">vl</span></a></span></span><span> </span><span id="local-6989586621679508083"><span class="annot"><span class="annottext">UnspreadRight (Edges n) (Notes n)
</span><a href="#local-6989586621679508083"><span class="hs-identifier hs-var">vr</span></a></span></span><span> </span><span id="local-6989586621679508082"><span class="annot"><span class="annottext">Unsplit (Edges n) (Notes n) (PVLeftmost n)
</span><a href="#local-6989586621679508082"><span class="hs-identifier hs-var">mg</span></a></span></span><span> </span><span id="local-6989586621679508081"><span class="annot"><span class="annottext">StartStop (Notes n)
-&gt; Maybe (t (Edge n))
-&gt; StartStop (Notes n)
-&gt; Bool
-&gt; [(Edges n, PVLeftmost n)]
</span><a href="#local-6989586621679508081"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679508080"><span class="annot"><span class="annottext">t2 n -&gt; Notes n
</span><a href="#local-6989586621679508080"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
</span><a href="PVGrammar.Parse.html#protoVoiceEvaluator"><span class="hs-identifier hs-var">protoVoiceEvaluator</span></a></span><span>
</span><span id="line-500"></span><span>
</span><span id="line-501"></span><span>  </span><span id="local-6989586621679508085"><span class="annot"><span class="annottext">filterUnspreadM :: (Notes n, Edges n, Notes n) -&gt; Maybe (Notes n, PVLeftmost n)
</span><a href="#local-6989586621679508085"><span class="hs-identifier hs-var hs-var">filterUnspreadM</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679508068"><span class="annot"><span class="annottext">Notes n
</span><a href="#local-6989586621679508068"><span class="hs-identifier hs-var">sl</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508067"><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679508067"><span class="hs-identifier hs-var">tm</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508066"><span class="annot"><span class="annottext">Notes n
</span><a href="#local-6989586621679508066"><span class="hs-identifier hs-var">sr</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span>
</span><span id="line-502"></span><span>    </span><span id="local-6989586621679508065"><span class="annot"><span class="annottext">(Notes n, PVLeftmost n)
</span><a href="#local-6989586621679508065"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(Notes n, Edges n, Notes n) -&gt; Maybe (Notes n, PVLeftmost n)
</span><a href="#local-6989586621679508069"><span class="hs-identifier hs-var">vm</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Notes n
</span><a href="#local-6989586621679508068"><span class="hs-identifier hs-var">sl</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679508067"><span class="hs-identifier hs-var">tm</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Notes n
</span><a href="#local-6989586621679508066"><span class="hs-identifier hs-var">sr</span></a></span><span class="hs-special">)</span><span> </span><span>
</span><span id="line-503"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">(Notes n, PVLeftmost n)
</span><a href="#local-6989586621679508065"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="hs-keyword">of</span><span> </span><span>
</span><span id="line-504"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span id="local-6989586621679508064"><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508064"><span class="hs-identifier hs-var">ns</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679508063"><span class="annot"><span class="annottext">PVLeftmost n
</span><a href="#local-6989586621679508063"><span class="hs-identifier hs-var">v'</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-505"></span><span>        </span><span class="hs-glyph">|</span><span>  </span><span class="annot"><span class="annottext">forall a. MultiSet a -&gt; Int
</span><a href="Internal.MultiSet.html#size"><span class="hs-identifier hs-var">MS.size</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508064"><span class="hs-identifier hs-var">ns</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679508086"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall n. MultiSet n -&gt; Notes n
</span><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-var">Notes</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679508064"><span class="hs-identifier hs-var">ns</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PVLeftmost n
</span><a href="#local-6989586621679508063"><span class="hs-identifier hs-var">v'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-506"></span><span>        </span><span class="hs-glyph">|</span><span>  </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-507"></span><span>
</span><span id="line-508"></span><span class="hs-comment">-- | An evaluator for protovoices that produces values in the 'Derivations' semiring.</span><span>
</span><span id="line-509"></span><span id="local-6989586621679509250"><span id="local-6989586621679509251"><span id="local-6989586621679509252"><span class="annot"><a href="PVGrammar.Parse.html#pvDerivUnrestricted"><span class="hs-identifier hs-type">pvDerivUnrestricted</span></a></span><span>
</span><span id="line-510"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509252"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509251"><span class="hs-identifier hs-type">t2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679509250"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679509250"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509250"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679509250"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509250"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-511"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span>
</span><span id="line-512"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509250"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-513"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679509252"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509250"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-514"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509250"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-515"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679509251"><span class="hs-identifier hs-type">t2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509250"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-516"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Derivations"><span class="hs-identifier hs-type">Derivations</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#PVLeftmost"><span class="hs-identifier hs-type">PVLeftmost</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509250"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-517"></span><span id="pvDerivUnrestricted"><span class="annot"><span class="annottext">pvDerivUnrestricted :: forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval
  (Edges n)
  (t (Edge n))
  (Notes n)
  (t2 n)
  (Derivations (PVLeftmost n))
</span><a href="PVGrammar.Parse.html#pvDerivUnrestricted"><span class="hs-identifier hs-var hs-var">pvDerivUnrestricted</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall v w tr tr' slc slc'.
(v -&gt; w) -&gt; Eval tr tr' slc slc' v -&gt; Eval tr tr' slc slc' w
</span><a href="Common.html#mapEvalScore"><span class="hs-identifier hs-var">mapEvalScore</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Derivations a
</span><a href="Common.html#Do"><span class="hs-identifier hs-var">Do</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
</span><a href="PVGrammar.Parse.html#protoVoiceEvaluator"><span class="hs-identifier hs-var">protoVoiceEvaluator</span></a></span><span>
</span><span id="line-518"></span><span>
</span><span id="line-519"></span><span class="hs-comment">{- | An evaluator for protovoices that produces values in the 'Derivations' semiring.

 - Enforces right-branching spreads (see 'rightBranchSpread').
-}</span><span>
</span><span id="line-523"></span><span id="local-6989586621679509236"><span id="local-6989586621679509237"><span id="local-6989586621679509238"><span class="annot"><a href="PVGrammar.Parse.html#pvDerivRightBranch"><span class="hs-identifier hs-type">pvDerivRightBranch</span></a></span><span>
</span><span id="line-524"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509238"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509237"><span class="hs-identifier hs-type">t2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679509236"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679509236"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509236"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679509236"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509236"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-525"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span>
</span><span id="line-526"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Merged"><span class="hs-identifier hs-type">Merged</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#RightBranchSpread"><span class="hs-identifier hs-type">RightBranchSpread</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509236"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-527"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679509238"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509236"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-528"></span><span>      </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509236"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-529"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679509237"><span class="hs-identifier hs-type">t2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509236"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-530"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Derivations"><span class="hs-identifier hs-type">Derivations</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#PVLeftmost"><span class="hs-identifier hs-type">PVLeftmost</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509236"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-531"></span><span id="pvDerivRightBranch"><span class="annot"><span class="annottext">pvDerivRightBranch :: forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval
  (Merged, (RightBranchSpread, Edges n))
  (t (Edge n))
  ((), ((), Notes n))
  (t2 n)
  (Derivations (PVLeftmost n))
</span><a href="PVGrammar.Parse.html#pvDerivRightBranch"><span class="hs-identifier hs-var hs-var">pvDerivRightBranch</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-532"></span><span>  </span><span class="annot"><span class="annottext">forall tr tr' slc slc' w.
Eval tr tr' slc slc' w -&gt; Eval (Merged, tr) tr' ((), slc) slc' w
</span><a href="Common.html#splitFirst"><span class="hs-identifier hs-var">splitFirst</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall tr tr' slc slc' w.
Eval tr tr' slc slc' w
-&gt; Eval (RightBranchSpread, tr) tr' ((), slc) slc' w
</span><a href="Common.html#rightBranchSpread"><span class="hs-identifier hs-var">rightBranchSpread</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall v w tr tr' slc slc'.
(v -&gt; w) -&gt; Eval tr tr' slc slc' v -&gt; Eval tr tr' slc slc' w
</span><a href="Common.html#mapEvalScore"><span class="hs-identifier hs-var">mapEvalScore</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Derivations a
</span><a href="Common.html#Do"><span class="hs-identifier hs-var">Do</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
</span><a href="PVGrammar.Parse.html#protoVoiceEvaluatorNoRepSplit"><span class="hs-identifier hs-var">protoVoiceEvaluatorNoRepSplit</span></a></span><span>
</span><span id="line-533"></span><span>
</span><span id="line-534"></span><span class="hs-comment">-- | An evaluator for protovoices that produces values in the counting semiring.</span><span>
</span><span id="line-535"></span><span id="local-6989586621679509218"><span id="local-6989586621679509219"><span id="local-6989586621679509220"><span class="annot"><a href="PVGrammar.Parse.html#pvCountUnrestricted"><span class="hs-identifier hs-type">pvCountUnrestricted</span></a></span><span>
</span><span id="line-536"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509220"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509219"><span class="hs-identifier hs-type">t2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679509218"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679509218"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509218"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679509218"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509218"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-537"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509218"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679509220"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509218"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509218"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679509219"><span class="hs-identifier hs-type">t2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509218"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span></span></span></span><span>
</span><span id="line-538"></span><span id="pvCountUnrestricted"><span class="annot"><span class="annottext">pvCountUnrestricted :: forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) Int
</span><a href="PVGrammar.Parse.html#pvCountUnrestricted"><span class="hs-identifier hs-var hs-var">pvCountUnrestricted</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall v w tr tr' slc slc'.
(v -&gt; w) -&gt; Eval tr tr' slc slc' v -&gt; Eval tr tr' slc slc' w
</span><a href="Common.html#mapEvalScore"><span class="hs-identifier hs-var">mapEvalScore</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
</span><a href="PVGrammar.Parse.html#protoVoiceEvaluator"><span class="hs-identifier hs-var">protoVoiceEvaluator</span></a></span><span>
</span><span id="line-539"></span><span>
</span><span id="line-540"></span><span class="hs-comment">{- | An evaluator for protovoices that produces values in the counting semiring.

 - Prohibits split operations in which one of the parent slices is repeated entirely (see 'protoVoiceEvaluatorNoRepSplit').
-}</span><span>
</span><span id="line-544"></span><span id="local-6989586621679508012"><span id="local-6989586621679508013"><span id="local-6989586621679508014"><span class="annot"><a href="PVGrammar.Parse.html#pvCountNoRepSplit"><span class="hs-identifier hs-type">pvCountNoRepSplit</span></a></span><span>
</span><span id="line-545"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679508014"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679508013"><span class="hs-identifier hs-type">t2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679508012"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679508012"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679508012"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679508012"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679508012"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-546"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679508012"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679508014"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679508012"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679508012"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679508013"><span class="hs-identifier hs-type">t2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679508012"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span></span></span></span><span>
</span><span id="line-547"></span><span id="pvCountNoRepSplit"><span class="annot"><span class="annottext">pvCountNoRepSplit :: forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) Int
</span><a href="PVGrammar.Parse.html#pvCountNoRepSplit"><span class="hs-identifier hs-var hs-var">pvCountNoRepSplit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall v w tr tr' slc slc'.
(v -&gt; w) -&gt; Eval tr tr' slc slc' v -&gt; Eval tr tr' slc slc' w
</span><a href="Common.html#mapEvalScore"><span class="hs-identifier hs-var">mapEvalScore</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
</span><a href="PVGrammar.Parse.html#protoVoiceEvaluatorNoRepSplit"><span class="hs-identifier hs-var">protoVoiceEvaluatorNoRepSplit</span></a></span><span>
</span><span id="line-548"></span><span>
</span><span id="line-549"></span><span class="hs-comment">{- | An evaluator for protovoices that produces values in the counting semiring.

 - Prohibits split operations in which one of the parent slices is repeated entirely (see 'protoVoiceEvaluatorNoRepSplit').
 - Enforces right-branching spreads (see 'rightBranchSpread').
-}</span><span>
</span><span id="line-554"></span><span id="local-6989586621679509207"><span id="local-6989586621679509208"><span id="local-6989586621679509209"><span class="annot"><a href="PVGrammar.Parse.html#pvCountNoRepSplitRightBranch"><span class="hs-identifier hs-type">pvCountNoRepSplitRightBranch</span></a></span><span>
</span><span id="line-555"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509209"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509208"><span class="hs-identifier hs-type">t2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679509207"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679509207"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509207"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679509207"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509207"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-556"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#RightBranchSpread"><span class="hs-identifier hs-type">RightBranchSpread</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509207"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679509209"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509207"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509207"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679509208"><span class="hs-identifier hs-type">t2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509207"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span></span></span></span><span>
</span><span id="line-557"></span><span id="pvCountNoRepSplitRightBranch"><span class="annot"><span class="annottext">pvCountNoRepSplitRightBranch :: forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval
  (RightBranchSpread, Edges n) (t (Edge n)) ((), Notes n) (t2 n) Int
</span><a href="PVGrammar.Parse.html#pvCountNoRepSplitRightBranch"><span class="hs-identifier hs-var hs-var">pvCountNoRepSplitRightBranch</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall tr tr' slc slc' w.
Eval tr tr' slc slc' w
-&gt; Eval (RightBranchSpread, tr) tr' ((), slc) slc' w
</span><a href="Common.html#rightBranchSpread"><span class="hs-identifier hs-var">rightBranchSpread</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) Int
</span><a href="PVGrammar.Parse.html#pvCountNoRepSplit"><span class="hs-identifier hs-var">pvCountNoRepSplit</span></a></span><span>
</span><span id="line-558"></span><span>
</span><span id="line-559"></span><span class="hs-comment">{- | An evaluator for protovoices that produces values in the counting semiring.

 - Prohibits split operations in which one of the parent slices is repeated entirely (see 'protoVoiceEvaluatorNoRepSplit').
 - Enforces right-branching spreads (see 'rightBranchSpread').
 - Normalizes the order of adjacent split and spread operations to split-before-spread (see 'splitFirst').
-}</span><span>
</span><span id="line-565"></span><span id="local-6989586621679509201"><span id="local-6989586621679509202"><span id="local-6989586621679509203"><span class="annot"><a href="PVGrammar.Parse.html#pvCountNoRepSplitRightBranchSplitFirst"><span class="hs-identifier hs-type">pvCountNoRepSplitRightBranchSplitFirst</span></a></span><span>
</span><span id="line-566"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509203"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509202"><span class="hs-identifier hs-type">t2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679509201"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679509201"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509201"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679509201"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679509201"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-567"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span>
</span><span id="line-568"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Merged"><span class="hs-identifier hs-type">Merged</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#RightBranchSpread"><span class="hs-identifier hs-type">RightBranchSpread</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509201"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-569"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679509203"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509201"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-570"></span><span>      </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509201"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-571"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679509202"><span class="hs-identifier hs-type">t2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679509201"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-572"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span></span></span></span><span>
</span><span id="line-573"></span><span id="pvCountNoRepSplitRightBranchSplitFirst"><span class="annot"><span class="annottext">pvCountNoRepSplitRightBranchSplitFirst :: forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval
  (Merged, (RightBranchSpread, Edges n))
  (t (Edge n))
  ((), ((), Notes n))
  (t2 n)
  Int
</span><a href="PVGrammar.Parse.html#pvCountNoRepSplitRightBranchSplitFirst"><span class="hs-identifier hs-var hs-var">pvCountNoRepSplitRightBranchSplitFirst</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall tr tr' slc slc' w.
Eval tr tr' slc slc' w -&gt; Eval (Merged, tr) tr' ((), slc) slc' w
</span><a href="Common.html#splitFirst"><span class="hs-identifier hs-var">splitFirst</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval
  (RightBranchSpread, Edges n) (t (Edge n)) ((), Notes n) (t2 n) Int
</span><a href="PVGrammar.Parse.html#pvCountNoRepSplitRightBranch"><span class="hs-identifier hs-var">pvCountNoRepSplitRightBranch</span></a></span><span>
</span><span id="line-574"></span></pre></body></html>