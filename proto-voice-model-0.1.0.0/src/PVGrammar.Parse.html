<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE DeriveAnyClass #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE TypeFamilies #-}</span><span>
</span><span id="line-3"></span><span>
</span><span id="line-4"></span><span class="hs-comment">{- | This module contains code that is specific to parsing the protovoice grammar.
 It implements a number of evaluators ('Eval') that can be used with the various parsers.
-}</span><span>
</span><span id="line-7"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">PVGrammar.Parse</span><span>
</span><span id="line-8"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-comment">-- * Generic Parsing</span></span><span>
</span><span id="line-9"></span><span>
</span><span id="line-10"></span><span>    </span><span class="hs-comment">-- | Evaluators that directly return protovoice operations.</span><span>
</span><span id="line-11"></span><span>    </span><span class="hs-comment">-- They can be embedded into a semiring using 'mapEvalScore'.</span><span>
</span><span id="line-12"></span><span>    </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier">IsNote</span></a></span><span>
</span><span id="line-13"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#protoVoiceEvaluator"><span class="hs-identifier">protoVoiceEvaluator</span></a></span><span>
</span><span id="line-14"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#protoVoiceEvaluatorImpure"><span class="hs-identifier">protoVoiceEvaluatorImpure</span></a></span><span>
</span><span id="line-15"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#protoVoiceEvaluatorNoRepSplit"><span class="hs-identifier">protoVoiceEvaluatorNoRepSplit</span></a></span><span>
</span><span id="line-16"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#protoVoiceEvaluatorLimitedSize"><span class="hs-identifier">protoVoiceEvaluatorLimitedSize</span></a></span><span>
</span><span id="line-17"></span><span>
</span><span id="line-18"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Parsing Derivations</span></span><span>
</span><span id="line-19"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#pvDerivUnrestricted"><span class="hs-identifier">pvDerivUnrestricted</span></a></span><span>
</span><span id="line-20"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#pvDerivRightBranch"><span class="hs-identifier">pvDerivRightBranch</span></a></span><span>
</span><span id="line-21"></span><span>
</span><span id="line-22"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Counting Parses</span></span><span>
</span><span id="line-23"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#pvCountUnrestricted"><span class="hs-identifier">pvCountUnrestricted</span></a></span><span>
</span><span id="line-24"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#pvCountNoRepSplit"><span class="hs-identifier">pvCountNoRepSplit</span></a></span><span>
</span><span id="line-25"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#pvCountNoRepSplitRightBranch"><span class="hs-identifier">pvCountNoRepSplitRightBranch</span></a></span><span>
</span><span id="line-26"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#pvCountNoRepSplitRightBranchSplitFirst"><span class="hs-identifier">pvCountNoRepSplitRightBranchSplitFirst</span></a></span><span>
</span><span id="line-27"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-28"></span><span>
</span><span id="line-29"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Common.html"><span class="hs-identifier">Common</span></a></span><span>
</span><span id="line-30"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="PVGrammar.html"><span class="hs-identifier">PVGrammar</span></a></span><span>
</span><span id="line-31"></span><span>
</span><span id="line-32"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Musicology.Pitch</span></span><span>
</span><span id="line-33"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">Diatonic</span></span><span>
</span><span id="line-34"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Interval</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-35"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Notation</span></span><span>
</span><span id="line-36"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">pc</span></span><span>
</span><span id="line-37"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">pto</span></span><span>
</span><span id="line-38"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-39"></span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Probability.html"><span class="hs-identifier">Probability</span></a></span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Numeric.Probability.Distribution</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">P</span></span><span>
</span><span id="line-42"></span><span>
</span><span id="line-43"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span>
</span><span id="line-44"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.DeepSeq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">NFData</span></span><span class="hs-special">)</span><span>
</span><span id="line-45"></span><span class="hs-comment">-- import Control.Monad (foldM)</span><span>
</span><span id="line-46"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Foldable</span></span><span>
</span><span id="line-47"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">foldl'</span></span><span>
</span><span id="line-48"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">toList</span></span><span>
</span><span id="line-49"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.HashMap.Strict</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">HM</span></span><span>
</span><span id="line-51"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.HashSet</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">S</span></span><span>
</span><span id="line-52"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Hashable</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Hashable</span></span><span class="hs-special">)</span><span>
</span><span id="line-53"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Kind</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Constraint</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Type</span></span><span class="hs-special">)</span><span>
</span><span id="line-54"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.List</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">L</span></span><span>
</span><span id="line-55"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map.Strict</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">M</span></span><span>
</span><span id="line-56"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span>
</span><span id="line-57"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">catMaybes</span></span><span>
</span><span id="line-58"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">mapMaybe</span></span><span>
</span><span id="line-59"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">maybeToList</span></span><span>
</span><span id="line-60"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-61"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">GHC.Generics</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Generic</span></span><span class="hs-special">)</span><span>
</span><span id="line-62"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Internal.MultiSet.html"><span class="hs-identifier">Internal.MultiSet</span></a></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">MS</span></span><span>
</span><span id="line-63"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Musicology.Core</span></span><span>
</span><span id="line-64"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><span class="hs-identifier">HasPitch</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-65"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Pitch</span></span><span>
</span><span id="line-66"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Pitched</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-67"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">isStep</span></span><span>
</span><span id="line-68"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-69"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">System.Random.Stateful</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">initStdGen</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">newIOGenM</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">StatefulGen</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">IOGenM</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">StdGen</span></span><span class="hs-special">)</span><span>
</span><span id="line-70"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Trans.Maybe</span></span><span>
</span><span id="line-71"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Trans</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">lift</span></span><span class="hs-special">)</span><span>
</span><span id="line-72"></span><span>
</span><span id="line-73"></span><span class="hs-comment">-- helper type: Either for terminal and non-terminal edges</span><span>
</span><span id="line-74"></span><span class="hs-comment">-- -------------------------------------------------------</span><span>
</span><span id="line-75"></span><span>
</span><span id="line-76"></span><span class="hs-comment">{- | A tag that distinguishes between objects related to terminal and non-terminal edges.
 Like 'Either', but with semantic constructor names to avoid confusion.
-}</span><span>
</span><span id="line-79"></span><span id="local-6989586621679526582"><span id="local-6989586621679526583"></span></span><span class="hs-keyword">data</span><span> </span><span id="EdgeEither"><span class="annot"><a href="PVGrammar.Parse.html#EdgeEither"><span class="hs-identifier hs-var">EdgeEither</span></a></span></span><span> </span><span id="local-6989586621679527138"><span class="annot"><a href="#local-6989586621679527138"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679527137"><span class="annot"><a href="#local-6989586621679527137"><span class="hs-identifier hs-type">b</span></a></span></span><span>
</span><span id="line-80"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- | marks an terminal edge (or some related object)</span><span>
</span><span id="line-81"></span><span>    </span><span id="Reg"><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><a href="#local-6989586621679527138"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-82"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-comment">-- | marks a non-terminal edge (or some related object)</span><span>
</span><span id="line-83"></span><span>    </span><span id="Pass"><span class="annot"><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-var">Pass</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><a href="#local-6989586621679527137"><span class="hs-identifier hs-type">b</span></a></span><span>
</span><span id="line-84"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679526574"><span id="local-6989586621679526578"><span class="annot"><span class="annottext">EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall a b.
(Eq a, Eq b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
/= :: EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
$c/= :: forall a b.
(Eq a, Eq b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
== :: EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
$c== :: forall a b.
(Eq a, Eq b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526550"><span id="local-6989586621679526552"><span id="local-6989586621679526555"><span id="local-6989586621679526558"><span id="local-6989586621679526561"><span id="local-6989586621679526565"><span id="local-6989586621679526569"><span class="annot"><span class="annottext">EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
EdgeEither a b -&gt; EdgeEither a b -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {a} {b}. (Ord a, Ord b) =&gt; Eq (EdgeEither a b)
forall a b.
(Ord a, Ord b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
forall a b.
(Ord a, Ord b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; Ordering
forall a b.
(Ord a, Ord b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; EdgeEither a b
min :: EdgeEither a b -&gt; EdgeEither a b -&gt; EdgeEither a b
$cmin :: forall a b.
(Ord a, Ord b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; EdgeEither a b
max :: EdgeEither a b -&gt; EdgeEither a b -&gt; EdgeEither a b
$cmax :: forall a b.
(Ord a, Ord b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; EdgeEither a b
&gt;= :: EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
$c&gt;= :: forall a b.
(Ord a, Ord b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
&gt; :: EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
$c&gt; :: forall a b.
(Ord a, Ord b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
&lt;= :: EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
$c&lt;= :: forall a b.
(Ord a, Ord b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
&lt; :: EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
$c&lt; :: forall a b.
(Ord a, Ord b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; Bool
compare :: EdgeEither a b -&gt; EdgeEither a b -&gt; Ordering
$ccompare :: forall a b.
(Ord a, Ord b) =&gt;
EdgeEither a b -&gt; EdgeEither a b -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526538"><span id="local-6989586621679526540"><span id="local-6989586621679526547"><span class="annot"><span class="annottext">Int -&gt; EdgeEither a b -&gt; ShowS
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall a b. (Show a, Show b) =&gt; Int -&gt; EdgeEither a b -&gt; ShowS
forall a b. (Show a, Show b) =&gt; [EdgeEither a b] -&gt; ShowS
forall a b. (Show a, Show b) =&gt; EdgeEither a b -&gt; String
showList :: [EdgeEither a b] -&gt; ShowS
$cshowList :: forall a b. (Show a, Show b) =&gt; [EdgeEither a b] -&gt; ShowS
show :: EdgeEither a b -&gt; String
$cshow :: forall a b. (Show a, Show b) =&gt; EdgeEither a b -&gt; String
showsPrec :: Int -&gt; EdgeEither a b -&gt; ShowS
$cshowsPrec :: forall a b. (Show a, Show b) =&gt; Int -&gt; EdgeEither a b -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall a b x. Rep (EdgeEither a b) x -&gt; EdgeEither a b
forall a b x. EdgeEither a b -&gt; Rep (EdgeEither a b) x
$cto :: forall a b x. Rep (EdgeEither a b) x -&gt; EdgeEither a b
$cfrom :: forall a b x. EdgeEither a b -&gt; Rep (EdgeEither a b) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526528"><span id="local-6989586621679526530"><span class="annot"><span class="annottext">forall a. Eq a -&gt; (Int -&gt; a -&gt; Int) -&gt; (a -&gt; Int) -&gt; Hashable a
forall {a} {b}. (Hashable a, Hashable b) =&gt; Eq (EdgeEither a b)
forall a b.
(Hashable a, Hashable b) =&gt;
Int -&gt; EdgeEither a b -&gt; Int
forall a b. (Hashable a, Hashable b) =&gt; EdgeEither a b -&gt; Int
hash :: EdgeEither a b -&gt; Int
$chash :: forall a b. (Hashable a, Hashable b) =&gt; EdgeEither a b -&gt; Int
hashWithSalt :: Int -&gt; EdgeEither a b -&gt; Int
$chashWithSalt :: forall a b.
(Hashable a, Hashable b) =&gt;
Int -&gt; EdgeEither a b -&gt; Int
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Hashable</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526525"><span class="annot"><span class="annottext">forall a. (a -&gt; ()) -&gt; NFData a
forall a b. (NFData a, NFData b) =&gt; EdgeEither a b -&gt; ()
rnf :: EdgeEither a b -&gt; ()
$crnf :: forall a b. (NFData a, NFData b) =&gt; EdgeEither a b -&gt; ()
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">NFData</span></span></span><span class="hs-special">)</span><span>
</span><span id="line-85"></span><span>
</span><span id="line-86"></span><span class="hs-comment">-- helper type: enum for possible operations</span><span>
</span><span id="line-87"></span><span class="hs-comment">-- -----------------------------------------</span><span>
</span><span id="line-88"></span><span>
</span><span id="line-89"></span><span class="hs-comment">{- | A tag that distinguishes four different types of operations:
  regular split, passing split, left ornament, and right ornament
-}</span><span>
</span><span id="line-92"></span><span id="local-6989586621679526522"><span id="local-6989586621679526523"></span></span><span class="hs-keyword">data</span><span> </span><span id="Elaboration"><span class="annot"><a href="PVGrammar.Parse.html#Elaboration"><span class="hs-identifier hs-var">Elaboration</span></a></span></span><span> </span><span id="local-6989586621679527126"><span class="annot"><a href="#local-6989586621679527126"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679527125"><span class="annot"><a href="#local-6989586621679527125"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span id="local-6989586621679527124"><span class="annot"><a href="#local-6989586621679527124"><span class="hs-identifier hs-type">c</span></a></span></span><span> </span><span id="local-6989586621679527123"><span class="annot"><a href="#local-6989586621679527123"><span class="hs-identifier hs-type">d</span></a></span></span><span>
</span><span id="line-93"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- | marks a terminal split</span><span>
</span><span id="line-94"></span><span>    </span><span id="EReg"><span class="annot"><a href="PVGrammar.Parse.html#EReg"><span class="hs-identifier hs-var">EReg</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><a href="#local-6989586621679527126"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-95"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-comment">-- | marks a non-terminal split</span><span>
</span><span id="line-96"></span><span>    </span><span id="EPass"><span class="annot"><a href="PVGrammar.Parse.html#EPass"><span class="hs-identifier hs-var">EPass</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><a href="#local-6989586621679527125"><span class="hs-identifier hs-type">b</span></a></span><span>
</span><span id="line-97"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-comment">-- | marks a right ornament</span><span>
</span><span id="line-98"></span><span>    </span><span id="ER"><span class="annot"><a href="PVGrammar.Parse.html#ER"><span class="hs-identifier hs-var">ER</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><a href="#local-6989586621679527124"><span class="hs-identifier hs-type">c</span></a></span><span>
</span><span id="line-99"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-comment">-- | marks a left ornament</span><span>
</span><span id="line-100"></span><span>    </span><span id="EL"><span class="annot"><a href="PVGrammar.Parse.html#EL"><span class="hs-identifier hs-var">EL</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="annot"><a href="#local-6989586621679527123"><span class="hs-identifier hs-type">d</span></a></span><span>
</span><span id="line-101"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679526510"><span id="local-6989586621679526516"><span class="annot"><span class="annottext">Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
forall a b c d.
(Eq a, Eq b, Eq c, Eq d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
/= :: Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
$c/= :: forall a b c d.
(Eq a, Eq b, Eq c, Eq d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
== :: Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
$c== :: forall a b c d.
(Eq a, Eq b, Eq c, Eq d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526490"><span id="local-6989586621679526492"><span id="local-6989586621679526494"><span id="local-6989586621679526496"><span id="local-6989586621679526498"><span id="local-6989586621679526500"><span id="local-6989586621679526506"><span class="annot"><span class="annottext">Elaboration a b c d -&gt; Elaboration a b c d -&gt; Ordering
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
forall {a} {b} {c} {d}.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Eq (Elaboration a b c d)
forall a b c d.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
forall a b c d.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Ordering
forall a b c d.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Elaboration a b c d
min :: Elaboration a b c d -&gt; Elaboration a b c d -&gt; Elaboration a b c d
$cmin :: forall a b c d.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Elaboration a b c d
max :: Elaboration a b c d -&gt; Elaboration a b c d -&gt; Elaboration a b c d
$cmax :: forall a b c d.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Elaboration a b c d
&gt;= :: Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
$c&gt;= :: forall a b c d.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
&gt; :: Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
$c&gt; :: forall a b c d.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
&lt;= :: Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
$c&lt;= :: forall a b c d.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
&lt; :: Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
$c&lt; :: forall a b c d.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Bool
compare :: Elaboration a b c d -&gt; Elaboration a b c d -&gt; Ordering
$ccompare :: forall a b c d.
(Ord a, Ord b, Ord c, Ord d) =&gt;
Elaboration a b c d -&gt; Elaboration a b c d -&gt; Ordering
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526476"><span id="local-6989586621679526478"><span id="local-6989586621679526488"><span class="annot"><span class="annottext">Int -&gt; Elaboration a b c d -&gt; ShowS
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
forall a b c d.
(Show a, Show b, Show c, Show d) =&gt;
Int -&gt; Elaboration a b c d -&gt; ShowS
forall a b c d.
(Show a, Show b, Show c, Show d) =&gt;
[Elaboration a b c d] -&gt; ShowS
forall a b c d.
(Show a, Show b, Show c, Show d) =&gt;
Elaboration a b c d -&gt; String
showList :: [Elaboration a b c d] -&gt; ShowS
$cshowList :: forall a b c d.
(Show a, Show b, Show c, Show d) =&gt;
[Elaboration a b c d] -&gt; ShowS
show :: Elaboration a b c d -&gt; String
$cshow :: forall a b c d.
(Show a, Show b, Show c, Show d) =&gt;
Elaboration a b c d -&gt; String
showsPrec :: Int -&gt; Elaboration a b c d -&gt; ShowS
$cshowsPrec :: forall a b c d.
(Show a, Show b, Show c, Show d) =&gt;
Int -&gt; Elaboration a b c d -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
forall a b c d x.
Rep (Elaboration a b c d) x -&gt; Elaboration a b c d
forall a b c d x.
Elaboration a b c d -&gt; Rep (Elaboration a b c d) x
$cto :: forall a b c d x.
Rep (Elaboration a b c d) x -&gt; Elaboration a b c d
$cfrom :: forall a b c d x.
Elaboration a b c d -&gt; Rep (Elaboration a b c d) x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526468"><span id="local-6989586621679526470"><span class="annot"><span class="annottext">forall a. Eq a -&gt; (Int -&gt; a -&gt; Int) -&gt; (a -&gt; Int) -&gt; Hashable a
forall {a} {b} {c} {d}.
(Hashable a, Hashable b, Hashable c, Hashable d) =&gt;
Eq (Elaboration a b c d)
forall a b c d.
(Hashable a, Hashable b, Hashable c, Hashable d) =&gt;
Int -&gt; Elaboration a b c d -&gt; Int
forall a b c d.
(Hashable a, Hashable b, Hashable c, Hashable d) =&gt;
Elaboration a b c d -&gt; Int
hash :: Elaboration a b c d -&gt; Int
$chash :: forall a b c d.
(Hashable a, Hashable b, Hashable c, Hashable d) =&gt;
Elaboration a b c d -&gt; Int
hashWithSalt :: Int -&gt; Elaboration a b c d -&gt; Int
$chashWithSalt :: forall a b c d.
(Hashable a, Hashable b, Hashable c, Hashable d) =&gt;
Int -&gt; Elaboration a b c d -&gt; Int
</span><a href="#local-6989586621679526468"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Hashable</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526466"><span class="annot"><span class="annottext">forall a. (a -&gt; ()) -&gt; NFData a
forall a b c d.
(NFData a, NFData b, NFData c, NFData d) =&gt;
Elaboration a b c d -&gt; ()
rnf :: Elaboration a b c d -&gt; ()
$crnf :: forall a b c d.
(NFData a, NFData b, NFData c, NFData d) =&gt;
Elaboration a b c d -&gt; ()
</span><a href="#local-6989586621679526466"><span class="hs-identifier hs-var hs-var hs-var hs-var">NFData</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-102"></span><span>
</span><span id="line-103"></span><span class="hs-comment">{- | Takes a collection of 'Elaboration'
 and splits it into lists for each elaboration type.
-}</span><span>
</span><span id="line-106"></span><span id="local-6989586621679527118"><span id="local-6989586621679527119"><span id="local-6989586621679527120"><span id="local-6989586621679527121"><span id="local-6989586621679527122"><span class="annot"><a href="PVGrammar.Parse.html#partitionElaborations"><span class="hs-identifier hs-type">partitionElaborations</span></a></span><span>
</span><span id="line-107"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679527122"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679527122"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Elaboration"><span class="hs-identifier hs-type">Elaboration</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527121"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527120"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527119"><span class="hs-identifier hs-type">c</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527118"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679527121"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679527120"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679527119"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679527118"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span></span></span></span></span></span><span>
</span><span id="line-108"></span><span id="partitionElaborations"><span class="annot"><span class="annottext">partitionElaborations :: forall (t :: * -&gt; *) a b c d.
Foldable t =&gt;
t (Elaboration a b c d) -&gt; ([a], [b], [c], [d])
</span><a href="PVGrammar.Parse.html#partitionElaborations"><span class="hs-identifier hs-var hs-var">partitionElaborations</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl'</span></span><span> </span><span class="annot"><span class="annottext">forall {a} {a} {a} {a}.
([a], [a], [a], [a]) -&gt; Elaboration a a a a -&gt; ([a], [a], [a], [a])
</span><a href="#local-6989586621679526462"><span class="hs-identifier hs-var">select</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-109"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-110"></span><span>  </span><span id="local-6989586621679526462"><span class="annot"><span class="annottext">select :: ([a], [a], [a], [a]) -&gt; Elaboration a a a a -&gt; ([a], [a], [a], [a])
</span><a href="#local-6989586621679526462"><span class="hs-identifier hs-var hs-var">select</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679526461"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526461"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526460"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526460"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526459"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526459"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526458"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526458"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#EReg"><span class="hs-identifier hs-type">EReg</span></a></span><span> </span><span id="local-6989586621679526457"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679526457"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679526457"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526461"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526460"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526459"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526458"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-111"></span><span>  </span><span class="annot"><a href="#local-6989586621679526462"><span class="hs-identifier hs-var">select</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679526456"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526456"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526455"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526455"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526454"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526454"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526453"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526453"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#EPass"><span class="hs-identifier hs-type">EPass</span></a></span><span> </span><span id="local-6989586621679526452"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679526452"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526456"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679526452"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526455"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526454"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526453"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-112"></span><span>  </span><span class="annot"><a href="#local-6989586621679526462"><span class="hs-identifier hs-var">select</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679526451"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526451"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526450"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526450"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526449"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526449"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526448"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526448"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#ER"><span class="hs-identifier hs-type">ER</span></a></span><span> </span><span id="local-6989586621679526447"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679526447"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526451"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526450"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679526447"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526449"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526448"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-113"></span><span>  </span><span class="annot"><a href="#local-6989586621679526462"><span class="hs-identifier hs-var">select</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679526446"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526446"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526445"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526445"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526444"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526444"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526443"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526443"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#EL"><span class="hs-identifier hs-type">EL</span></a></span><span> </span><span id="local-6989586621679526442"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679526442"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526446"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526445"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526444"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679526442"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679526443"><span class="hs-identifier hs-var">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-114"></span><span>
</span><span id="line-115"></span><span class="hs-comment">-- parsing Ornamentations</span><span>
</span><span id="line-116"></span><span class="hs-comment">-- ======================</span><span>
</span><span id="line-117"></span><span>
</span><span id="line-118"></span><span class="hs-comment">-- | A constraint alias for note types.</span><span>
</span><span id="line-119"></span><span class="hs-keyword">type</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Constraint</span></span><span>
</span><span id="line-120"></span><span class="hs-keyword">type</span><span> </span><span id="IsNote"><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-var">IsNote</span></a></span></span><span> </span><span id="local-6989586621679526441"><span class="annot"><a href="#local-6989586621679526441"><span class="hs-identifier hs-type">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-121"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">HasPitch</span></span><span> </span><span class="annot"><a href="#local-6989586621679526441"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Diatonic</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ICOf</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">IntervalOf</span></span><span> </span><span class="annot"><a href="#local-6989586621679526441"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ICOf</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">IntervalOf</span></span><span> </span><span class="annot"><a href="#local-6989586621679526441"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-122"></span><span>
</span><span id="line-123"></span><span class="hs-comment">-- | Checks if the middle pitch is between the left and the right pitch.</span><span>
</span><span id="line-124"></span><span id="local-6989586621679527108"><span class="annot"><a href="PVGrammar.Parse.html#between"><span class="hs-identifier hs-type">between</span></a></span><span>
</span><span id="line-125"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679527108"><span class="hs-identifier hs-type">i</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Interval</span></span><span> </span><span class="annot"><a href="#local-6989586621679527108"><span class="hs-identifier hs-type">i</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-126"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pitch</span></span><span> </span><span class="annot"><a href="#local-6989586621679527108"><span class="hs-identifier hs-type">i</span></a></span><span>
</span><span id="line-127"></span><span>  </span><span class="hs-comment">-- ^ left pitch</span><span>
</span><span id="line-128"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pitch</span></span><span> </span><span class="annot"><a href="#local-6989586621679527108"><span class="hs-identifier hs-type">i</span></a></span><span>
</span><span id="line-129"></span><span>  </span><span class="hs-comment">-- ^ middle pitch</span><span>
</span><span id="line-130"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pitch</span></span><span> </span><span class="annot"><a href="#local-6989586621679527108"><span class="hs-identifier hs-type">i</span></a></span><span>
</span><span id="line-131"></span><span>  </span><span class="hs-comment">-- ^ right pitch</span><span>
</span><span id="line-132"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-133"></span><span id="between"><span class="annot"><span class="annottext">between :: forall i.
(Eq i, Interval i) =&gt;
Pitch i -&gt; Pitch i -&gt; Pitch i -&gt; Bool
</span><a href="PVGrammar.Parse.html#between"><span class="hs-identifier hs-var hs-var">between</span></a></span></span><span> </span><span id="local-6989586621679526420"><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679526420"><span class="hs-identifier hs-var">pl</span></a></span></span><span> </span><span id="local-6989586621679526419"><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679526419"><span class="hs-identifier hs-var">pm</span></a></span></span><span> </span><span id="local-6989586621679526418"><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679526418"><span class="hs-identifier hs-var">pr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-134"></span><span>  </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679526420"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679526419"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679526419"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679526418"><span class="hs-identifier hs-var">pr</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679526420"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679526418"><span class="hs-identifier hs-var">pr</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><a href="#local-6989586621679526415"><span class="hs-identifier hs-var">dir1</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><a href="#local-6989586621679526414"><span class="hs-identifier hs-var">odir</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><a href="#local-6989586621679526413"><span class="hs-identifier hs-var">dir2</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Ordering
</span><a href="#local-6989586621679526414"><span class="hs-identifier hs-var">odir</span></a></span><span>
</span><span id="line-135"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-136"></span><span>  </span><span id="local-6989586621679526414"><span class="annot"><span class="annottext">odir :: Ordering
</span><a href="#local-6989586621679526414"><span class="hs-identifier hs-var hs-var">odir</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall i. Interval i =&gt; i -&gt; Ordering
</span><span class="hs-identifier hs-var">direction</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679526420"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall {v}. AdditiveGroup v =&gt; Pitch v -&gt; Pitch v -&gt; v
</span><span class="hs-operator hs-var">`pto`</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679526418"><span class="hs-identifier hs-var">pr</span></a></span><span>
</span><span id="line-137"></span><span>  </span><span id="local-6989586621679526415"><span class="annot"><span class="annottext">dir1 :: Ordering
</span><a href="#local-6989586621679526415"><span class="hs-identifier hs-var hs-var">dir1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall i. Interval i =&gt; i -&gt; Ordering
</span><span class="hs-identifier hs-var">direction</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679526420"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall {v}. AdditiveGroup v =&gt; Pitch v -&gt; Pitch v -&gt; v
</span><span class="hs-operator hs-var">`pto`</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679526419"><span class="hs-identifier hs-var">pm</span></a></span><span>
</span><span id="line-138"></span><span>  </span><span id="local-6989586621679526413"><span class="annot"><span class="annottext">dir2 :: Ordering
</span><a href="#local-6989586621679526413"><span class="hs-identifier hs-var hs-var">dir2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall i. Interval i =&gt; i -&gt; Ordering
</span><span class="hs-identifier hs-var">direction</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679526419"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">forall {v}. AdditiveGroup v =&gt; Pitch v -&gt; Pitch v -&gt; v
</span><span class="hs-operator hs-var">`pto`</span></span><span> </span><span class="annot"><span class="annottext">Pitch i
</span><a href="#local-6989586621679526418"><span class="hs-identifier hs-var">pr</span></a></span><span>
</span><span id="line-139"></span><span>
</span><span id="line-140"></span><span class="hs-comment">{- | Attempts to reduce three nodes using an ornamentation operation.
 If succesfull, returns the ornament type and the parent edge,
 which is either a non-terminal edge for passing notes,
 or a terminal edge for all other operations.
-}</span><span>
</span><span id="line-145"></span><span id="local-6989586621679527095"><span class="annot"><a href="PVGrammar.Parse.html#findOrnament"><span class="hs-identifier hs-type">findOrnament</span></a></span><span>
</span><span id="line-146"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527095"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-147"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#StartStop"><span class="hs-identifier hs-type">StartStop</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527095"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-148"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Common.html#StartStop"><span class="hs-identifier hs-type">StartStop</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527095"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-149"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Common.html#StartStop"><span class="hs-identifier hs-type">StartStop</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527095"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-150"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-151"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-152"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span>
</span><span id="line-153"></span><span>      </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#EdgeEither"><span class="hs-identifier hs-type">EdgeEither</span></a></span><span>
</span><span id="line-154"></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#DoubleOrnament"><span class="hs-identifier hs-type">DoubleOrnament</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527095"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-155"></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#PassingOrnament"><span class="hs-identifier hs-type">PassingOrnament</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#InnerEdge"><span class="hs-identifier hs-type">InnerEdge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527095"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-156"></span><span>      </span><span class="hs-special">)</span></span><span>
</span><span id="line-157"></span><span id="findOrnament"><span class="annot"><span class="annottext">findOrnament :: forall n.
IsNote n =&gt;
StartStop n
-&gt; StartStop n
-&gt; StartStop n
-&gt; Bool
-&gt; Bool
-&gt; Maybe
     (EdgeEither
        (DoubleOrnament, Edge n) (PassingOrnament, InnerEdge n))
</span><a href="PVGrammar.Parse.html#findOrnament"><span class="hs-identifier hs-var hs-var">findOrnament</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679526372"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526372"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679526371"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526371"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679526370"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526370"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-158"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526369"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526368"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526368"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526367"><span class="hs-identifier hs-var">pr</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DoubleOrnament
</span><a href="PVGrammar.html#FullRepeat"><span class="hs-identifier hs-var">FullRepeat</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526372"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526370"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-159"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526369"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526368"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679526365"><span class="hs-identifier hs-var">so</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DoubleOrnament
</span><a href="PVGrammar.html#RightRepeatOfLeft"><span class="hs-identifier hs-var">RightRepeatOfLeft</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526372"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526370"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-160"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526368"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526367"><span class="hs-identifier hs-var">pr</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679526365"><span class="hs-identifier hs-var">so</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DoubleOrnament
</span><a href="PVGrammar.html#LeftRepeatOfRight"><span class="hs-identifier hs-var">LeftRepeatOfRight</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526372"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526370"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-161"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-162"></span><span>  </span><span id="local-6989586621679526369"><span class="annot"><span class="annottext">pl :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526369"><span class="hs-identifier hs-var hs-var">pl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526372"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-163"></span><span>  </span><span id="local-6989586621679526368"><span class="annot"><span class="annottext">pm :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526368"><span class="hs-identifier hs-var hs-var">pm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526371"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-164"></span><span>  </span><span id="local-6989586621679526367"><span class="annot"><span class="annottext">pr :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526367"><span class="hs-identifier hs-var hs-var">pr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526370"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-165"></span><span>  </span><span id="local-6989586621679526365"><span class="annot"><span class="annottext">so :: Bool
</span><a href="#local-6989586621679526365"><span class="hs-identifier hs-var hs-var">so</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall i. Diatonic i =&gt; i -&gt; Bool
</span><span class="hs-identifier hs-var">isStep</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526369"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall {v}. AdditiveGroup v =&gt; Pitch v -&gt; Pitch v -&gt; v
</span><span class="hs-operator hs-var">`pto`</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526367"><span class="hs-identifier hs-var">pr</span></a></span><span>
</span><span id="line-166"></span><span class="annot"><a href="PVGrammar.Parse.html#findOrnament"><span class="hs-identifier hs-var">findOrnament</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679526361"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526361"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679526360"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526360"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679526359"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526359"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span>
</span><span id="line-167"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526358"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526357"><span class="hs-identifier hs-var">pr</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679526356"><span class="hs-identifier hs-var">s1</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DoubleOrnament
</span><a href="PVGrammar.html#FullNeighbor"><span class="hs-identifier hs-var">FullNeighbor</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526361"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526359"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-168"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679526356"><span class="hs-identifier hs-var">s1</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679526354"><span class="hs-identifier hs-var">s2</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">forall i.
(Eq i, Interval i) =&gt;
Pitch i -&gt; Pitch i -&gt; Pitch i -&gt; Bool
</span><a href="PVGrammar.Parse.html#between"><span class="hs-identifier hs-var">between</span></a></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526358"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526353"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526357"><span class="hs-identifier hs-var">pr</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b. b -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-var">Pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="PVGrammar.html#PassingMid"><span class="hs-identifier hs-var">PassingMid</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526361"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526359"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-169"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-170"></span><span>  </span><span id="local-6989586621679526358"><span class="annot"><span class="annottext">pl :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526358"><span class="hs-identifier hs-var hs-var">pl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526361"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-171"></span><span>  </span><span id="local-6989586621679526353"><span class="annot"><span class="annottext">pm :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526353"><span class="hs-identifier hs-var hs-var">pm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526360"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-172"></span><span>  </span><span id="local-6989586621679526357"><span class="annot"><span class="annottext">pr :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526357"><span class="hs-identifier hs-var hs-var">pr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526359"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-173"></span><span>  </span><span id="local-6989586621679526356"><span class="annot"><span class="annottext">s1 :: Bool
</span><a href="#local-6989586621679526356"><span class="hs-identifier hs-var hs-var">s1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall i. Diatonic i =&gt; i -&gt; Bool
</span><span class="hs-identifier hs-var">isStep</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526358"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall {v}. AdditiveGroup v =&gt; Pitch v -&gt; Pitch v -&gt; v
</span><span class="hs-operator hs-var">`pto`</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526353"><span class="hs-identifier hs-var">pm</span></a></span><span>
</span><span id="line-174"></span><span>  </span><span id="local-6989586621679526354"><span class="annot"><span class="annottext">s2 :: Bool
</span><a href="#local-6989586621679526354"><span class="hs-identifier hs-var hs-var">s2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall i. Diatonic i =&gt; i -&gt; Bool
</span><span class="hs-identifier hs-var">isStep</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526353"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">forall {v}. AdditiveGroup v =&gt; Pitch v -&gt; Pitch v -&gt; v
</span><span class="hs-operator hs-var">`pto`</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526357"><span class="hs-identifier hs-var">pr</span></a></span><span>
</span><span id="line-175"></span><span class="annot"><a href="PVGrammar.Parse.html#findOrnament"><span class="hs-identifier hs-var">findOrnament</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><a href="Common.html#Start"><span class="hs-identifier hs-var">Start</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><a href="Common.html#Stop"><span class="hs-identifier hs-var">Stop</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DoubleOrnament
</span><a href="PVGrammar.html#RootNote"><span class="hs-identifier hs-var">RootNote</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. StartStop a
</span><a href="Common.html#Start"><span class="hs-identifier hs-var">Start</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. StartStop a
</span><a href="Common.html#Stop"><span class="hs-identifier hs-var">Stop</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-176"></span><span class="annot"><a href="PVGrammar.Parse.html#findOrnament"><span class="hs-identifier hs-var">findOrnament</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-177"></span><span>
</span><span id="line-178"></span><span class="hs-comment">{- | Attempts to reduce three notes as a passing motion
 where one of the child edges is a non-terminal edge.

 Since one of the edges is a terminal edge,
 the corresponding outer note could be start/stop symbol, in which case the reduction fails.
 The side with the terminal edge is thus a @StartStop Pitch i@ within a 'Reg',
 while the non-terminal side is a @Pitch i@ within an 'Pass'.
 Exactly one side must be a 'Reg' and the other an 'Pass', otherwise the reduction fails.
-}</span><span>
</span><span id="line-187"></span><span id="local-6989586621679527075"><span class="annot"><a href="PVGrammar.Parse.html#findPassing"><span class="hs-identifier hs-type">findPassing</span></a></span><span>
</span><span id="line-188"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527075"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-189"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#EdgeEither"><span class="hs-identifier hs-type">EdgeEither</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#StartStop"><span class="hs-identifier hs-type">StartStop</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527075"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679527075"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-190"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679527075"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-191"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#EdgeEither"><span class="hs-identifier hs-type">EdgeEither</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#StartStop"><span class="hs-identifier hs-type">StartStop</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527075"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679527075"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-192"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#InnerEdge"><span class="hs-identifier hs-type">InnerEdge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527075"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#PassingOrnament"><span class="hs-identifier hs-type">PassingOrnament</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-193"></span><span id="findPassing"><span class="annot"><span class="annottext">findPassing :: forall n.
IsNote n =&gt;
EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe (InnerEdge n, PassingOrnament)
</span><a href="PVGrammar.Parse.html#findPassing"><span class="hs-identifier hs-var hs-var">findPassing</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679526318"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526318"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span id="local-6989586621679526317"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526317"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-type">Pass</span></a></span><span> </span><span id="local-6989586621679526316"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526316"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-194"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">forall i. Diatonic i =&gt; i -&gt; Bool
</span><span class="hs-identifier hs-var">isStep</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526315"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall {v}. AdditiveGroup v =&gt; Pitch v -&gt; Pitch v -&gt; v
</span><span class="hs-operator hs-var">`pto`</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526314"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">forall i.
(Eq i, Interval i) =&gt;
Pitch i -&gt; Pitch i -&gt; Pitch i -&gt; Bool
</span><a href="PVGrammar.Parse.html#between"><span class="hs-identifier hs-var">between</span></a></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526315"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526314"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526313"><span class="hs-identifier hs-var">pr</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-195"></span><span>      </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526318"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526316"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="PVGrammar.html#PassingLeft"><span class="hs-identifier hs-var">PassingLeft</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-196"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-197"></span><span>  </span><span id="local-6989586621679526315"><span class="annot"><span class="annottext">pl :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526315"><span class="hs-identifier hs-var hs-var">pl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526318"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-198"></span><span>  </span><span id="local-6989586621679526314"><span class="annot"><span class="annottext">pm :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526314"><span class="hs-identifier hs-var hs-var">pm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526317"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-199"></span><span>  </span><span id="local-6989586621679526313"><span class="annot"><span class="annottext">pr :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526313"><span class="hs-identifier hs-var hs-var">pr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526316"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-200"></span><span class="annot"><a href="PVGrammar.Parse.html#findPassing"><span class="hs-identifier hs-var">findPassing</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-type">Pass</span></a></span><span> </span><span id="local-6989586621679526311"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526311"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679526310"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526310"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679526309"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526309"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-201"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">forall i. Diatonic i =&gt; i -&gt; Bool
</span><span class="hs-identifier hs-var">isStep</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526308"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">forall {v}. AdditiveGroup v =&gt; Pitch v -&gt; Pitch v -&gt; v
</span><span class="hs-operator hs-var">`pto`</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526307"><span class="hs-identifier hs-var">pr</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">forall i.
(Eq i, Interval i) =&gt;
Pitch i -&gt; Pitch i -&gt; Pitch i -&gt; Bool
</span><a href="PVGrammar.Parse.html#between"><span class="hs-identifier hs-var">between</span></a></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526306"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526308"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526307"><span class="hs-identifier hs-var">pr</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-202"></span><span>      </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526311"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526309"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="PVGrammar.html#PassingRight"><span class="hs-identifier hs-var">PassingRight</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-203"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-204"></span><span>  </span><span id="local-6989586621679526306"><span class="annot"><span class="annottext">pl :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526306"><span class="hs-identifier hs-var hs-var">pl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526311"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-205"></span><span>  </span><span id="local-6989586621679526308"><span class="annot"><span class="annottext">pm :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526308"><span class="hs-identifier hs-var hs-var">pm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526310"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-206"></span><span>  </span><span id="local-6989586621679526307"><span class="annot"><span class="annottext">pr :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526307"><span class="hs-identifier hs-var hs-var">pr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526309"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-207"></span><span class="annot"><a href="PVGrammar.Parse.html#findPassing"><span class="hs-identifier hs-var">findPassing</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-208"></span><span>
</span><span id="line-209"></span><span id="local-6989586621679527073"><span class="annot"><a href="PVGrammar.Parse.html#findRightOrnament"><span class="hs-identifier hs-type">findRightOrnament</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527073"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679527073"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679527073"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="PVGrammar.html#RightOrnament"><span class="hs-identifier hs-type">RightOrnament</span></a></span></span><span>
</span><span id="line-210"></span><span id="findRightOrnament"><span class="annot"><span class="annottext">findRightOrnament :: forall n. IsNote n =&gt; n -&gt; n -&gt; Maybe RightOrnament
</span><a href="PVGrammar.Parse.html#findRightOrnament"><span class="hs-identifier hs-var hs-var">findRightOrnament</span></a></span></span><span> </span><span id="local-6989586621679526287"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526287"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679526286"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526286"><span class="hs-identifier hs-var">m</span></a></span></span><span>
</span><span id="line-211"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526285"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526284"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">RightOrnament
</span><a href="PVGrammar.html#RightRepeat"><span class="hs-identifier hs-var">RightRepeat</span></a></span><span>
</span><span id="line-212"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">forall i. Diatonic i =&gt; i -&gt; Bool
</span><span class="hs-identifier hs-var">isStep</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526285"><span class="hs-identifier hs-var">pl</span></a></span><span> </span><span class="annot"><span class="annottext">forall {v}. AdditiveGroup v =&gt; Pitch v -&gt; Pitch v -&gt; v
</span><span class="hs-operator hs-var">`pto`</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526284"><span class="hs-identifier hs-var">pm</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">RightOrnament
</span><a href="PVGrammar.html#RightNeighbor"><span class="hs-identifier hs-var">RightNeighbor</span></a></span><span>
</span><span id="line-213"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-214"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-215"></span><span>  </span><span id="local-6989586621679526285"><span class="annot"><span class="annottext">pl :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526285"><span class="hs-identifier hs-var hs-var">pl</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526287"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-216"></span><span>  </span><span id="local-6989586621679526284"><span class="annot"><span class="annottext">pm :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526284"><span class="hs-identifier hs-var hs-var">pm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526286"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-217"></span><span>
</span><span id="line-218"></span><span id="local-6989586621679527070"><span class="annot"><a href="PVGrammar.Parse.html#findLeftOrnament"><span class="hs-identifier hs-type">findLeftOrnament</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527070"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679527070"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679527070"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="PVGrammar.html#LeftOrnament"><span class="hs-identifier hs-type">LeftOrnament</span></a></span></span><span>
</span><span id="line-219"></span><span id="findLeftOrnament"><span class="annot"><span class="annottext">findLeftOrnament :: forall n. IsNote n =&gt; n -&gt; n -&gt; Maybe LeftOrnament
</span><a href="PVGrammar.Parse.html#findLeftOrnament"><span class="hs-identifier hs-var hs-var">findLeftOrnament</span></a></span></span><span> </span><span id="local-6989586621679526264"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526264"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679526263"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526263"><span class="hs-identifier hs-var">r</span></a></span></span><span>
</span><span id="line-220"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526262"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526261"><span class="hs-identifier hs-var">pr</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">LeftOrnament
</span><a href="PVGrammar.html#LeftRepeat"><span class="hs-identifier hs-var">LeftRepeat</span></a></span><span>
</span><span id="line-221"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">forall i. Diatonic i =&gt; i -&gt; Bool
</span><span class="hs-identifier hs-var">isStep</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526262"><span class="hs-identifier hs-var">pm</span></a></span><span> </span><span class="annot"><span class="annottext">forall {v}. AdditiveGroup v =&gt; Pitch v -&gt; Pitch v -&gt; v
</span><span class="hs-operator hs-var">`pto`</span></span><span> </span><span class="annot"><span class="annottext">Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526261"><span class="hs-identifier hs-var">pr</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">LeftOrnament
</span><a href="PVGrammar.html#LeftNeighbor"><span class="hs-identifier hs-var">LeftNeighbor</span></a></span><span>
</span><span id="line-222"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-223"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-224"></span><span>  </span><span id="local-6989586621679526262"><span class="annot"><span class="annottext">pm :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526262"><span class="hs-identifier hs-var hs-var">pm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526264"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-225"></span><span>  </span><span id="local-6989586621679526261"><span class="annot"><span class="annottext">pr :: Pitch (ICOf (IntervalOf n))
</span><a href="#local-6989586621679526261"><span class="hs-identifier hs-var hs-var">pr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526263"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-226"></span><span>
</span><span id="line-227"></span><span class="hs-comment">-- evaluator interface</span><span>
</span><span id="line-228"></span><span class="hs-comment">-- ===================</span><span>
</span><span id="line-229"></span><span>
</span><span id="line-230"></span><span class="hs-comment">{- | The evaluator that represents the proto-voice grammar.
 As scores it returns a representation of each operation.
 These scores do not form a semiring,
 but can be embedded into different semirings using 'mapEvalScore'.
-}</span><span>
</span><span id="line-235"></span><span id="local-6989586621679527065"><span id="local-6989586621679527066"><span id="local-6989586621679527067"><span class="annot"><a href="PVGrammar.Parse.html#protoVoiceEvaluator"><span class="hs-identifier hs-type">protoVoiceEvaluator</span></a></span><span>
</span><span id="line-236"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679527067"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679527066"><span class="hs-identifier hs-type">t2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679527065"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679527065"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527065"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679527065"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679527065"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-237"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527065"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679527067"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527065"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527065"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679527066"><span class="hs-identifier hs-type">t2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527065"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#PVLeftmost"><span class="hs-identifier hs-type">PVLeftmost</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527065"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-238"></span><span id="protoVoiceEvaluator"><span class="annot"><span class="annottext">protoVoiceEvaluator :: forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
</span><a href="PVGrammar.Parse.html#protoVoiceEvaluator"><span class="hs-identifier hs-var hs-var">protoVoiceEvaluator</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-239"></span><span>  </span><span class="annot"><span class="annottext">forall tr slc h s tr' f slc'.
UnspreadMiddle tr slc h
-&gt; UnspreadLeft tr slc
-&gt; UnspreadRight tr slc
-&gt; (StartStop slc -&gt; tr -&gt; slc -&gt; tr -&gt; StartStop slc -&gt; [(tr, s)])
-&gt; (StartStop slc -&gt; Maybe tr' -&gt; StartStop slc -&gt; [(tr, f)])
-&gt; (slc' -&gt; slc)
-&gt; Eval tr tr' slc slc' (Leftmost s f h)
</span><a href="Common.html#mkLeftmostEval"><span class="hs-identifier hs-var">mkLeftmostEval</span></a></span><span>
</span><span id="line-240"></span><span>    </span><span class="annot"><span class="annottext">forall n.
(Eq n, Ord n, Hashable n, IsNote n) =&gt;
UnspreadMiddle (Edges n) (Notes n) (Spread n)
</span><a href="PVGrammar.Parse.html#pvUnspreadMiddle"><span class="hs-identifier hs-var">pvUnspreadMiddle</span></a></span><span>
</span><span id="line-241"></span><span>    </span><span class="annot"><span class="annottext">forall n. UnspreadLeft (Edges n) (Notes n)
</span><a href="PVGrammar.Parse.html#pvUnspreadLeft"><span class="hs-identifier hs-var">pvUnspreadLeft</span></a></span><span>
</span><span id="line-242"></span><span>    </span><span class="annot"><span class="annottext">forall n. UnspreadRight (Edges n) (Notes n)
</span><a href="PVGrammar.Parse.html#pvUnspreadRight"><span class="hs-identifier hs-var">pvUnspreadRight</span></a></span><span>
</span><span id="line-243"></span><span>    </span><span class="annot"><span class="annottext">forall n.
(IsNote n, Notation n, Ord n, Hashable n) =&gt;
StartStop (Notes n)
-&gt; Edges n
-&gt; Notes n
-&gt; Edges n
-&gt; StartStop (Notes n)
-&gt; [(Edges n, Split n)]
</span><a href="PVGrammar.Parse.html#pvUnsplit"><span class="hs-identifier hs-var">pvUnsplit</span></a></span><span>
</span><span id="line-244"></span><span>    </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) n.
(Foldable t, Ord n, Hashable n) =&gt;
StartStop (Notes n)
-&gt; Maybe (t (Edge n)) -&gt; StartStop (Notes n) -&gt; [(Edges n, Freeze)]
</span><a href="PVGrammar.Parse.html#pvThaw"><span class="hs-identifier hs-var">pvThaw</span></a></span><span>
</span><span id="line-245"></span><span>    </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) n.
(Foldable t, Eq n, Hashable n) =&gt;
t n -&gt; Notes n
</span><a href="PVGrammar.Parse.html#pvSlice"><span class="hs-identifier hs-var">pvSlice</span></a></span><span>
</span><span id="line-246"></span><span>
</span><span id="line-247"></span><span id="local-6989586621679527032"><span id="local-6989586621679527033"><span id="local-6989586621679527034"><span class="annot"><a href="PVGrammar.Parse.html#protoVoiceEvaluatorImpure"><span class="hs-identifier hs-type">protoVoiceEvaluatorImpure</span></a></span><span>
</span><span id="line-248"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679527034"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679527033"><span class="hs-identifier hs-type">t2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679527032"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679527032"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527032"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679527032"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679527032"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-249"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#EvalImpure"><span class="hs-identifier hs-type">EvalImpure</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527032"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679527034"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527032"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527032"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679527033"><span class="hs-identifier hs-type">t2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527032"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#PVLeftmost"><span class="hs-identifier hs-type">PVLeftmost</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527032"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-250"></span><span id="protoVoiceEvaluatorImpure"><span class="annot"><span class="annottext">protoVoiceEvaluatorImpure :: forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
EvalImpure (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
</span><a href="PVGrammar.Parse.html#protoVoiceEvaluatorImpure"><span class="hs-identifier hs-var hs-var">protoVoiceEvaluatorImpure</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-251"></span><span>  </span><span class="annot"><span class="annottext">forall tr slc h s tr' f slc'.
UnspreadMiddle tr slc h
-&gt; UnspreadLeft tr slc
-&gt; UnspreadRight tr slc
-&gt; (StartStop slc -&gt; tr -&gt; slc -&gt; tr -&gt; StartStop slc -&gt; [(tr, s)])
-&gt; (StartStop slc
    -&gt; tr -&gt; slc -&gt; tr -&gt; StartStop slc -&gt; IO [(tr, s)])
-&gt; (StartStop slc -&gt; Maybe tr' -&gt; StartStop slc -&gt; [(tr, f)])
-&gt; (slc' -&gt; slc)
-&gt; EvalImpure tr tr' slc slc' (Leftmost s f h)
</span><a href="Common.html#mkLeftmostEvalImpure"><span class="hs-identifier hs-var">mkLeftmostEvalImpure</span></a></span><span>
</span><span id="line-252"></span><span>    </span><span class="annot"><span class="annottext">forall n.
(Eq n, Ord n, Hashable n, IsNote n) =&gt;
UnspreadMiddle (Edges n) (Notes n) (Spread n)
</span><a href="PVGrammar.Parse.html#pvUnspreadMiddle"><span class="hs-identifier hs-var">pvUnspreadMiddle</span></a></span><span>
</span><span id="line-253"></span><span>    </span><span class="annot"><span class="annottext">forall n. UnspreadLeft (Edges n) (Notes n)
</span><a href="PVGrammar.Parse.html#pvUnspreadLeft"><span class="hs-identifier hs-var">pvUnspreadLeft</span></a></span><span>
</span><span id="line-254"></span><span>    </span><span class="annot"><span class="annottext">forall n. UnspreadRight (Edges n) (Notes n)
</span><a href="PVGrammar.Parse.html#pvUnspreadRight"><span class="hs-identifier hs-var">pvUnspreadRight</span></a></span><span>
</span><span id="line-255"></span><span>    </span><span class="annot"><span class="annottext">forall n.
(IsNote n, Notation n, Ord n, Hashable n) =&gt;
StartStop (Notes n)
-&gt; Edges n
-&gt; Notes n
-&gt; Edges n
-&gt; StartStop (Notes n)
-&gt; [(Edges n, Split n)]
</span><a href="PVGrammar.Parse.html#pvUnsplit"><span class="hs-identifier hs-var">pvUnsplit</span></a></span><span>
</span><span id="line-256"></span><span>    </span><span class="annot"><span class="annottext">forall n.
(IsNote n, Notation n, Ord n, Hashable n) =&gt;
StartStop (Notes n)
-&gt; Edges n
-&gt; Notes n
-&gt; Edges n
-&gt; StartStop (Notes n)
-&gt; IO [(Edges n, Split n)]
</span><a href="PVGrammar.Parse.html#pvUnsplit%27"><span class="hs-identifier hs-var">pvUnsplit'</span></a></span><span>
</span><span id="line-257"></span><span>    </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) n.
(Foldable t, Ord n, Hashable n) =&gt;
StartStop (Notes n)
-&gt; Maybe (t (Edge n)) -&gt; StartStop (Notes n) -&gt; [(Edges n, Freeze)]
</span><a href="PVGrammar.Parse.html#pvThaw"><span class="hs-identifier hs-var">pvThaw</span></a></span><span>
</span><span id="line-258"></span><span>    </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) n.
(Foldable t, Eq n, Hashable n) =&gt;
t n -&gt; Notes n
</span><a href="PVGrammar.Parse.html#pvSlice"><span class="hs-identifier hs-var">pvSlice</span></a></span><span>
</span><span id="line-259"></span><span class="hs-comment">{- | Computes the verticalization (unspread) of a middle transition.
 If the verticalization is admitted, returns the corresponding operation.
-}</span><span>
</span><span id="line-262"></span><span id="local-6989586621679527045"><span class="annot"><a href="PVGrammar.Parse.html#pvUnspreadMiddle"><span class="hs-identifier hs-type">pvUnspreadMiddle</span></a></span><span>
</span><span id="line-263"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679527045"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679527045"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679527045"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527045"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-264"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#UnspreadMiddle"><span class="hs-identifier hs-type">UnspreadMiddle</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527045"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527045"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Spread"><span class="hs-identifier hs-type">Spread</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527045"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-265"></span><span id="pvUnspreadMiddle"><span class="annot"><span class="annottext">pvUnspreadMiddle :: forall n.
(Eq n, Ord n, Hashable n, IsNote n) =&gt;
UnspreadMiddle (Edges n) (Notes n) (Spread n)
</span><a href="PVGrammar.Parse.html#pvUnspreadMiddle"><span class="hs-identifier hs-var hs-var">pvUnspreadMiddle</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span id="local-6989586621679526159"><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679526159"><span class="hs-identifier hs-var">nl</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526158"><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679526158"><span class="hs-identifier hs-var">edges</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span id="local-6989586621679526157"><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679526157"><span class="hs-identifier hs-var">nr</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-266"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">any</span></span><span> </span><span class="annot"><span class="annottext">forall {a} {a} {f :: * -&gt; *}.
(ICOf (IntervalOf a) ~ ICOf (IntervalOf a),
 Eq (f (Pitch (ICOf (IntervalOf a)))), Functor f, HasPitch a,
 HasPitch a) =&gt;
(f a, f a) -&gt; Bool
</span><a href="#local-6989586621679526155"><span class="hs-identifier hs-var">notARepetition</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall n. Edges n -&gt; HashSet (Edge n)
</span><a href="PVGrammar.html#edgesReg"><span class="hs-identifier hs-var">edgesReg</span></a></span><span> </span><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679526158"><span class="hs-identifier hs-var">edges</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-267"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall n. MultiSet n -&gt; Notes n
</span><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-var">Notes</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679526153"><span class="hs-identifier hs-var">top</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Spread n
</span><a href="#local-6989586621679526152"><span class="hs-identifier hs-var">op</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-268"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-269"></span><span>  </span><span id="local-6989586621679526155"><span class="annot"><span class="annottext">notARepetition :: (f a, f a) -&gt; Bool
</span><a href="#local-6989586621679526155"><span class="hs-identifier hs-var hs-var">notARepetition</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679526134"><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679526134"><span class="hs-identifier hs-var">p1</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526133"><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679526133"><span class="hs-identifier hs-var">p2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679526134"><span class="hs-identifier hs-var">p1</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p. Interval p =&gt; Pitch p -&gt; Pitch (ICOf p)
</span><span class="hs-identifier hs-var">pc</span></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a. HasPitch a =&gt; a -&gt; Pitch (IntervalOf a)
</span><span class="hs-identifier hs-var">pitch</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">f a
</span><a href="#local-6989586621679526133"><span class="hs-identifier hs-var">p2</span></a></span><span>
</span><span id="line-270"></span><span>  </span><span id="local-6989586621679526153"><span class="annot"><span class="annottext">top :: MultiSet n
</span><a href="#local-6989586621679526153"><span class="hs-identifier hs-var hs-var">top</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a.
(Eq a, Hashable a) =&gt;
MultiSet a -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#maxUnion"><span class="hs-identifier hs-var">MS.maxUnion</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679526159"><span class="hs-identifier hs-var">nl</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679526157"><span class="hs-identifier hs-var">nr</span></a></span><span>
</span><span id="line-271"></span><span>  </span><span id="local-6989586621679526130"><span class="annot"><span class="annottext">leftMS :: MultiSet n
</span><a href="#local-6989586621679526130"><span class="hs-identifier hs-var hs-var">leftMS</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679526159"><span class="hs-identifier hs-var">nl</span></a></span><span> </span><span class="annot"><span class="annottext">forall a.
(Eq a, Hashable a) =&gt;
MultiSet a -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#%5C%5C"><span class="hs-operator hs-var">MS.\\</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679526157"><span class="hs-identifier hs-var">nr</span></a></span><span>
</span><span id="line-272"></span><span>  </span><span id="local-6989586621679526128"><span class="annot"><span class="annottext">left :: HashMap n SpreadDirection
</span><a href="#local-6989586621679526128"><span class="hs-identifier hs-var hs-var">left</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall k v. (Eq k, Hashable k) =&gt; [(k, v)] -&gt; HashMap k v
</span><span class="hs-identifier hs-var">HM.fromList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; SpreadDirection
</span><a href="PVGrammar.html#ToLeft"><span class="hs-identifier hs-var">ToLeft</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall k. MultiSet k -&gt; [(k, Int)]
</span><a href="Internal.MultiSet.html#toOccurList"><span class="hs-identifier hs-var">MS.toOccurList</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679526130"><span class="hs-identifier hs-var">leftMS</span></a></span><span>
</span><span id="line-273"></span><span>  </span><span id="local-6989586621679526123"><span class="annot"><span class="annottext">rightMS :: MultiSet n
</span><a href="#local-6989586621679526123"><span class="hs-identifier hs-var hs-var">rightMS</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679526157"><span class="hs-identifier hs-var">nr</span></a></span><span> </span><span class="annot"><span class="annottext">forall a.
(Eq a, Hashable a) =&gt;
MultiSet a -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#%5C%5C"><span class="hs-operator hs-var">MS.\\</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679526159"><span class="hs-identifier hs-var">nl</span></a></span><span>
</span><span id="line-274"></span><span>  </span><span id="local-6989586621679526122"><span class="annot"><span class="annottext">right :: HashMap n SpreadDirection
</span><a href="#local-6989586621679526122"><span class="hs-identifier hs-var hs-var">right</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall k v. (Eq k, Hashable k) =&gt; [(k, v)] -&gt; HashMap k v
</span><span class="hs-identifier hs-var">HM.fromList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; SpreadDirection
</span><a href="PVGrammar.html#ToRight"><span class="hs-identifier hs-var">ToRight</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall k. MultiSet k -&gt; [(k, Int)]
</span><a href="Internal.MultiSet.html#toOccurList"><span class="hs-identifier hs-var">MS.toOccurList</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679526123"><span class="hs-identifier hs-var">rightMS</span></a></span><span>
</span><span id="line-275"></span><span>  </span><span id="local-6989586621679526120"><span class="annot"><span class="annottext">bothSet :: HashSet n
</span><a href="#local-6989586621679526120"><span class="hs-identifier hs-var hs-var">bothSet</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-276"></span><span>    </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; HashSet a -&gt; HashSet a -&gt; HashSet a
</span><span class="hs-identifier hs-var">S.intersection</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k. MultiSet k -&gt; HashSet k
</span><a href="Internal.MultiSet.html#toSet"><span class="hs-identifier hs-var">MS.toSet</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679526159"><span class="hs-identifier hs-var">nl</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k. MultiSet k -&gt; HashSet k
</span><a href="Internal.MultiSet.html#toSet"><span class="hs-identifier hs-var">MS.toSet</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679526157"><span class="hs-identifier hs-var">nr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-277"></span><span>      </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; HashSet a -&gt; HashSet a -&gt; HashSet a
</span><span class="hs-operator hs-var">`S.difference`</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k. MultiSet k -&gt; HashSet k
</span><a href="Internal.MultiSet.html#toSet"><span class="hs-identifier hs-var">MS.toSet</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679526130"><span class="hs-identifier hs-var">leftMS</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; HashSet a -&gt; HashSet a -&gt; HashSet a
</span><span class="hs-operator hs-var">`S.union`</span></span><span> </span><span class="annot"><span class="annottext">forall k. MultiSet k -&gt; HashSet k
</span><a href="Internal.MultiSet.html#toSet"><span class="hs-identifier hs-var">MS.toSet</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679526123"><span class="hs-identifier hs-var">rightMS</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-278"></span><span>  </span><span id="local-6989586621679526115"><span class="annot"><span class="annottext">both :: HashMap n SpreadDirection
</span><a href="#local-6989586621679526115"><span class="hs-identifier hs-var hs-var">both</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b -&gt; a) -&gt; a -&gt; HashSet b -&gt; a
</span><span class="hs-identifier hs-var">S.foldl'</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679526113"><span class="annot"><span class="annottext">HashMap n SpreadDirection
</span><a href="#local-6989586621679526113"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679526112"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526112"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall k v.
(Eq k, Hashable k) =&gt;
k -&gt; v -&gt; HashMap k v -&gt; HashMap k v
</span><span class="hs-identifier hs-var">HM.insert</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679526112"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">SpreadDirection
</span><a href="PVGrammar.html#ToBoth"><span class="hs-identifier hs-var">ToBoth</span></a></span><span> </span><span class="annot"><span class="annottext">HashMap n SpreadDirection
</span><a href="#local-6989586621679526113"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall k v. HashMap k v
</span><span class="hs-identifier hs-var">HM.empty</span></span><span> </span><span class="annot"><span class="annottext">HashSet n
</span><a href="#local-6989586621679526120"><span class="hs-identifier hs-var">bothSet</span></a></span><span>
</span><span id="line-279"></span><span>  </span><span id="local-6989586621679526152"><span class="annot"><span class="annottext">op :: Spread n
</span><a href="#local-6989586621679526152"><span class="hs-identifier hs-var hs-var">op</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall n. HashMap n SpreadDirection -&gt; Edges n -&gt; Spread n
</span><a href="PVGrammar.html#SpreadOp"><span class="hs-identifier hs-var">SpreadOp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">HashMap n SpreadDirection
</span><a href="#local-6989586621679526128"><span class="hs-identifier hs-var">left</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">HashMap n SpreadDirection
</span><a href="#local-6989586621679526122"><span class="hs-identifier hs-var">right</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">HashMap n SpreadDirection
</span><a href="#local-6989586621679526115"><span class="hs-identifier hs-var">both</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679526158"><span class="hs-identifier hs-var">edges</span></a></span><span>
</span><span id="line-280"></span><span>
</span><span id="line-281"></span><span class="hs-comment">{- | Computes all left parent transitions for a verticalization and a left child transition.
 Here, this operation is always admitted and unique,
 so the edges from the child transition are just passed through.
-}</span><span>
</span><span id="line-285"></span><span id="local-6989586621679527043"><span class="annot"><a href="PVGrammar.Parse.html#pvUnspreadLeft"><span class="hs-identifier hs-type">pvUnspreadLeft</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Common.html#UnspreadLeft"><span class="hs-identifier hs-type">UnspreadLeft</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527043"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527043"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-286"></span><span id="pvUnspreadLeft"><span class="annot"><span class="annottext">pvUnspreadLeft :: forall n. UnspreadLeft (Edges n) (Notes n)
</span><a href="PVGrammar.Parse.html#pvUnspreadLeft"><span class="hs-identifier hs-var hs-var">pvUnspreadLeft</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679526107"><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679526107"><span class="hs-identifier hs-var">el</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Notes n
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Notes n
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679526107"><span class="hs-identifier hs-var">el</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-287"></span><span>
</span><span id="line-288"></span><span class="hs-comment">{- | Computes all right parent transition for a verticalization and a right child transition.
 Here, this operation is always admitted and unique,
 so the edges from the child transition are just passed through.
-}</span><span>
</span><span id="line-292"></span><span id="local-6989586621679527042"><span class="annot"><a href="PVGrammar.Parse.html#pvUnspreadRight"><span class="hs-identifier hs-type">pvUnspreadRight</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Common.html#UnspreadRight"><span class="hs-identifier hs-type">UnspreadRight</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527042"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527042"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-293"></span><span id="pvUnspreadRight"><span class="annot"><span class="annottext">pvUnspreadRight :: forall n. UnspreadRight (Edges n) (Notes n)
</span><a href="PVGrammar.Parse.html#pvUnspreadRight"><span class="hs-identifier hs-var hs-var">pvUnspreadRight</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Notes n
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679526106"><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679526106"><span class="hs-identifier hs-var">er</span></a></span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Notes n
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679526106"><span class="hs-identifier hs-var">er</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-294"></span><span>
</span><span id="line-295"></span><span class="hs-comment">{- | Computes all possible unsplits of two child transitions.
 Since transitions here only represent the certain edges,
 'pvUnsplit' must also take into account unelaborated edges,
 which are not present in the child transitions.
-}</span><span>
</span><span id="line-300"></span><span id="local-6989586621679527020"><span class="annot"><a href="PVGrammar.Parse.html#pvUnsplit%27"><span class="hs-identifier hs-type">pvUnsplit'</span></a></span><span>
</span><span id="line-301"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527020"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679527020"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679527020"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679527020"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-302"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#StartStop"><span class="hs-identifier hs-type">StartStop</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527020"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-303"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527020"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-304"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527020"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-305"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527020"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-306"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Common.html#StartStop"><span class="hs-identifier hs-type">StartStop</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527020"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-307"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IO</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527020"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Split"><span class="hs-identifier hs-type">Split</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527020"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span></span><span>
</span><span id="line-308"></span><span id="pvUnsplit%27"><span class="annot"><span class="annottext">pvUnsplit' :: forall n.
(IsNote n, Notation n, Ord n, Hashable n) =&gt;
StartStop (Notes n)
-&gt; Edges n
-&gt; Notes n
-&gt; Edges n
-&gt; StartStop (Notes n)
-&gt; IO [(Edges n, Split n)]
</span><a href="PVGrammar.Parse.html#pvUnsplit%27"><span class="hs-identifier hs-var hs-var">pvUnsplit'</span></a></span></span><span> </span><span id="local-6989586621679525935"><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679525935"><span class="hs-identifier hs-var">notesl</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span id="local-6989586621679525933"><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679525933"><span class="hs-identifier hs-var">leftRegs</span></a></span></span><span> </span><span id="local-6989586621679525932"><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525932"><span class="hs-identifier hs-var">leftPass</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span id="local-6989586621679525931"><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679525931"><span class="hs-identifier hs-var">notesm</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span id="local-6989586621679525930"><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679525930"><span class="hs-identifier hs-var">rightRegs</span></a></span></span><span> </span><span id="local-6989586621679525929"><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525929"><span class="hs-identifier hs-var">rightPass</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679525928"><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679525928"><span class="hs-identifier hs-var">notesr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-309"></span><span>  </span><span class="hs-keyword">do</span><span>
</span><span id="line-310"></span><span>  </span><span id="local-6989586621679525927"><span class="annot"><span class="annottext">StdGen
</span><a href="#local-6989586621679525927"><span class="hs-identifier hs-var">gen</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *). MonadIO m =&gt; m StdGen
</span><span class="hs-identifier hs-var">initStdGen</span></span><span>
</span><span id="line-311"></span><span>  </span><span id="local-6989586621679525926"><span class="annot"><span class="annottext">IOGenM StdGen
</span><a href="#local-6989586621679525926"><span class="hs-identifier hs-var">mgen</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) g. MonadIO m =&gt; g -&gt; m (IOGenM g)
</span><span class="hs-identifier hs-var">newIOGenM</span></span><span> </span><span class="annot"><span class="annottext">StdGen
</span><a href="#local-6989586621679525927"><span class="hs-identifier hs-var">gen</span></a></span><span>
</span><span id="line-312"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679525925"><span class="annot"><span class="annottext">options :: [[([(Edge n, (n, DoubleOrnament))],
   [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
   [(n, (n, LeftOrnament))])]]
</span><a href="#local-6989586621679525925"><span class="hs-identifier hs-var hs-var">options</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">IOGenM StdGen
-&gt; MultiSet n
-&gt; [[([(Edge n, (n, DoubleOrnament))],
      [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
      [(n, (n, LeftOrnament))])]]
</span><a href="#local-6989586621679525924"><span class="hs-identifier hs-var">getOptions</span></a></span><span> </span><span class="annot"><span class="annottext">IOGenM StdGen
</span><a href="#local-6989586621679525926"><span class="hs-identifier hs-var">mgen</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679525931"><span class="hs-identifier hs-var">notesm</span></a></span><span>
</span><span id="line-313"></span><span>  </span><span id="local-6989586621679525923"><span class="annot"><span class="annottext">[([(Edge n, (n, DoubleOrnament))],
  [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
  [(n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679525923"><span class="hs-identifier hs-var">combinations</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall g a. StatefulGen g IO =&gt; g -&gt; MaybeT IO a -&gt; IO [a]
</span><a href="Probability.html#collectRandomChoice"><span class="hs-identifier hs-var">collectRandomChoice</span></a></span><span> </span><span class="annot"><span class="annottext">IOGenM StdGen
</span><a href="#local-6989586621679525926"><span class="hs-identifier hs-var">mgen</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall {t :: * -&gt; *} {p} {a} {a} {a} {a}.
(Foldable t, StatefulGen p IO) =&gt;
p -&gt; t [([a], [a], [a], [a])] -&gt; MaybeT IO ([a], [a], [a], [a])
</span><a href="#local-6989586621679525921"><span class="hs-identifier hs-var">getCombinations</span></a></span><span> </span><span class="annot"><span class="annottext">IOGenM StdGen
</span><a href="#local-6989586621679525926"><span class="hs-identifier hs-var">mgen</span></a></span><span> </span><span class="annot"><span class="annottext">[[([(Edge n, (n, DoubleOrnament))],
   [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
   [(n, (n, LeftOrnament))])]]
</span><a href="#local-6989586621679525925"><span class="hs-identifier hs-var">options</span></a></span><span>
</span><span id="line-314"></span><span class="hs-comment">--   collectRandomChoice mgen $ enumerateAll mgen </span><span>
</span><span id="line-315"></span><span class="hs-comment">--   -- pure $ map mkTop combinations</span><span>
</span><span id="line-316"></span><span>  </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">([(Edge n, (n, DoubleOrnament))],
 [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
 [(n, (n, LeftOrnament))])
-&gt; (Edges n, Split n)
</span><a href="#local-6989586621679525920"><span class="hs-identifier hs-var">mkTop</span></a></span><span> </span><span class="annot"><span class="annottext">[([(Edge n, (n, DoubleOrnament))],
  [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
  [(n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679525923"><span class="hs-identifier hs-var">combinations</span></a></span><span>
</span><span id="line-317"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-318"></span><span>  </span><span class="hs-comment">-- preprocessing of the notes left and right of the unsplit</span><span>
</span><span id="line-319"></span><span>  </span><span class="hs-glyph">!</span><span id="local-6989586621679525919"><span class="annot"><span class="annottext">innerL :: [EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679525919"><span class="hs-identifier hs-var hs-var">innerL</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall n. StartStop (Notes n) -&gt; [StartStop n]
</span><a href="PVGrammar.html#innerNotes"><span class="hs-identifier hs-var">innerNotes</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679525935"><span class="hs-identifier hs-var">notesl</span></a></span><span>
</span><span id="line-320"></span><span>  </span><span class="hs-glyph">!</span><span id="local-6989586621679525917"><span class="annot"><span class="annottext">innerR :: [EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679525917"><span class="hs-identifier hs-var hs-var">innerR</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall n. StartStop (Notes n) -&gt; [StartStop n]
</span><a href="PVGrammar.html#innerNotes"><span class="hs-identifier hs-var">innerNotes</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679525928"><span class="hs-identifier hs-var">notesr</span></a></span><span>
</span><span id="line-321"></span><span>
</span><span id="line-322"></span><span>  </span><span class="hs-comment">-- find all reduction options for every pitch</span><span>
</span><span id="line-323"></span><span>  </span><span id="local-6989586621679525924"><span class="annot"><span class="annottext">getOptions :: IOGenM StdGen
-&gt; MultiSet n
-&gt; [[([(Edge n, (n, DoubleOrnament))],
      [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
      [(n, (n, LeftOrnament))])]]
</span><a href="#local-6989586621679525924"><span class="hs-identifier hs-var hs-var">getOptions</span></a></span></span><span> </span><span id="local-6989586621679525916"><span class="annot"><span class="annottext">IOGenM StdGen
</span><a href="#local-6989586621679525916"><span class="hs-identifier hs-var">mgen</span></a></span></span><span> </span><span id="local-6989586621679525915"><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679525915"><span class="hs-identifier hs-var">notesm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IOGenM StdGen
-&gt; (n, Int)
-&gt; [([(Edge n, (n, DoubleOrnament))],
     [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
     [(n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679525914"><span class="hs-identifier hs-var">noteOptions</span></a></span><span> </span><span class="annot"><span class="annottext">IOGenM StdGen
</span><a href="#local-6989586621679525916"><span class="hs-identifier hs-var">mgen</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall k. MultiSet k -&gt; [(k, Int)]
</span><a href="Internal.MultiSet.html#toOccurList"><span class="hs-identifier hs-var">MS.toOccurList</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679525915"><span class="hs-identifier hs-var">notesm</span></a></span><span>
</span><span id="line-324"></span><span>
</span><span id="line-325"></span><span>  </span><span class="hs-comment">-- find all reduction options for every pitch</span><span>
</span><span id="line-326"></span><span>  </span><span class="hs-comment">-- noteOptions </span><span>
</span><span id="line-327"></span><span>  </span><span class="hs-comment">--   :: IOGenM StdGen</span><span>
</span><span id="line-328"></span><span>  </span><span class="hs-comment">--   -&gt; (n, Int)</span><span>
</span><span id="line-329"></span><span>  </span><span class="hs-comment">--   -&gt; [([(Edge n, (n, DoubleOrnament))],</span><span>
</span><span id="line-330"></span><span>  </span><span class="hs-comment">--      [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],</span><span>
</span><span id="line-331"></span><span>  </span><span class="hs-comment">--      [(n, (n, LeftOrnament))])]</span><span>
</span><span id="line-332"></span><span>  </span><span id="local-6989586621679525914"><span class="annot"><span class="annottext">noteOptions :: IOGenM StdGen
-&gt; (n, Int)
-&gt; [([(Edge n, (n, DoubleOrnament))],
     [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
     [(n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679525914"><span class="hs-identifier hs-var hs-var">noteOptions</span></a></span></span><span> </span><span id="local-6989586621679525913"><span class="annot"><span class="annottext">IOGenM StdGen
</span><a href="#local-6989586621679525913"><span class="hs-identifier hs-var">mgen</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525912"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525912"><span class="hs-identifier hs-var">note</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525911"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525911"><span class="hs-identifier hs-var">nocc</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-333"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525911"><span class="hs-identifier hs-var">nocc</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. MultiSet a -&gt; Int
</span><a href="Internal.MultiSet.html#size"><span class="hs-identifier hs-var">MS.size</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525908"><span class="hs-identifier hs-var">mandatoryLeft</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525911"><span class="hs-identifier hs-var">nocc</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. MultiSet a -&gt; Int
</span><a href="Internal.MultiSet.html#size"><span class="hs-identifier hs-var">MS.size</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525906"><span class="hs-identifier hs-var">mandatoryRight</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-334"></span><span>         </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-335"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-336"></span><span>      </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b c d.
Foldable t =&gt;
t (Elaboration a b c d) -&gt; ([a], [b], [c], [d])
</span><a href="PVGrammar.Parse.html#partitionElaborations"><span class="hs-identifier hs-var">partitionElaborations</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">IOGenM StdGen
-&gt; MultiSet (EdgeEither (StartStop n) n)
-&gt; MultiSet (EdgeEither (StartStop n) n)
-&gt; Int
-&gt; [[Elaboration
       (Edge n, (n, DoubleOrnament))
       (InnerEdge n, (n, PassingOrnament))
       (n, (n, RightOrnament))
       (n, (n, LeftOrnament))]]
</span><a href="#local-6989586621679525905"><span class="hs-identifier hs-var">enumerateOptions</span></a></span><span> </span><span class="annot"><span class="annottext">IOGenM StdGen
</span><a href="#local-6989586621679525913"><span class="hs-identifier hs-var">mgen</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525908"><span class="hs-identifier hs-var">mandatoryLeft</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525906"><span class="hs-identifier hs-var">mandatoryRight</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525911"><span class="hs-identifier hs-var">nocc</span></a></span><span>
</span><span id="line-337"></span><span>    </span><span class="hs-comment">-- | nocc &lt; MS.size mandatoryLeft || nocc &lt; MS.size mandatoryRight =</span><span>
</span><span id="line-338"></span><span>    </span><span class="hs-comment">--     []</span><span>
</span><span id="line-339"></span><span>    </span><span class="hs-comment">-- | otherwise =</span><span>
</span><span id="line-340"></span><span>    </span><span class="hs-comment">--     partitionElaborations</span><span>
</span><span id="line-341"></span><span>    </span><span class="hs-comment">--       &lt;$&gt; enumerateOptions mandatoryLeft mandatoryRight nocc</span><span>
</span><span id="line-342"></span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-343"></span><span>    </span><span class="hs-comment">-- compute the mandatory edges for the current pitch:</span><span>
</span><span id="line-344"></span><span>    </span><span id="local-6989586621679525904"><span class="annot"><span class="annottext">mleftRegs :: HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525904"><span class="hs-identifier hs-var hs-var">mleftRegs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall b a.
(Hashable b, Eq b) =&gt;
(a -&gt; b) -&gt; HashSet a -&gt; HashSet b
</span><span class="hs-identifier hs-var">S.map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; Bool) -&gt; HashSet a -&gt; HashSet a
</span><span class="hs-identifier hs-var">S.filter</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525912"><span class="hs-identifier hs-var">note</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679525933"><span class="hs-identifier hs-var">leftRegs</span></a></span><span>
</span><span id="line-345"></span><span>    </span><span id="local-6989586621679525901"><span class="annot"><span class="annottext">mleftPass :: MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525901"><span class="hs-identifier hs-var hs-var">mleftPass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall b a.
(Eq b, Hashable b) =&gt;
(a -&gt; b) -&gt; MultiSet a -&gt; MultiSet b
</span><a href="Internal.MultiSet.html#map"><span class="hs-identifier hs-var">MS.map</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. b -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-var">Pass</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; Bool) -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#filter"><span class="hs-identifier hs-var">MS.filter</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525912"><span class="hs-identifier hs-var">note</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525932"><span class="hs-identifier hs-var">leftPass</span></a></span><span>
</span><span id="line-346"></span><span>    </span><span id="local-6989586621679525898"><span class="annot"><span class="annottext">mrightRegs :: HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525898"><span class="hs-identifier hs-var hs-var">mrightRegs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall b a.
(Hashable b, Eq b) =&gt;
(a -&gt; b) -&gt; HashSet a -&gt; HashSet b
</span><span class="hs-identifier hs-var">S.map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; Bool) -&gt; HashSet a -&gt; HashSet a
</span><span class="hs-identifier hs-var">S.filter</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525912"><span class="hs-identifier hs-var">note</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679525930"><span class="hs-identifier hs-var">rightRegs</span></a></span><span>
</span><span id="line-347"></span><span>    </span><span id="local-6989586621679525897"><span class="annot"><span class="annottext">mrightPass :: MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525897"><span class="hs-identifier hs-var hs-var">mrightPass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall b a.
(Eq b, Hashable b) =&gt;
(a -&gt; b) -&gt; MultiSet a -&gt; MultiSet b
</span><a href="Internal.MultiSet.html#map"><span class="hs-identifier hs-var">MS.map</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. b -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-var">Pass</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; Bool) -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#filter"><span class="hs-identifier hs-var">MS.filter</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525912"><span class="hs-identifier hs-var">note</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525929"><span class="hs-identifier hs-var">rightPass</span></a></span><span>
</span><span id="line-348"></span><span>    </span><span id="local-6989586621679525908"><span class="annot"><span class="annottext">mandatoryLeft :: MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525908"><span class="hs-identifier hs-var hs-var">mandatoryLeft</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a.
(Foldable t, Eq a, Hashable a) =&gt;
t a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#fromSet"><span class="hs-identifier hs-var">MS.fromSet</span></a></span><span> </span><span class="annot"><span class="annottext">HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525904"><span class="hs-identifier hs-var">mleftRegs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525901"><span class="hs-identifier hs-var">mleftPass</span></a></span><span>
</span><span id="line-349"></span><span>    </span><span id="local-6989586621679525906"><span class="annot"><span class="annottext">mandatoryRight :: MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525906"><span class="hs-identifier hs-var hs-var">mandatoryRight</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a.
(Foldable t, Eq a, Hashable a) =&gt;
t a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#fromSet"><span class="hs-identifier hs-var">MS.fromSet</span></a></span><span> </span><span class="annot"><span class="annottext">HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525898"><span class="hs-identifier hs-var">mrightRegs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525897"><span class="hs-identifier hs-var">mrightPass</span></a></span><span>
</span><span id="line-350"></span><span>
</span><span id="line-351"></span><span>    </span><span class="hs-comment">-- the possible reductions of a (multiple) pitch are enumerated in three stages:</span><span>
</span><span id="line-352"></span><span>
</span><span id="line-353"></span><span>    </span><span class="hs-comment">-- stage 1: consume all mandatory edges on the left</span><span>
</span><span id="line-354"></span><span>    </span><span id="local-6989586621679525905"><span class="annot"><span class="annottext">enumerateOptions :: IOGenM StdGen
-&gt; MultiSet (EdgeEither (StartStop n) n)
-&gt; MultiSet (EdgeEither (StartStop n) n)
-&gt; Int
-&gt; [[Elaboration
       (Edge n, (n, DoubleOrnament))
       (InnerEdge n, (n, PassingOrnament))
       (n, (n, RightOrnament))
       (n, (n, LeftOrnament))]]
</span><a href="#local-6989586621679525905"><span class="hs-identifier hs-var hs-var">enumerateOptions</span></a></span></span><span> </span><span id="local-6989586621679525895"><span class="annot"><span class="annottext">IOGenM StdGen
</span><a href="#local-6989586621679525895"><span class="hs-identifier hs-var">mgen</span></a></span></span><span> </span><span id="local-6989586621679525894"><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525894"><span class="hs-identifier hs-var">ml</span></a></span></span><span> </span><span id="local-6989586621679525893"><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525893"><span class="hs-identifier hs-var">mr</span></a></span></span><span> </span><span id="local-6989586621679525892"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525892"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-355"></span><span>      </span><span class="hs-special">(</span><span id="local-6989586621679525891"><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525891"><span class="hs-identifier hs-var">mr'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525890"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525890"><span class="hs-identifier hs-var">n'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525889"><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525889"><span class="hs-identifier hs-var">acc</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span>  </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) b a.
Monad m =&gt;
(b -&gt; a -&gt; m b) -&gt; b -&gt; MultiSet a -&gt; m b
</span><a href="Internal.MultiSet.html#foldM"><span class="hs-identifier hs-var">MS.foldM</span></a></span><span> </span><span class="annot"><span class="annottext">(MultiSet (EdgeEither (StartStop n) n), Int,
 [Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament))])
-&gt; EdgeEither (StartStop n) n
-&gt; [(MultiSet (EdgeEither (StartStop n) n), Int,
     [Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679525887"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525893"><span class="hs-identifier hs-var">mr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525892"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525894"><span class="hs-identifier hs-var">ml</span></a></span><span>
</span><span id="line-356"></span><span>      </span><span class="hs-special">(</span><span id="local-6989586621679525886"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525886"><span class="hs-identifier hs-var">n''</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525885"><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525885"><span class="hs-identifier hs-var">acc'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span>  </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) b a.
Monad m =&gt;
(b -&gt; a -&gt; m b) -&gt; b -&gt; MultiSet a -&gt; m b
</span><a href="Internal.MultiSet.html#foldM"><span class="hs-identifier hs-var">MS.foldM</span></a></span><span> </span><span class="annot"><span class="annottext">(Int,
 [Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament))])
-&gt; EdgeEither (StartStop n) n
-&gt; [(Int,
     [Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679525884"><span class="hs-identifier hs-var">goR</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525890"><span class="hs-identifier hs-var">n'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525889"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525891"><span class="hs-identifier hs-var">mr'</span></a></span><span>
</span><span id="line-357"></span><span>      </span><span class="annot"><span class="annottext">forall {a}. [a] -&gt; Int -&gt; [a] -&gt; [[a]]
</span><a href="#local-6989586621679525883"><span class="hs-identifier hs-var">goFree</span></a></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525882"><span class="hs-identifier hs-var">freeOptions</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525886"><span class="hs-identifier hs-var">n''</span></a></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525885"><span class="hs-identifier hs-var">acc'</span></a></span><span>
</span><span id="line-358"></span><span>
</span><span id="line-359"></span><span>    </span><span id="local-6989586621679525887"><span class="annot"><span class="annottext">goL :: (MultiSet (EdgeEither (StartStop n) n), Int,
 [Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament))])
-&gt; EdgeEither (StartStop n) n
-&gt; [(MultiSet (EdgeEither (StartStop n) n), Int,
     [Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679525887"><span class="hs-identifier hs-var hs-var">goL</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-360"></span><span>    </span><span class="annot"><a href="#local-6989586621679525887"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525881"><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525881"><span class="hs-identifier hs-var">mr</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525880"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525880"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525879"><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525879"><span class="hs-identifier hs-var">acc</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679525878"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525878"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-361"></span><span>      </span><span class="hs-special">(</span><span id="local-6989586621679525877"><span class="annot"><span class="annottext">Elaboration
  (Edge n, (n, DoubleOrnament))
  (InnerEdge n, (n, PassingOrnament))
  (n, (n, RightOrnament))
  (n, (n, LeftOrnament))
</span><a href="#local-6989586621679525877"><span class="hs-identifier hs-var">new</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525876"><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525876"><span class="hs-identifier hs-var">mr'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Int
-&gt; EdgeEither (StartStop n) n
-&gt; MultiSet (EdgeEither (StartStop n) n)
-&gt; [(Elaboration
       (Edge n, (n, DoubleOrnament))
       (InnerEdge n, (n, PassingOrnament))
       (n, (n, RightOrnament))
       (n, (n, LeftOrnament)),
     MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679525875"><span class="hs-identifier hs-var">pickLeft</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525880"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525878"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525881"><span class="hs-identifier hs-var">mr</span></a></span><span>
</span><span id="line-362"></span><span>      </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525876"><span class="hs-identifier hs-var">mr'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525880"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Elaboration
  (Edge n, (n, DoubleOrnament))
  (InnerEdge n, (n, PassingOrnament))
  (n, (n, RightOrnament))
  (n, (n, LeftOrnament))
</span><a href="#local-6989586621679525877"><span class="hs-identifier hs-var">new</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525879"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-363"></span><span>    </span><span class="hs-comment">-- combine a mandatory left with a mandatory right or free right edge</span><span>
</span><span id="line-364"></span><span>    </span><span id="local-6989586621679525875"><span class="annot"><span class="annottext">pickLeft :: Int
-&gt; EdgeEither (StartStop n) n
-&gt; MultiSet (EdgeEither (StartStop n) n)
-&gt; [(Elaboration
       (Edge n, (n, DoubleOrnament))
       (InnerEdge n, (n, PassingOrnament))
       (n, (n, RightOrnament))
       (n, (n, LeftOrnament)),
     MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679525875"><span class="hs-identifier hs-var hs-var">pickLeft</span></a></span></span><span> </span><span id="local-6989586621679525874"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525874"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679525873"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525873"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679525872"><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525872"><span class="hs-identifier hs-var">mr</span></a></span></span><span>
</span><span id="line-365"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525874"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. MultiSet a -&gt; Int
</span><a href="Internal.MultiSet.html#size"><span class="hs-identifier hs-var">MS.size</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525872"><span class="hs-identifier hs-var">mr</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679525870"><span class="hs-identifier hs-var">mand</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679525869"><span class="hs-identifier hs-var">opt</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679525868"><span class="hs-identifier hs-var">single</span></a></span><span>
</span><span id="line-366"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679525870"><span class="hs-identifier hs-var">mand</span></a></span><span>
</span><span id="line-367"></span><span>     </span><span class="hs-keyword">where</span><span>
</span><span id="line-368"></span><span>      </span><span id="local-6989586621679525870"><span class="annot"><span class="annottext">mand :: [(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679525870"><span class="hs-identifier hs-var hs-var">mand</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-369"></span><span>        </span><span id="local-6989586621679525867"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525867"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall k. MultiSet k -&gt; [k]
</span><a href="Internal.MultiSet.html#distinctElems"><span class="hs-identifier hs-var">MS.distinctElems</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525872"><span class="hs-identifier hs-var">mr</span></a></span><span>
</span><span id="line-370"></span><span>        </span><span id="local-6989586621679525865"><span class="annot"><span class="annottext">Elaboration
  (Edge n, (n, DoubleOrnament))
  (InnerEdge n, (n, PassingOrnament))
  (n, (n, RightOrnament))
  (n, (n, LeftOrnament))
</span><a href="#local-6989586621679525865"><span class="hs-identifier hs-var">red</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; [a]
</span><span class="hs-identifier hs-var">maybeToList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall {n} {c} {d}.
(HasPitch n, Diatonic (ICOf (IntervalOf n)),
 Eq (ICOf (IntervalOf n))) =&gt;
Bool
-&gt; Bool
-&gt; EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        c
        d)
</span><a href="#local-6989586621679525864"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525873"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525912"><span class="hs-identifier hs-var">note</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525867"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-371"></span><span>        </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Elaboration
  (Edge n, (n, DoubleOrnament))
  (InnerEdge n, (n, PassingOrnament))
  (n, (n, RightOrnament))
  (n, (n, LeftOrnament))
</span><a href="#local-6989586621679525865"><span class="hs-identifier hs-var">red</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#delete"><span class="hs-identifier hs-var">MS.delete</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525867"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525872"><span class="hs-identifier hs-var">mr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-372"></span><span>      </span><span class="hs-comment">-- TODO: remove mr options here?</span><span>
</span><span id="line-373"></span><span>      </span><span id="local-6989586621679525862"><span class="annot"><span class="annottext">tryOpt :: EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament)))
</span><a href="#local-6989586621679525862"><span class="hs-identifier hs-var hs-var">tryOpt</span></a></span></span><span> </span><span id="local-6989586621679525861"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525861"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall {n} {c} {d}.
(HasPitch n, Diatonic (ICOf (IntervalOf n)),
 Eq (ICOf (IntervalOf n))) =&gt;
Bool
-&gt; Bool
-&gt; EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        c
        d)
</span><a href="#local-6989586621679525864"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525861"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; HashSet a -&gt; Bool
</span><span class="hs-operator hs-var">`S.member`</span></span><span> </span><span class="annot"><span class="annottext">HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525898"><span class="hs-identifier hs-var">mrightRegs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525873"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525912"><span class="hs-identifier hs-var">note</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525861"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-374"></span><span>      </span><span id="local-6989586621679525869"><span class="annot"><span class="annottext">opt :: [(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679525869"><span class="hs-identifier hs-var hs-var">opt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525872"><span class="hs-identifier hs-var">mr</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament)))
</span><a href="#local-6989586621679525862"><span class="hs-identifier hs-var">tryOpt</span></a></span><span> </span><span class="annot"><span class="annottext">[EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679525917"><span class="hs-identifier hs-var">innerR</span></a></span><span>
</span><span id="line-375"></span><span>      </span><span id="local-6989586621679525868"><span class="annot"><span class="annottext">single :: [(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679525868"><span class="hs-identifier hs-var hs-var">single</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525872"><span class="hs-identifier hs-var">mr</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; [a]
</span><span class="hs-identifier hs-var">maybeToList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall {a} {b} {a} {b} {d}.
(HasPitch a, Diatonic (ICOf (IntervalOf a)),
 Eq (ICOf (IntervalOf a))) =&gt;
a
-&gt; EdgeEither (StartStop a) b
-&gt; Maybe (Elaboration a b (a, (a, RightOrnament)) d)
</span><a href="#local-6989586621679525859"><span class="hs-identifier hs-var">tryLeftReduction</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525912"><span class="hs-identifier hs-var">note</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525873"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-376"></span><span>
</span><span id="line-377"></span><span>    </span><span class="hs-comment">-- stage 2: consume all remaining mandatory edges on the right</span><span>
</span><span id="line-378"></span><span>    </span><span id="local-6989586621679525884"><span class="annot"><span class="annottext">goR :: (Int,
 [Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament))])
-&gt; EdgeEither (StartStop n) n
-&gt; [(Int,
     [Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679525884"><span class="hs-identifier hs-var hs-var">goR</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-379"></span><span>    </span><span class="annot"><a href="#local-6989586621679525884"><span class="hs-identifier hs-var">goR</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525858"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525858"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525857"><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525857"><span class="hs-identifier hs-var">acc</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679525856"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525856"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-380"></span><span>      </span><span id="local-6989586621679525855"><span class="annot"><span class="annottext">Elaboration
  (Edge n, (n, DoubleOrnament))
  (InnerEdge n, (n, PassingOrnament))
  (n, (n, RightOrnament))
  (n, (n, LeftOrnament))
</span><a href="#local-6989586621679525855"><span class="hs-identifier hs-var">new</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
-&gt; [Elaboration
      (Edge n, (n, DoubleOrnament))
      (InnerEdge n, (n, PassingOrnament))
      (n, (n, RightOrnament))
      (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525854"><span class="hs-identifier hs-var">pickRight</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525856"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-381"></span><span>      </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525858"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Elaboration
  (Edge n, (n, DoubleOrnament))
  (InnerEdge n, (n, PassingOrnament))
  (n, (n, RightOrnament))
  (n, (n, LeftOrnament))
</span><a href="#local-6989586621679525855"><span class="hs-identifier hs-var">new</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525857"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-382"></span><span>    </span><span class="hs-comment">-- combine mandatory right with free left edge</span><span>
</span><span id="line-383"></span><span>    </span><span id="local-6989586621679525854"><span class="annot"><span class="annottext">pickRight :: EdgeEither (StartStop n) n
-&gt; [Elaboration
      (Edge n, (n, DoubleOrnament))
      (InnerEdge n, (n, PassingOrnament))
      (n, (n, RightOrnament))
      (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525854"><span class="hs-identifier hs-var hs-var">pickRight</span></a></span></span><span> </span><span id="local-6989586621679525853"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525853"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525852"><span class="hs-identifier hs-var">opt</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525851"><span class="hs-identifier hs-var">single</span></a></span><span>
</span><span id="line-384"></span><span>     </span><span class="hs-keyword">where</span><span>
</span><span id="line-385"></span><span>      </span><span id="local-6989586621679525850"><span class="annot"><span class="annottext">tryOpt :: EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament)))
</span><a href="#local-6989586621679525850"><span class="hs-identifier hs-var hs-var">tryOpt</span></a></span></span><span> </span><span id="local-6989586621679525849"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525849"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall {n} {c} {d}.
(HasPitch n, Diatonic (ICOf (IntervalOf n)),
 Eq (ICOf (IntervalOf n))) =&gt;
Bool
-&gt; Bool
-&gt; EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        c
        d)
</span><a href="#local-6989586621679525864"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525849"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; HashSet a -&gt; Bool
</span><span class="hs-operator hs-var">`S.member`</span></span><span> </span><span class="annot"><span class="annottext">HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525904"><span class="hs-identifier hs-var">mleftRegs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525849"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525912"><span class="hs-identifier hs-var">note</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525853"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-386"></span><span>      </span><span id="local-6989586621679525852"><span class="annot"><span class="annottext">opt :: [Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525852"><span class="hs-identifier hs-var hs-var">opt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament)))
</span><a href="#local-6989586621679525850"><span class="hs-identifier hs-var">tryOpt</span></a></span><span> </span><span class="annot"><span class="annottext">[EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679525919"><span class="hs-identifier hs-var">innerL</span></a></span><span>
</span><span id="line-387"></span><span>      </span><span id="local-6989586621679525851"><span class="annot"><span class="annottext">single :: [Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525851"><span class="hs-identifier hs-var hs-var">single</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; [a]
</span><span class="hs-identifier hs-var">maybeToList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall {a} {b} {a} {b} {c}.
(HasPitch a, Diatonic (ICOf (IntervalOf a)),
 Eq (ICOf (IntervalOf a))) =&gt;
a
-&gt; EdgeEither (StartStop a) b
-&gt; Maybe (Elaboration a b c (a, (a, LeftOrnament)))
</span><a href="#local-6989586621679525848"><span class="hs-identifier hs-var">tryRightReduction</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525912"><span class="hs-identifier hs-var">note</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525853"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-388"></span><span>
</span><span id="line-389"></span><span>    </span><span class="hs-comment">-- stage 3: explain all remaining notes through a combination of unknown edges</span><span>
</span><span id="line-390"></span><span>    </span><span id="local-6989586621679525883"><span class="annot"><span class="annottext">goFree :: [a] -&gt; Int -&gt; [a] -&gt; [[a]]
</span><a href="#local-6989586621679525883"><span class="hs-identifier hs-var hs-var">goFree</span></a></span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span id="local-6989586621679525836"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679525836"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679525836"><span class="hs-identifier hs-var">acc</span></a></span><span>
</span><span id="line-391"></span><span>    </span><span class="annot"><a href="#local-6989586621679525883"><span class="hs-identifier hs-var">goFree</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-392"></span><span>    </span><span class="annot"><a href="#local-6989586621679525883"><span class="hs-identifier hs-var">goFree</span></a></span><span> </span><span class="hs-special">[</span><span id="local-6989586621679525835"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525835"><span class="hs-identifier hs-var">lastOpt</span></a></span></span><span class="hs-special">]</span><span> </span><span id="local-6989586621679525834"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525834"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679525833"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679525833"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. Int -&gt; a -&gt; [a]
</span><span class="hs-identifier hs-var">L.replicate</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525834"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525835"><span class="hs-identifier hs-var">lastOpt</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679525833"><span class="hs-identifier hs-var">acc</span></a></span><span>
</span><span id="line-393"></span><span>    </span><span class="annot"><a href="#local-6989586621679525883"><span class="hs-identifier hs-var">goFree</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525831"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525831"><span class="hs-identifier hs-var">opt</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621679525830"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679525830"><span class="hs-identifier hs-var">opts</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679525829"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525829"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679525828"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679525828"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-394"></span><span>      </span><span id="local-6989586621679525827"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525827"><span class="hs-identifier hs-var">nopt</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">..</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525829"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-395"></span><span>      </span><span class="annot"><span class="annottext">[a] -&gt; Int -&gt; [a] -&gt; [[a]]
</span><a href="#local-6989586621679525883"><span class="hs-identifier hs-var">goFree</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679525830"><span class="hs-identifier hs-var">opts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525829"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525827"><span class="hs-identifier hs-var">nopt</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Int -&gt; a -&gt; [a]
</span><span class="hs-identifier hs-var">L.replicate</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525827"><span class="hs-identifier hs-var">nopt</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525831"><span class="hs-identifier hs-var">opt</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679525828"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-396"></span><span>    </span><span class="hs-comment">-- list all options for free reduction</span><span>
</span><span id="line-397"></span><span>    </span><span id="local-6989586621679525882"><span class="annot"><span class="annottext">freeOptions :: [Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525882"><span class="hs-identifier hs-var hs-var">freeOptions</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525826"><span class="hs-identifier hs-var">pickFreeBoth</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525825"><span class="hs-identifier hs-var">pickFreeLeft</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525824"><span class="hs-identifier hs-var">pickFreeRight</span></a></span><span>
</span><span id="line-398"></span><span>    </span><span class="hs-comment">-- combine two free edges</span><span>
</span><span id="line-399"></span><span>    </span><span id="local-6989586621679525826"><span class="annot"><span class="annottext">pickFreeBoth :: [Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525826"><span class="hs-identifier hs-var hs-var">pickFreeBoth</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-400"></span><span>      </span><span id="local-6989586621679525823"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525823"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679525919"><span class="hs-identifier hs-var">innerL</span></a></span><span>
</span><span id="line-401"></span><span>      </span><span id="local-6989586621679525822"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525822"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679525917"><span class="hs-identifier hs-var">innerR</span></a></span><span>
</span><span id="line-402"></span><span>      </span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; [a]
</span><span class="hs-identifier hs-var">maybeToList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-403"></span><span>        </span><span class="annot"><span class="annottext">forall {n} {c} {d}.
(HasPitch n, Diatonic (ICOf (IntervalOf n)),
 Eq (ICOf (IntervalOf n))) =&gt;
Bool
-&gt; Bool
-&gt; EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        c
        d)
</span><a href="#local-6989586621679525864"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525823"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; HashSet a -&gt; Bool
</span><span class="hs-operator hs-var">`S.member`</span></span><span> </span><span class="annot"><span class="annottext">HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525904"><span class="hs-identifier hs-var">mleftRegs</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525822"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; HashSet a -&gt; Bool
</span><span class="hs-operator hs-var">`S.member`</span></span><span> </span><span class="annot"><span class="annottext">HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525898"><span class="hs-identifier hs-var">mrightRegs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525823"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525912"><span class="hs-identifier hs-var">note</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525822"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-404"></span><span>    </span><span class="hs-comment">-- reduce to left using free edge</span><span>
</span><span id="line-405"></span><span>    </span><span id="local-6989586621679525825"><span class="annot"><span class="annottext">pickFreeLeft :: [Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525825"><span class="hs-identifier hs-var hs-var">pickFreeLeft</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall {a} {b} {a} {b} {d}.
(HasPitch a, Diatonic (ICOf (IntervalOf a)),
 Eq (ICOf (IntervalOf a))) =&gt;
a
-&gt; EdgeEither (StartStop a) b
-&gt; Maybe (Elaboration a b (a, (a, RightOrnament)) d)
</span><a href="#local-6989586621679525859"><span class="hs-identifier hs-var">tryLeftReduction</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525912"><span class="hs-identifier hs-var">note</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679525919"><span class="hs-identifier hs-var">innerL</span></a></span><span>
</span><span id="line-406"></span><span>    </span><span class="hs-comment">-- reduce to right using free edge</span><span>
</span><span id="line-407"></span><span>    </span><span id="local-6989586621679525824"><span class="annot"><span class="annottext">pickFreeRight :: [Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525824"><span class="hs-identifier hs-var hs-var">pickFreeRight</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall {a} {b} {a} {b} {c}.
(HasPitch a, Diatonic (ICOf (IntervalOf a)),
 Eq (ICOf (IntervalOf a))) =&gt;
a
-&gt; EdgeEither (StartStop a) b
-&gt; Maybe (Elaboration a b c (a, (a, LeftOrnament)))
</span><a href="#local-6989586621679525848"><span class="hs-identifier hs-var">tryRightReduction</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525912"><span class="hs-identifier hs-var">note</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679525917"><span class="hs-identifier hs-var">innerR</span></a></span><span>
</span><span id="line-408"></span><span>
</span><span id="line-409"></span><span>  </span><span class="hs-comment">-- at all stages: try out potential reductions:</span><span>
</span><span id="line-410"></span><span>
</span><span id="line-411"></span><span>  </span><span class="hs-comment">-- two terminal edges: any ornament</span><span>
</span><span id="line-412"></span><span>  </span><span id="local-6989586621679525864"><span class="annot"><span class="annottext">tryReduction :: Bool
-&gt; Bool
-&gt; EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        c
        d)
</span><a href="#local-6989586621679525864"><span class="hs-identifier hs-var hs-var">tryReduction</span></a></span></span><span> </span><span id="local-6989586621679525804"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679525804"><span class="hs-identifier hs-var">lIsUsed</span></a></span></span><span> </span><span id="local-6989586621679525803"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679525803"><span class="hs-identifier hs-var">rIsUsed</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span id="local-6989586621679525802"><span class="annot"><span class="annottext">StartStop n
</span><a href="#local-6989586621679525802"><span class="hs-identifier hs-var">notel</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679525801"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525801"><span class="hs-identifier hs-var">notem</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span id="local-6989586621679525800"><span class="annot"><span class="annottext">StartStop n
</span><a href="#local-6989586621679525800"><span class="hs-identifier hs-var">noter</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-413"></span><span>    </span><span id="local-6989586621679525799"><span class="annot"><span class="annottext">EdgeEither (DoubleOrnament, Edge n) (PassingOrnament, InnerEdge n)
</span><a href="#local-6989586621679525799"><span class="hs-identifier hs-var">reduction</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall n.
IsNote n =&gt;
StartStop n
-&gt; StartStop n
-&gt; StartStop n
-&gt; Bool
-&gt; Bool
-&gt; Maybe
     (EdgeEither
        (DoubleOrnament, Edge n) (PassingOrnament, InnerEdge n))
</span><a href="PVGrammar.Parse.html#findOrnament"><span class="hs-identifier hs-var">findOrnament</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><a href="#local-6989586621679525802"><span class="hs-identifier hs-var">notel</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525801"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><a href="#local-6989586621679525800"><span class="hs-identifier hs-var">noter</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679525804"><span class="hs-identifier hs-var">lIsUsed</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679525803"><span class="hs-identifier hs-var">rIsUsed</span></a></span><span>
</span><span id="line-414"></span><span>    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">EdgeEither (DoubleOrnament, Edge n) (PassingOrnament, InnerEdge n)
</span><a href="#local-6989586621679525799"><span class="hs-identifier hs-var">reduction</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-415"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525798"><span class="annot"><span class="annottext">DoubleOrnament
</span><a href="#local-6989586621679525798"><span class="hs-identifier hs-var">orn</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525797"><span class="annot"><span class="annottext">Edge n
</span><a href="#local-6989586621679525797"><span class="hs-identifier hs-var">parent</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a b c d. a -&gt; Elaboration a b c d
</span><a href="PVGrammar.Parse.html#EReg"><span class="hs-identifier hs-var">EReg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Edge n
</span><a href="#local-6989586621679525797"><span class="hs-identifier hs-var">parent</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525801"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">DoubleOrnament
</span><a href="#local-6989586621679525798"><span class="hs-identifier hs-var">orn</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-416"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-type">Pass</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525796"><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679525796"><span class="hs-identifier hs-var">pass</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525795"><span class="annot"><span class="annottext">InnerEdge n
</span><a href="#local-6989586621679525795"><span class="hs-identifier hs-var">parent</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a b c d. b -&gt; Elaboration a b c d
</span><a href="PVGrammar.Parse.html#EPass"><span class="hs-identifier hs-var">EPass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">InnerEdge n
</span><a href="#local-6989586621679525795"><span class="hs-identifier hs-var">parent</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525801"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679525796"><span class="hs-identifier hs-var">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-417"></span><span>  </span><span class="hs-comment">-- a non-terminal edge left and a terminal edge right: passing note</span><span>
</span><span id="line-418"></span><span>  </span><span class="annot"><a href="#local-6989586621679525864"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679525794"><span class="annot"><span class="annottext">notel :: EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525794"><span class="hs-identifier hs-var">notel</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-type">Pass</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679525793"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525793"><span class="hs-identifier hs-var">notem</span></a></span></span><span> </span><span id="local-6989586621679525792"><span class="annot"><span class="annottext">noter :: EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525792"><span class="hs-identifier hs-var">noter</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-419"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679525791"><span class="annot"><span class="annottext">InnerEdge n
</span><a href="#local-6989586621679525791"><span class="hs-identifier hs-var">parent</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525790"><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679525790"><span class="hs-identifier hs-var">pass</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall n.
IsNote n =&gt;
EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe (InnerEdge n, PassingOrnament)
</span><a href="PVGrammar.Parse.html#findPassing"><span class="hs-identifier hs-var">findPassing</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525794"><span class="hs-identifier hs-var">notel</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525793"><span class="hs-identifier hs-var">notem</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525792"><span class="hs-identifier hs-var">noter</span></a></span><span>
</span><span id="line-420"></span><span>    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b c d. b -&gt; Elaboration a b c d
</span><a href="PVGrammar.Parse.html#EPass"><span class="hs-identifier hs-var">EPass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">InnerEdge n
</span><a href="#local-6989586621679525791"><span class="hs-identifier hs-var">parent</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525793"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679525790"><span class="hs-identifier hs-var">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-421"></span><span>  </span><span class="hs-comment">-- a terminal edge left and a non-terminal edge right: passing note</span><span>
</span><span id="line-422"></span><span>  </span><span class="annot"><a href="#local-6989586621679525864"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679525789"><span class="annot"><span class="annottext">notel :: EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525789"><span class="hs-identifier hs-var">notel</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679525788"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525788"><span class="hs-identifier hs-var">notem</span></a></span></span><span> </span><span id="local-6989586621679525787"><span class="annot"><span class="annottext">noter :: EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525787"><span class="hs-identifier hs-var">noter</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-type">Pass</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-423"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679525786"><span class="annot"><span class="annottext">InnerEdge n
</span><a href="#local-6989586621679525786"><span class="hs-identifier hs-var">parent</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525785"><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679525785"><span class="hs-identifier hs-var">pass</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall n.
IsNote n =&gt;
EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe (InnerEdge n, PassingOrnament)
</span><a href="PVGrammar.Parse.html#findPassing"><span class="hs-identifier hs-var">findPassing</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525789"><span class="hs-identifier hs-var">notel</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525788"><span class="hs-identifier hs-var">notem</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525787"><span class="hs-identifier hs-var">noter</span></a></span><span>
</span><span id="line-424"></span><span>    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b c d. b -&gt; Elaboration a b c d
</span><a href="PVGrammar.Parse.html#EPass"><span class="hs-identifier hs-var">EPass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">InnerEdge n
</span><a href="#local-6989586621679525786"><span class="hs-identifier hs-var">parent</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525788"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679525785"><span class="hs-identifier hs-var">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-425"></span><span>  </span><span class="hs-comment">-- all other combinations are forbidden</span><span>
</span><span id="line-426"></span><span>  </span><span class="annot"><a href="#local-6989586621679525864"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-427"></span><span>
</span><span id="line-428"></span><span>  </span><span class="hs-comment">-- single reduction to a left parent</span><span>
</span><span id="line-429"></span><span>  </span><span id="local-6989586621679525859"><span class="annot"><span class="annottext">tryLeftReduction :: a
-&gt; EdgeEither (StartStop a) b
-&gt; Maybe (Elaboration a b (a, (a, RightOrnament)) d)
</span><a href="#local-6989586621679525859"><span class="hs-identifier hs-var hs-var">tryLeftReduction</span></a></span></span><span> </span><span id="local-6989586621679525775"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525775"><span class="hs-identifier hs-var">notem</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679525774"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525774"><span class="hs-identifier hs-var">notel</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-430"></span><span>    </span><span id="local-6989586621679525773"><span class="annot"><span class="annottext">RightOrnament
</span><a href="#local-6989586621679525773"><span class="hs-identifier hs-var">orn</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall n. IsNote n =&gt; n -&gt; n -&gt; Maybe RightOrnament
</span><a href="PVGrammar.Parse.html#findRightOrnament"><span class="hs-identifier hs-var">findRightOrnament</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525774"><span class="hs-identifier hs-var">notel</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525775"><span class="hs-identifier hs-var">notem</span></a></span><span>
</span><span id="line-431"></span><span>    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b c d. c -&gt; Elaboration a b c d
</span><a href="PVGrammar.Parse.html#ER"><span class="hs-identifier hs-var">ER</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525774"><span class="hs-identifier hs-var">notel</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525775"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">RightOrnament
</span><a href="#local-6989586621679525773"><span class="hs-identifier hs-var">orn</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-432"></span><span>  </span><span class="annot"><a href="#local-6989586621679525859"><span class="hs-identifier hs-var">tryLeftReduction</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop a) b
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-433"></span><span>
</span><span id="line-434"></span><span>  </span><span class="hs-comment">-- single reduction to a right parent</span><span>
</span><span id="line-435"></span><span>  </span><span id="local-6989586621679525848"><span class="annot"><span class="annottext">tryRightReduction :: a
-&gt; EdgeEither (StartStop a) b
-&gt; Maybe (Elaboration a b c (a, (a, LeftOrnament)))
</span><a href="#local-6989586621679525848"><span class="hs-identifier hs-var hs-var">tryRightReduction</span></a></span></span><span> </span><span id="local-6989586621679525763"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525763"><span class="hs-identifier hs-var">notem</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679525762"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525762"><span class="hs-identifier hs-var">noter</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-436"></span><span>    </span><span id="local-6989586621679525761"><span class="annot"><span class="annottext">LeftOrnament
</span><a href="#local-6989586621679525761"><span class="hs-identifier hs-var">orn</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall n. IsNote n =&gt; n -&gt; n -&gt; Maybe LeftOrnament
</span><a href="PVGrammar.Parse.html#findLeftOrnament"><span class="hs-identifier hs-var">findLeftOrnament</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525763"><span class="hs-identifier hs-var">notem</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525762"><span class="hs-identifier hs-var">noter</span></a></span><span>
</span><span id="line-437"></span><span>    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b c d. d -&gt; Elaboration a b c d
</span><a href="PVGrammar.Parse.html#EL"><span class="hs-identifier hs-var">EL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525762"><span class="hs-identifier hs-var">noter</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525763"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">LeftOrnament
</span><a href="#local-6989586621679525761"><span class="hs-identifier hs-var">orn</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-438"></span><span>  </span><span class="annot"><a href="#local-6989586621679525848"><span class="hs-identifier hs-var">tryRightReduction</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop a) b
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-439"></span><span>
</span><span id="line-440"></span><span>
</span><span id="line-441"></span><span>  </span><span class="hs-comment">-- compute all possible combinations of reduction options</span><span>
</span><span id="line-442"></span><span>  </span><span id="local-6989586621679525921"><span class="annot"><span class="annottext">getCombinations :: p -&gt; t [([a], [a], [a], [a])] -&gt; MaybeT IO ([a], [a], [a], [a])
</span><a href="#local-6989586621679525921"><span class="hs-identifier hs-var hs-var">getCombinations</span></a></span></span><span> </span><span id="local-6989586621679525741"><span class="annot"><span class="annottext">p
</span><a href="#local-6989586621679525741"><span class="hs-identifier hs-var">mgen</span></a></span></span><span> </span><span id="local-6989586621679525740"><span class="annot"><span class="annottext">t [([a], [a], [a], [a])]
</span><a href="#local-6989586621679525740"><span class="hs-identifier hs-var">options</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-443"></span><span>    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *). Alternative f =&gt; Bool -&gt; f ()
</span><span class="hs-identifier hs-var">guard</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">any</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">L.null</span></span><span> </span><span class="annot"><span class="annottext">t [([a], [a], [a], [a])]
</span><a href="#local-6989586621679525740"><span class="hs-identifier hs-var">options</span></a></span><span>
</span><span id="line-444"></span><span>    </span><span class="annot"><span class="annottext">forall g slc. StatefulGen g IO =&gt; g -&gt; [slc] -&gt; MaybeT IO slc
</span><a href="Probability.html#pickRandomChoice"><span class="hs-identifier hs-var">pickRandomChoice</span></a></span><span> </span><span class="annot"><span class="annottext">p
</span><a href="#local-6989586621679525741"><span class="hs-identifier hs-var">mgen</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (m :: * -&gt; *) b a.
(Foldable t, Monad m) =&gt;
(b -&gt; a -&gt; m b) -&gt; b -&gt; t a -&gt; m b
</span><span class="hs-identifier hs-var">foldM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall {m :: * -&gt; *} {a} {b} {c} {d} {p}.
(Monad m, Semigroup a, Semigroup b, Semigroup c, Semigroup d) =&gt;
p -&gt; (a, b, c, d) -&gt; m (a, b, c, d) -&gt; m (a, b, c, d)
</span><a href="#local-6989586621679525736"><span class="hs-identifier hs-var">pickOption</span></a></span><span> </span><span class="annot"><span class="annottext">p
</span><a href="#local-6989586621679525741"><span class="hs-identifier hs-var">mgen</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">t [([a], [a], [a], [a])]
</span><a href="#local-6989586621679525740"><span class="hs-identifier hs-var">options</span></a></span><span> </span><span class="hs-comment">-- otherwise, compute all combinations</span><span>
</span><span id="line-445"></span><span>
</span><span id="line-446"></span><span>  </span><span class="hs-comment">-- picks all different options for a single note in the list monad</span><span>
</span><span id="line-447"></span><span>  </span><span id="local-6989586621679525736"><span class="annot"><span class="annottext">pickOption :: p -&gt; (a, b, c, d) -&gt; m (a, b, c, d) -&gt; m (a, b, c, d)
</span><a href="#local-6989586621679525736"><span class="hs-identifier hs-var hs-var">pickOption</span></a></span></span><span> </span><span id="local-6989586621679525722"><span class="annot"><span class="annottext">p
</span><a href="#local-6989586621679525722"><span class="hs-identifier hs-var">mgen</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525721"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525721"><span class="hs-identifier hs-var">accReg</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525720"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679525720"><span class="hs-identifier hs-var">accPass</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525719"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679525719"><span class="hs-identifier hs-var">accL</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525718"><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679525718"><span class="hs-identifier hs-var">accR</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679525717"><span class="annot"><span class="annottext">m (a, b, c, d)
</span><a href="#local-6989586621679525717"><span class="hs-identifier hs-var">opts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-448"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679525716"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525716"><span class="hs-identifier hs-var">regs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525715"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679525715"><span class="hs-identifier hs-var">pass</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525714"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679525714"><span class="hs-identifier hs-var">ls</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525713"><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679525713"><span class="hs-identifier hs-var">rs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m (a, b, c, d)
</span><a href="#local-6989586621679525717"><span class="hs-identifier hs-var">opts</span></a></span><span>
</span><span id="line-449"></span><span>    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525716"><span class="hs-identifier hs-var">regs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525721"><span class="hs-identifier hs-var">accReg</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679525715"><span class="hs-identifier hs-var">pass</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679525720"><span class="hs-identifier hs-var">accPass</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679525714"><span class="hs-identifier hs-var">ls</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679525719"><span class="hs-identifier hs-var">accL</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679525713"><span class="hs-identifier hs-var">rs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679525718"><span class="hs-identifier hs-var">accR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-450"></span><span>
</span><span id="line-451"></span><span>  </span><span class="hs-comment">-- convert a combination into a derivation operation:</span><span>
</span><span id="line-452"></span><span>  </span><span class="hs-comment">-- turn the accumulated information into the format expected from the evaluator</span><span>
</span><span id="line-453"></span><span>  </span><span id="local-6989586621679525920"><span class="annot"><span class="annottext">mkTop :: ([(Edge n, (n, DoubleOrnament))],
 [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
 [(n, (n, LeftOrnament))])
-&gt; (Edges n, Split n)
</span><a href="#local-6989586621679525920"><span class="hs-identifier hs-var hs-var">mkTop</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525712"><span class="annot"><span class="annottext">[(Edge n, (n, DoubleOrnament))]
</span><a href="#local-6989586621679525712"><span class="hs-identifier hs-var">regs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525711"><span class="annot"><span class="annottext">[(InnerEdge n, (n, PassingOrnament))]
</span><a href="#local-6989586621679525711"><span class="hs-identifier hs-var">pass</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525710"><span class="annot"><span class="annottext">[(n, (n, RightOrnament))]
</span><a href="#local-6989586621679525710"><span class="hs-identifier hs-var">rs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525709"><span class="annot"><span class="annottext">[(n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525709"><span class="hs-identifier hs-var">ls</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-454"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="hs-comment">-- validate</span><span>
</span><span id="line-455"></span><span>      </span><span class="hs-keyword">then</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679525708"><span class="hs-identifier hs-var">top</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall n.
Map (Edge n) [(n, DoubleOrnament)]
-&gt; Map (InnerEdge n) [(n, PassingOrnament)]
-&gt; Map n [(n, RightOrnament)]
-&gt; Map n [(n, LeftOrnament)]
-&gt; HashSet (Edge n)
-&gt; HashSet (Edge n)
-&gt; MultiSet (InnerEdge n)
-&gt; MultiSet (InnerEdge n)
-&gt; Split n
</span><a href="PVGrammar.html#SplitOp"><span class="hs-identifier hs-var">SplitOp</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Edge n) [(n, DoubleOrnament)]
</span><a href="#local-6989586621679525706"><span class="hs-identifier hs-var">tmap</span></a></span><span> </span><span class="annot"><span class="annottext">Map (InnerEdge n) [(n, PassingOrnament)]
</span><a href="#local-6989586621679525705"><span class="hs-identifier hs-var">ntmap</span></a></span><span> </span><span class="annot"><span class="annottext">Map n [(n, RightOrnament)]
</span><a href="#local-6989586621679525704"><span class="hs-identifier hs-var">rmap</span></a></span><span> </span><span class="annot"><span class="annottext">Map n [(n, LeftOrnament)]
</span><a href="#local-6989586621679525703"><span class="hs-identifier hs-var">lmap</span></a></span><span> </span><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679525933"><span class="hs-identifier hs-var">leftRegs</span></a></span><span> </span><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679525930"><span class="hs-identifier hs-var">rightRegs</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525702"><span class="hs-identifier hs-var">passL</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525701"><span class="hs-identifier hs-var">passR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-456"></span><span>      </span><span class="hs-keyword">else</span><span>
</span><span id="line-457"></span><span>        </span><span class="annot"><span class="annottext">forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-458"></span><span>          </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;invalid unsplit:\n  notesl=&quot;</span></span><span>
</span><span id="line-459"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679525935"><span class="hs-identifier hs-var">notesl</span></a></span><span>
</span><span id="line-460"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n  notesr=&quot;</span></span><span>
</span><span id="line-461"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679525928"><span class="hs-identifier hs-var">notesr</span></a></span><span>
</span><span id="line-462"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n  notesm=&quot;</span></span><span>
</span><span id="line-463"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall n. MultiSet n -&gt; Notes n
</span><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-var">Notes</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679525931"><span class="hs-identifier hs-var">notesm</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-464"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n  left=&quot;</span></span><span>
</span><span id="line-465"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall n. HashSet (Edge n) -&gt; MultiSet (InnerEdge n) -&gt; Edges n
</span><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-var">Edges</span></a></span><span> </span><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679525933"><span class="hs-identifier hs-var">leftRegs</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525932"><span class="hs-identifier hs-var">leftPass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-466"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n  right=&quot;</span></span><span>
</span><span id="line-467"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall n. HashSet (Edge n) -&gt; MultiSet (InnerEdge n) -&gt; Edges n
</span><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-var">Edges</span></a></span><span> </span><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679525930"><span class="hs-identifier hs-var">rightRegs</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525929"><span class="hs-identifier hs-var">rightPass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-468"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n  top=&quot;</span></span><span>
</span><span id="line-469"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679525708"><span class="hs-identifier hs-var">top</span></a></span><span>
</span><span id="line-470"></span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-471"></span><span>    </span><span class="hs-comment">-- validate =</span><span>
</span><span id="line-472"></span><span>    </span><span class="hs-comment">--   all ((`L.elem` innerNotes notesl) . fst . fst) regs</span><span>
</span><span id="line-473"></span><span>    </span><span class="hs-comment">--     &amp;&amp; all ((`L.elem` innerNotes notesr) . snd . fst)   regs</span><span>
</span><span id="line-474"></span><span>    </span><span class="hs-comment">--     &amp;&amp; all ((`L.elem` innerNotes notesl) . Inner . fst) rs</span><span>
</span><span id="line-475"></span><span>    </span><span class="hs-comment">--     &amp;&amp; all ((`L.elem` innerNotes notesr) . Inner . fst) ls</span><span>
</span><span id="line-476"></span><span>
</span><span id="line-477"></span><span>    </span><span class="hs-comment">-- collect all operations</span><span>
</span><span id="line-478"></span><span>    </span><span id="local-6989586621679525693"><span class="annot"><span class="annottext">mapify :: [(k, a)] -&gt; Map k [a]
</span><a href="#local-6989586621679525693"><span class="hs-identifier hs-var hs-var">mapify</span></a></span></span><span> </span><span id="local-6989586621679525692"><span class="annot"><span class="annottext">[(k, a)]
</span><a href="#local-6989586621679525692"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; (a -&gt; a -&gt; a) -&gt; [(k, a)] -&gt; Map k a
</span><span class="hs-identifier hs-var">M.fromListWith</span></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">(&lt;&gt;)</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[(k, a)]
</span><a href="#local-6989586621679525692"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-479"></span><span>    </span><span id="local-6989586621679525706"><span class="annot"><span class="annottext">tmap :: Map (Edge n) [(n, DoubleOrnament)]
</span><a href="#local-6989586621679525706"><span class="hs-identifier hs-var hs-var">tmap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall {k} {a}. Ord k =&gt; [(k, a)] -&gt; Map k [a]
</span><a href="#local-6989586621679525693"><span class="hs-identifier hs-var">mapify</span></a></span><span> </span><span class="annot"><span class="annottext">[(Edge n, (n, DoubleOrnament))]
</span><a href="#local-6989586621679525712"><span class="hs-identifier hs-var">regs</span></a></span><span>
</span><span id="line-480"></span><span>    </span><span id="local-6989586621679525705"><span class="annot"><span class="annottext">ntmap :: Map (InnerEdge n) [(n, PassingOrnament)]
</span><a href="#local-6989586621679525705"><span class="hs-identifier hs-var hs-var">ntmap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall {k} {a}. Ord k =&gt; [(k, a)] -&gt; Map k [a]
</span><a href="#local-6989586621679525693"><span class="hs-identifier hs-var">mapify</span></a></span><span> </span><span class="annot"><span class="annottext">[(InnerEdge n, (n, PassingOrnament))]
</span><a href="#local-6989586621679525711"><span class="hs-identifier hs-var">pass</span></a></span><span>
</span><span id="line-481"></span><span>    </span><span id="local-6989586621679525703"><span class="annot"><span class="annottext">lmap :: Map n [(n, LeftOrnament)]
</span><a href="#local-6989586621679525703"><span class="hs-identifier hs-var hs-var">lmap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall {k} {a}. Ord k =&gt; [(k, a)] -&gt; Map k [a]
</span><a href="#local-6989586621679525693"><span class="hs-identifier hs-var">mapify</span></a></span><span> </span><span class="annot"><span class="annottext">[(n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525709"><span class="hs-identifier hs-var">ls</span></a></span><span>
</span><span id="line-482"></span><span>    </span><span id="local-6989586621679525704"><span class="annot"><span class="annottext">rmap :: Map n [(n, RightOrnament)]
</span><a href="#local-6989586621679525704"><span class="hs-identifier hs-var hs-var">rmap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall {k} {a}. Ord k =&gt; [(k, a)] -&gt; Map k [a]
</span><a href="#local-6989586621679525693"><span class="hs-identifier hs-var">mapify</span></a></span><span> </span><span class="annot"><span class="annottext">[(n, (n, RightOrnament))]
</span><a href="#local-6989586621679525710"><span class="hs-identifier hs-var">rs</span></a></span><span>
</span><span id="line-483"></span><span>    </span><span id="local-6989586621679525708"><span class="annot"><span class="annottext">top :: Edges n
</span><a href="#local-6989586621679525708"><span class="hs-identifier hs-var hs-var">top</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall n. HashSet (Edge n) -&gt; MultiSet (InnerEdge n) -&gt; Edges n
</span><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-var">Edges</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; [a] -&gt; HashSet a
</span><span class="hs-identifier hs-var">S.fromList</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[(Edge n, (n, DoubleOrnament))]
</span><a href="#local-6989586621679525712"><span class="hs-identifier hs-var">regs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a.
(Foldable t, Eq a, Hashable a) =&gt;
t a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#fromList"><span class="hs-identifier hs-var">MS.fromList</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[(InnerEdge n, (n, PassingOrnament))]
</span><a href="#local-6989586621679525711"><span class="hs-identifier hs-var">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-484"></span><span>    </span><span id="local-6989586621679525702"><span class="annot"><span class="annottext">passL :: MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525702"><span class="hs-identifier hs-var hs-var">passL</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#delete"><span class="hs-identifier hs-var">MS.delete</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525932"><span class="hs-identifier hs-var">leftPass</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">forall {a} {b} {b}. ((a, b), (b, PassingOrnament)) -&gt; Maybe (a, b)
</span><a href="#local-6989586621679525687"><span class="hs-identifier hs-var">leftPassingChild</span></a></span><span> </span><span class="annot"><span class="annottext">[(InnerEdge n, (n, PassingOrnament))]
</span><a href="#local-6989586621679525711"><span class="hs-identifier hs-var">pass</span></a></span><span>
</span><span id="line-485"></span><span>    </span><span id="local-6989586621679525701"><span class="annot"><span class="annottext">passR :: MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525701"><span class="hs-identifier hs-var hs-var">passR</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#delete"><span class="hs-identifier hs-var">MS.delete</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525929"><span class="hs-identifier hs-var">rightPass</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">forall {a} {b} {a}. ((a, b), (a, PassingOrnament)) -&gt; Maybe (a, b)
</span><a href="#local-6989586621679525686"><span class="hs-identifier hs-var">rightPassingChild</span></a></span><span> </span><span class="annot"><span class="annottext">[(InnerEdge n, (n, PassingOrnament))]
</span><a href="#local-6989586621679525711"><span class="hs-identifier hs-var">pass</span></a></span><span>
</span><span id="line-486"></span><span>    </span><span id="local-6989586621679525687"><span class="annot"><span class="annottext">leftPassingChild :: ((a, b), (b, PassingOrnament)) -&gt; Maybe (a, b)
</span><a href="#local-6989586621679525687"><span class="hs-identifier hs-var hs-var">leftPassingChild</span></a></span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span id="local-6989586621679525683"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525683"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525682"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679525682"><span class="hs-identifier hs-var">_r</span></a></span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525681"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679525681"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525680"><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679525680"><span class="hs-identifier hs-var">orn</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-487"></span><span>      </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679525680"><span class="hs-identifier hs-var">orn</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="PVGrammar.html#PassingRight"><span class="hs-identifier hs-var">PassingRight</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525683"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679525681"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-488"></span><span>    </span><span id="local-6989586621679525686"><span class="annot"><span class="annottext">rightPassingChild :: ((a, b), (a, PassingOrnament)) -&gt; Maybe (a, b)
</span><a href="#local-6989586621679525686"><span class="hs-identifier hs-var hs-var">rightPassingChild</span></a></span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span id="local-6989586621679525678"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525678"><span class="hs-identifier hs-var">_l</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525677"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679525677"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525676"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525676"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525675"><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679525675"><span class="hs-identifier hs-var">orn</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-489"></span><span>      </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679525675"><span class="hs-identifier hs-var">orn</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="PVGrammar.html#PassingLeft"><span class="hs-identifier hs-var">PassingLeft</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525676"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679525677"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-490"></span><span>
</span><span id="line-491"></span><span>  </span><span class="hs-comment">-- undefined </span><span>
</span><span id="line-492"></span><span class="hs-comment">-- do</span><span>
</span><span id="line-493"></span><span class="hs-comment">--   gen &lt;- initStdGen</span><span>
</span><span id="line-494"></span><span class="hs-comment">--   mgen &lt;- newIOGenM gen</span><span>
</span><span id="line-495"></span><span class="hs-comment">--   collectRandomChoice mgen $ enumerateAll mgen </span><span>
</span><span id="line-496"></span><span class="hs-comment">--   -- pure $ map mkTop combinations</span><span>
</span><span id="line-497"></span><span class="hs-comment">--  where</span><span>
</span><span id="line-498"></span><span class="hs-comment">--   enumerateAll mgen = do  </span><span>
</span><span id="line-499"></span><span class="hs-comment">--     options &lt;- evalOptions mgen </span><span>
</span><span id="line-500"></span><span class="hs-comment">--     combinations &lt;- evalCombinations mgen options</span><span>
</span><span id="line-501"></span><span class="hs-comment">--     let res = map mkTop combinations</span><span>
</span><span id="line-502"></span><span class="hs-comment">--     pickRandomChoice mgen res</span><span>
</span><span id="line-503"></span><span class="hs-comment">--     -- pickRandomChoice mgen $ </span><span>
</span><span id="line-504"></span><span class="hs-comment">--</span><span>
</span><span id="line-505"></span><span class="hs-comment">--   -- preprocessing of the notes left and right of the unsplit</span><span>
</span><span id="line-506"></span><span class="hs-comment">--   !innerL = Reg &lt;$&gt; innerNotes notesl</span><span>
</span><span id="line-507"></span><span class="hs-comment">--   !innerR = Reg &lt;$&gt; innerNotes notesr</span><span>
</span><span id="line-508"></span><span class="hs-comment">--</span><span>
</span><span id="line-509"></span><span class="hs-comment">--   -- find all reduction options for every pitch</span><span>
</span><span id="line-510"></span><span class="hs-comment">--   -- evalOptions </span><span>
</span><span id="line-511"></span><span class="hs-comment">--   --   :: StatefulGen g IO </span><span>
</span><span id="line-512"></span><span class="hs-comment">--   --   =&gt; g </span><span>
</span><span id="line-513"></span><span class="hs-comment">--   --   -&gt; MaybeT IO</span><span>
</span><span id="line-514"></span><span class="hs-comment">--   --      [([(Edge n, (n, DoubleOrnament))],</span><span>
</span><span id="line-515"></span><span class="hs-comment">--   --        [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],</span><span>
</span><span id="line-516"></span><span class="hs-comment">--   --        [(n, (n, LeftOrnament))])]</span><span>
</span><span id="line-517"></span><span class="hs-comment">--   evalOptions mgen = do </span><span>
</span><span id="line-518"></span><span class="hs-comment">--      pickRandomChoice mgen $ mapM (evalNoteOptions mgen) $ MS.toOccurList notesm</span><span>
</span><span id="line-519"></span><span class="hs-comment">--</span><span>
</span><span id="line-520"></span><span class="hs-comment">--   -- evalNoteOptions </span><span>
</span><span id="line-521"></span><span class="hs-comment">--   --   :: StatefulGen g IO =&gt; g</span><span>
</span><span id="line-522"></span><span class="hs-comment">--   --   -&gt; (n, Int)</span><span>
</span><span id="line-523"></span><span class="hs-comment">--   --   -&gt; MaybeT IO ([(Edge n, (n, DoubleOrnament))],</span><span>
</span><span id="line-524"></span><span class="hs-comment">--   --        [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],</span><span>
</span><span id="line-525"></span><span class="hs-comment">--   --        [(n, (n, LeftOrnament))])</span><span>
</span><span id="line-526"></span><span class="hs-comment">--   evalNoteOptions mgen (note, nocc) = do </span><span>
</span><span id="line-527"></span><span class="hs-comment">--     guard (nocc &lt; MS.size mandatoryLeft || nocc &lt; MS.size mandatoryRight )</span><span>
</span><span id="line-528"></span><span class="hs-comment">--     allOps &lt;- enumerateOptions mgen mandatoryLeft mandatoryRight nocc</span><span>
</span><span id="line-529"></span><span class="hs-comment">--     pickRandomChoice mgen $ partitionElaborations &lt;$&gt; [allOps]</span><span>
</span><span id="line-530"></span><span class="hs-comment">--     -- pure $  partitionElaborations &lt;$&gt; allOps</span><span>
</span><span id="line-531"></span><span class="hs-comment">--    where</span><span>
</span><span id="line-532"></span><span class="hs-comment">--     -- compute the mandatory edges for the current pitch:</span><span>
</span><span id="line-533"></span><span class="hs-comment">--     mleftRegs = S.map (Reg . fst) $ S.filter ((== Inner note) . snd) leftRegs</span><span>
</span><span id="line-534"></span><span class="hs-comment">--     mleftPass = MS.map (Pass . fst) $ MS.filter ((== note) . snd) leftPass</span><span>
</span><span id="line-535"></span><span class="hs-comment">--     mrightRegs = S.map (Reg . snd) $ S.filter ((== Inner note) . fst) rightRegs</span><span>
</span><span id="line-536"></span><span class="hs-comment">--     mrightPass = MS.map (Pass . snd) $ MS.filter ((== note) . fst) rightPass</span><span>
</span><span id="line-537"></span><span class="hs-comment">--     mandatoryLeft = MS.fromSet mleftRegs &lt;&gt; mleftPass</span><span>
</span><span id="line-538"></span><span class="hs-comment">--     mandatoryRight = MS.fromSet mrightRegs &lt;&gt; mrightPass</span><span>
</span><span id="line-539"></span><span class="hs-comment">--</span><span>
</span><span id="line-540"></span><span class="hs-comment">--     -- the possible reductions of a (multiple) pitch are enumerated in three stages:</span><span>
</span><span id="line-541"></span><span class="hs-comment">--</span><span>
</span><span id="line-542"></span><span class="hs-comment">--     -- stage 1: consume all mandatory edges on the left</span><span>
</span><span id="line-543"></span><span class="hs-comment">--     enumerateOptions mgen ml mr n = do</span><span>
</span><span id="line-544"></span><span class="hs-comment">--       (mr', n', acc) &lt;- pickRandomChoice mgen $ MS.foldM goL (mr, n, []) ml</span><span>
</span><span id="line-545"></span><span class="hs-comment">--       (n'', acc') &lt;- pickRandomChoice mgen $ MS.foldM goR (n', acc) mr'</span><span>
</span><span id="line-546"></span><span class="hs-comment">--       freeOpts &lt;- freeOptions mgen</span><span>
</span><span id="line-547"></span><span class="hs-comment">--       goFree mgen [freeOpts] n'' acc'</span><span>
</span><span id="line-548"></span><span class="hs-comment">--     goL (_, 0, _) _ = []</span><span>
</span><span id="line-549"></span><span class="hs-comment">--     goL (mr, n, acc) l = do</span><span>
</span><span id="line-550"></span><span class="hs-comment">--       (new, mr') &lt;- pickLeft n l mr</span><span>
</span><span id="line-551"></span><span class="hs-comment">--       pure (mr', n - 1, new : acc)</span><span>
</span><span id="line-552"></span><span class="hs-comment">--     -- combine a mandatory left with a mandatory right or free right edge</span><span>
</span><span id="line-553"></span><span class="hs-comment">--     pickLeft n l mr</span><span>
</span><span id="line-554"></span><span class="hs-comment">--       | n &gt; MS.size mr = mand &lt;&gt; opt &lt;&gt; single</span><span>
</span><span id="line-555"></span><span class="hs-comment">--       | otherwise = mand</span><span>
</span><span id="line-556"></span><span class="hs-comment">--      where</span><span>
</span><span id="line-557"></span><span class="hs-comment">--       mand = do</span><span>
</span><span id="line-558"></span><span class="hs-comment">--         r &lt;- MS.distinctElems mr</span><span>
</span><span id="line-559"></span><span class="hs-comment">--         red &lt;- maybeToList $ tryReduction True True l note r</span><span>
</span><span id="line-560"></span><span class="hs-comment">--         pure (red, MS.delete r mr)</span><span>
</span><span id="line-561"></span><span class="hs-comment">--       -- TODO: remove mr options here?</span><span>
</span><span id="line-562"></span><span class="hs-comment">--       tryOpt r = tryReduction True (r `S.member` mrightRegs) l note r</span><span>
</span><span id="line-563"></span><span class="hs-comment">--       opt = (,mr) &lt;$&gt; mapMaybe tryOpt innerR</span><span>
</span><span id="line-564"></span><span class="hs-comment">--       single = fmap (,mr) $ maybeToList $ tryLeftReduction note l</span><span>
</span><span id="line-565"></span><span class="hs-comment">--</span><span>
</span><span id="line-566"></span><span class="hs-comment">--     -- stage 2: consume all remaining mandatory edges on the right</span><span>
</span><span id="line-567"></span><span class="hs-comment">--     goR (0, _) _ = []</span><span>
</span><span id="line-568"></span><span class="hs-comment">--     goR (n, acc) r = do</span><span>
</span><span id="line-569"></span><span class="hs-comment">--       new &lt;- pickRight r</span><span>
</span><span id="line-570"></span><span class="hs-comment">--       pure (n - 1, new : acc)</span><span>
</span><span id="line-571"></span><span class="hs-comment">--     -- combine mandatory right with free left edge</span><span>
</span><span id="line-572"></span><span class="hs-comment">--     pickRight r = opt &lt;&gt; single</span><span>
</span><span id="line-573"></span><span class="hs-comment">--      where</span><span>
</span><span id="line-574"></span><span class="hs-comment">--       tryOpt l = tryReduction (l `S.member` mleftRegs) True l note r</span><span>
</span><span id="line-575"></span><span class="hs-comment">--       opt = mapMaybe tryOpt innerL</span><span>
</span><span id="line-576"></span><span class="hs-comment">--       single = maybeToList $ tryRightReduction note r</span><span>
</span><span id="line-577"></span><span class="hs-comment">--</span><span>
</span><span id="line-578"></span><span class="hs-comment">--     -- stage 3: explain all remaining notes through a combination of unknown edges</span><span>
</span><span id="line-579"></span><span class="hs-comment">--     goFree mgen _ 0 acc = pickRandomChoice mgen acc</span><span>
</span><span id="line-580"></span><span class="hs-comment">--     goFree mgen [] _ _ = pickRandomChoice mgen []</span><span>
</span><span id="line-581"></span><span class="hs-comment">--     goFree mgen [lastOpt] n acc = pickRandomChoice mgen $ L.replicate n lastOpt &lt;&gt; acc</span><span>
</span><span id="line-582"></span><span class="hs-comment">--     goFree mgen (opt : opts) n acc = do</span><span>
</span><span id="line-583"></span><span class="hs-comment">--       nopt &lt;- pickRandomChoice mgen [0 .. n]</span><span>
</span><span id="line-584"></span><span class="hs-comment">--       goFree mgen opts (n - nopt) (L.replicate nopt opt &lt;&gt; acc)</span><span>
</span><span id="line-585"></span><span class="hs-comment">--</span><span>
</span><span id="line-586"></span><span class="hs-comment">--     -- list all options for free reduction</span><span>
</span><span id="line-587"></span><span class="hs-comment">--     freeOptions mgen = do </span><span>
</span><span id="line-588"></span><span class="hs-comment">--       freeBoth &lt;- pickFreeBoth mgen </span><span>
</span><span id="line-589"></span><span class="hs-comment">--       freeLeft &lt;- pickFreeLeft mgen</span><span>
</span><span id="line-590"></span><span class="hs-comment">--       freeRight &lt;- pickFreeRight mgen </span><span>
</span><span id="line-591"></span><span class="hs-comment">--       pickRandomChoice mgen [freeBoth &lt;&gt; freeLeft &lt;&gt; freeRight]</span><span>
</span><span id="line-592"></span><span class="hs-comment">--     -- combine two free edges</span><span>
</span><span id="line-593"></span><span class="hs-comment">--     pickFreeBoth mgen = do</span><span>
</span><span id="line-594"></span><span class="hs-comment">--       l &lt;- pickRandomChoice mgen innerL</span><span>
</span><span id="line-595"></span><span class="hs-comment">--       r &lt;- pickRandomChoice mgen innerR</span><span>
</span><span id="line-596"></span><span class="hs-comment">--       pickRandomChoice mgen $ maybeToList $</span><span>
</span><span id="line-597"></span><span class="hs-comment">--         tryReduction (l `S.member` mleftRegs) (r `S.member` mrightRegs) l note r</span><span>
</span><span id="line-598"></span><span class="hs-comment">--     -- reduce to left using free edge</span><span>
</span><span id="line-599"></span><span class="hs-comment">--     pickFreeLeft mgen = do </span><span>
</span><span id="line-600"></span><span class="hs-comment">--       pickRandomChoice mgen $ mapMaybe (tryLeftReduction note) innerL</span><span>
</span><span id="line-601"></span><span class="hs-comment">--     -- reduce to right using free edge</span><span>
</span><span id="line-602"></span><span class="hs-comment">--     pickFreeRight mgen = do </span><span>
</span><span id="line-603"></span><span class="hs-comment">--       pickRandomChoice mgen $ mapMaybe (tryRightReduction note) innerR</span><span>
</span><span id="line-604"></span><span class="hs-comment">--</span><span>
</span><span id="line-605"></span><span class="hs-comment">--   -- at all stages: try out potential reductions:</span><span>
</span><span id="line-606"></span><span class="hs-comment">--</span><span>
</span><span id="line-607"></span><span class="hs-comment">--   -- two terminal edges: any ornament</span><span>
</span><span id="line-608"></span><span class="hs-comment">--   tryReduction lIsUsed rIsUsed (Reg notel) notem (Reg noter) = do</span><span>
</span><span id="line-609"></span><span class="hs-comment">--     reduction &lt;- findOrnament notel (Inner notem) noter lIsUsed rIsUsed</span><span>
</span><span id="line-610"></span><span class="hs-comment">--     pure $ case reduction of</span><span>
</span><span id="line-611"></span><span class="hs-comment">--       (Reg (orn, parent)) -&gt; EReg (parent, (notem, orn))</span><span>
</span><span id="line-612"></span><span class="hs-comment">--       (Pass (pass, parent)) -&gt; EPass (parent, (notem, pass))</span><span>
</span><span id="line-613"></span><span class="hs-comment">--   -- a non-terminal edge left and a terminal edge right: passing note</span><span>
</span><span id="line-614"></span><span class="hs-comment">--   tryReduction _ _ notel@(Pass _) notem noter@(Reg _) = do</span><span>
</span><span id="line-615"></span><span class="hs-comment">--     (parent, pass) &lt;- findPassing notel notem noter</span><span>
</span><span id="line-616"></span><span class="hs-comment">--     pure $ EPass (parent, (notem, pass))</span><span>
</span><span id="line-617"></span><span class="hs-comment">--   -- a terminal edge left and a non-terminal edge right: passing note</span><span>
</span><span id="line-618"></span><span class="hs-comment">--   tryReduction _ _ notel@(Reg _) notem noter@(Pass _) = do</span><span>
</span><span id="line-619"></span><span class="hs-comment">--     (parent, pass) &lt;- findPassing notel notem noter</span><span>
</span><span id="line-620"></span><span class="hs-comment">--     pure $ EPass (parent, (notem, pass))</span><span>
</span><span id="line-621"></span><span class="hs-comment">--   -- all other combinations are forbidden</span><span>
</span><span id="line-622"></span><span class="hs-comment">--   tryReduction _ _ _ _ _ = Nothing</span><span>
</span><span id="line-623"></span><span class="hs-comment">--</span><span>
</span><span id="line-624"></span><span class="hs-comment">--   -- single reduction to a left parent</span><span>
</span><span id="line-625"></span><span class="hs-comment">--   tryLeftReduction notem (Reg (Inner notel)) = do</span><span>
</span><span id="line-626"></span><span class="hs-comment">--     orn &lt;- findRightOrnament notel notem</span><span>
</span><span id="line-627"></span><span class="hs-comment">--     pure $ ER (notel, (notem, orn))</span><span>
</span><span id="line-628"></span><span class="hs-comment">--   tryLeftReduction _ _ = Nothing</span><span>
</span><span id="line-629"></span><span class="hs-comment">--</span><span>
</span><span id="line-630"></span><span class="hs-comment">--   -- single reduction to a right parent</span><span>
</span><span id="line-631"></span><span class="hs-comment">--   tryRightReduction notem (Reg (Inner noter)) = do</span><span>
</span><span id="line-632"></span><span class="hs-comment">--     orn &lt;- findLeftOrnament notem noter</span><span>
</span><span id="line-633"></span><span class="hs-comment">--     pure $ EL (noter, (notem, orn))</span><span>
</span><span id="line-634"></span><span class="hs-comment">--   tryRightReduction _ _ = Nothing</span><span>
</span><span id="line-635"></span><span class="hs-comment">--</span><span>
</span><span id="line-636"></span><span class="hs-comment">--   -- compute all possible combinations of reduction options</span><span>
</span><span id="line-637"></span><span class="hs-comment">--   evalCombinations mgen options = do </span><span>
</span><span id="line-638"></span><span class="hs-comment">--     guard $ any L.null options </span><span>
</span><span id="line-639"></span><span class="hs-comment">--     pickRandomChoice mgen $ foldM (pickOption mgen) ([], [], [], []) options -- otherwise, compute all combinations</span><span>
</span><span id="line-640"></span><span class="hs-comment">--       -- picks all different options for a single note in the list monad</span><span>
</span><span id="line-641"></span><span class="hs-comment">--   pickOption mgen (accReg, accPass, accL, accR) opts = do</span><span>
</span><span id="line-642"></span><span class="hs-comment">--     (regs, pass, ls, rs) &lt;- opts</span><span>
</span><span id="line-643"></span><span class="hs-comment">--     pure (regs &lt;&gt; accReg, pass &lt;&gt; accPass, ls &lt;&gt; accL, rs &lt;&gt; accR)</span><span>
</span><span id="line-644"></span><span class="hs-comment">--</span><span>
</span><span id="line-645"></span><span class="hs-comment">--   -- convert a combination into a derivation operation:</span><span>
</span><span id="line-646"></span><span class="hs-comment">--   -- turn the accumulated information into the format expected from the evaluator</span><span>
</span><span id="line-647"></span><span class="hs-comment">--   mkTop (regs, pass, rs, ls) =</span><span>
</span><span id="line-648"></span><span class="hs-comment">--     if True -- validate</span><span>
</span><span id="line-649"></span><span class="hs-comment">--       then (top, SplitOp tmap ntmap rmap lmap leftRegs rightRegs passL passR)</span><span>
</span><span id="line-650"></span><span class="hs-comment">--       else</span><span>
</span><span id="line-651"></span><span class="hs-comment">--         error $</span><span>
</span><span id="line-652"></span><span class="hs-comment">--           &quot;invalid unsplit:\n  notesl=&quot;</span><span>
</span><span id="line-653"></span><span class="hs-comment">--             &lt;&gt; show notesl</span><span>
</span><span id="line-654"></span><span class="hs-comment">--             &lt;&gt; &quot;\n  notesr=&quot;</span><span>
</span><span id="line-655"></span><span class="hs-comment">--             &lt;&gt; show notesr</span><span>
</span><span id="line-656"></span><span class="hs-comment">--             &lt;&gt; &quot;\n  notesm=&quot;</span><span>
</span><span id="line-657"></span><span class="hs-comment">--             &lt;&gt; show (Notes notesm)</span><span>
</span><span id="line-658"></span><span class="hs-comment">--             &lt;&gt; &quot;\n  left=&quot;</span><span>
</span><span id="line-659"></span><span class="hs-comment">--             &lt;&gt; show (Edges leftRegs leftPass)</span><span>
</span><span id="line-660"></span><span class="hs-comment">--             &lt;&gt; &quot;\n  right=&quot;</span><span>
</span><span id="line-661"></span><span class="hs-comment">--             &lt;&gt; show (Edges rightRegs rightPass)</span><span>
</span><span id="line-662"></span><span class="hs-comment">--             &lt;&gt; &quot;\n  top=&quot;</span><span>
</span><span id="line-663"></span><span class="hs-comment">--             &lt;&gt; show top</span><span>
</span><span id="line-664"></span><span class="hs-comment">--    where</span><span>
</span><span id="line-665"></span><span class="hs-comment">--     -- validate =</span><span>
</span><span id="line-666"></span><span class="hs-comment">--     --   all ((`L.elem` innerNotes notesl) . fst . fst) regs</span><span>
</span><span id="line-667"></span><span class="hs-comment">--     --     &amp;&amp; all ((`L.elem` innerNotes notesr) . snd . fst)   regs</span><span>
</span><span id="line-668"></span><span class="hs-comment">--     --     &amp;&amp; all ((`L.elem` innerNotes notesl) . Inner . fst) rs</span><span>
</span><span id="line-669"></span><span class="hs-comment">--     --     &amp;&amp; all ((`L.elem` innerNotes notesr) . Inner . fst) ls</span><span>
</span><span id="line-670"></span><span class="hs-comment">--</span><span>
</span><span id="line-671"></span><span class="hs-comment">--     -- collect all operations</span><span>
</span><span id="line-672"></span><span class="hs-comment">--     mapify xs = M.fromListWith (&lt;&gt;) $ fmap (: []) &lt;$&gt; xs</span><span>
</span><span id="line-673"></span><span class="hs-comment">--     tmap = mapify regs</span><span>
</span><span id="line-674"></span><span class="hs-comment">--     ntmap = mapify pass</span><span>
</span><span id="line-675"></span><span class="hs-comment">--     lmap = mapify ls</span><span>
</span><span id="line-676"></span><span class="hs-comment">--     rmap = mapify rs</span><span>
</span><span id="line-677"></span><span class="hs-comment">--     top = Edges (S.fromList (fst &lt;$&gt; regs)) (MS.fromList (fst &lt;$&gt; pass))</span><span>
</span><span id="line-678"></span><span class="hs-comment">--     passL = foldr MS.delete leftPass $ mapMaybe leftPassingChild pass</span><span>
</span><span id="line-679"></span><span class="hs-comment">--     passR = foldr MS.delete rightPass $ mapMaybe rightPassingChild pass</span><span>
</span><span id="line-680"></span><span class="hs-comment">--     leftPassingChild ((l, _r), (m, orn)) =</span><span>
</span><span id="line-681"></span><span class="hs-comment">--       if orn == PassingRight then Just (l, m) else Nothing</span><span>
</span><span id="line-682"></span><span class="hs-comment">--     rightPassingChild ((_l, r), (m, orn)) =</span><span>
</span><span id="line-683"></span><span class="hs-comment">--       if orn == PassingLeft then Just (m, r) else Nothing</span><span>
</span><span id="line-684"></span><span>
</span><span id="line-685"></span><span>
</span><span id="line-686"></span><span class="hs-comment">{- | Computes all possible unsplits of two child transitions.
 Since transitions here only represent the certain edges,
 'pvUnsplit' must also take into account unelaborated edges,
 which are not present in the child transitions.
-}</span><span>
</span><span id="line-691"></span><span id="local-6989586621679527041"><span class="annot"><a href="PVGrammar.Parse.html#pvUnsplit"><span class="hs-identifier hs-type">pvUnsplit</span></a></span><span>
</span><span id="line-692"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527041"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679527041"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679527041"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679527041"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-693"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#StartStop"><span class="hs-identifier hs-type">StartStop</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527041"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-694"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527041"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-695"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527041"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-696"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527041"><span class="hs-identifier hs-type">n</span></a></span><span>
</span><span id="line-697"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Common.html#StartStop"><span class="hs-identifier hs-type">StartStop</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527041"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-698"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527041"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Split"><span class="hs-identifier hs-type">Split</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527041"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span></span><span>
</span><span id="line-699"></span><span id="pvUnsplit"><span class="annot"><span class="annottext">pvUnsplit :: forall n.
(IsNote n, Notation n, Ord n, Hashable n) =&gt;
StartStop (Notes n)
-&gt; Edges n
-&gt; Notes n
-&gt; Edges n
-&gt; StartStop (Notes n)
-&gt; [(Edges n, Split n)]
</span><a href="PVGrammar.Parse.html#pvUnsplit"><span class="hs-identifier hs-var hs-var">pvUnsplit</span></a></span></span><span> </span><span id="local-6989586621679525524"><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679525524"><span class="hs-identifier hs-var">notesl</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span id="local-6989586621679525523"><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679525523"><span class="hs-identifier hs-var">leftRegs</span></a></span></span><span> </span><span id="local-6989586621679525522"><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525522"><span class="hs-identifier hs-var">leftPass</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span id="local-6989586621679525521"><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679525521"><span class="hs-identifier hs-var">notesm</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span id="local-6989586621679525520"><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679525520"><span class="hs-identifier hs-var">rightRegs</span></a></span></span><span> </span><span id="local-6989586621679525519"><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525519"><span class="hs-identifier hs-var">rightPass</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679525518"><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679525518"><span class="hs-identifier hs-var">notesr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-700"></span><span>  </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">([(Edge n, (n, DoubleOrnament))],
 [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
 [(n, (n, LeftOrnament))])
-&gt; (Edges n, Split n)
</span><a href="#local-6989586621679525517"><span class="hs-identifier hs-var">mkTop</span></a></span><span> </span><span class="annot"><span class="annottext">[([(Edge n, (n, DoubleOrnament))],
  [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
  [(n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679525516"><span class="hs-identifier hs-var">combinations</span></a></span><span>
</span><span id="line-701"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-702"></span><span>  </span><span class="hs-comment">-- preprocessing of the notes left and right of the unsplit</span><span>
</span><span id="line-703"></span><span>  </span><span class="hs-glyph">!</span><span id="local-6989586621679525515"><span class="annot"><span class="annottext">innerL :: [EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679525515"><span class="hs-identifier hs-var hs-var">innerL</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall n. StartStop (Notes n) -&gt; [StartStop n]
</span><a href="PVGrammar.html#innerNotes"><span class="hs-identifier hs-var">innerNotes</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679525524"><span class="hs-identifier hs-var">notesl</span></a></span><span>
</span><span id="line-704"></span><span>  </span><span class="hs-glyph">!</span><span id="local-6989586621679525514"><span class="annot"><span class="annottext">innerR :: [EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679525514"><span class="hs-identifier hs-var hs-var">innerR</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall n. StartStop (Notes n) -&gt; [StartStop n]
</span><a href="PVGrammar.html#innerNotes"><span class="hs-identifier hs-var">innerNotes</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679525518"><span class="hs-identifier hs-var">notesr</span></a></span><span>
</span><span id="line-705"></span><span>
</span><span id="line-706"></span><span>  </span><span class="hs-comment">-- find all reduction options for every pitch</span><span>
</span><span id="line-707"></span><span>  </span><span class="hs-glyph">!</span><span id="local-6989586621679525513"><span class="annot"><span class="annottext">options :: [[([(Edge n, (n, DoubleOrnament))],
   [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
   [(n, (n, LeftOrnament))])]]
</span><a href="#local-6989586621679525513"><span class="hs-identifier hs-var hs-var">options</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(n, Int)
-&gt; [([(Edge n, (n, DoubleOrnament))],
     [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
     [(n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679525512"><span class="hs-identifier hs-var">noteOptions</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall k. MultiSet k -&gt; [(k, Int)]
</span><a href="Internal.MultiSet.html#toOccurList"><span class="hs-identifier hs-var">MS.toOccurList</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679525521"><span class="hs-identifier hs-var">notesm</span></a></span><span>
</span><span id="line-708"></span><span>  </span><span id="local-6989586621679525512"><span class="annot"><span class="annottext">noteOptions :: (n, Int)
-&gt; [([(Edge n, (n, DoubleOrnament))],
     [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
     [(n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679525512"><span class="hs-identifier hs-var hs-var">noteOptions</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525511"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525511"><span class="hs-identifier hs-var">note</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525510"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525510"><span class="hs-identifier hs-var">nocc</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-709"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525510"><span class="hs-identifier hs-var">nocc</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. MultiSet a -&gt; Int
</span><a href="Internal.MultiSet.html#size"><span class="hs-identifier hs-var">MS.size</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525509"><span class="hs-identifier hs-var">mandatoryLeft</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525510"><span class="hs-identifier hs-var">nocc</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. MultiSet a -&gt; Int
</span><a href="Internal.MultiSet.html#size"><span class="hs-identifier hs-var">MS.size</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525508"><span class="hs-identifier hs-var">mandatoryRight</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-710"></span><span>        </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-711"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-712"></span><span>        </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b c d.
Foldable t =&gt;
t (Elaboration a b c d) -&gt; ([a], [b], [c], [d])
</span><a href="PVGrammar.Parse.html#partitionElaborations"><span class="hs-identifier hs-var">partitionElaborations</span></a></span><span>
</span><span id="line-713"></span><span>          </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
-&gt; MultiSet (EdgeEither (StartStop n) n)
-&gt; Int
-&gt; [[Elaboration
       (Edge n, (n, DoubleOrnament))
       (InnerEdge n, (n, PassingOrnament))
       (n, (n, RightOrnament))
       (n, (n, LeftOrnament))]]
</span><a href="#local-6989586621679525507"><span class="hs-identifier hs-var">enumerateOptions</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525509"><span class="hs-identifier hs-var">mandatoryLeft</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525508"><span class="hs-identifier hs-var">mandatoryRight</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525510"><span class="hs-identifier hs-var">nocc</span></a></span><span>
</span><span id="line-714"></span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-715"></span><span>    </span><span class="hs-comment">-- compute the mandatory edges for the current pitch:</span><span>
</span><span id="line-716"></span><span>    </span><span id="local-6989586621679525506"><span class="annot"><span class="annottext">mleftRegs :: HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525506"><span class="hs-identifier hs-var hs-var">mleftRegs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall b a.
(Hashable b, Eq b) =&gt;
(a -&gt; b) -&gt; HashSet a -&gt; HashSet b
</span><span class="hs-identifier hs-var">S.map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; Bool) -&gt; HashSet a -&gt; HashSet a
</span><span class="hs-identifier hs-var">S.filter</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525511"><span class="hs-identifier hs-var">note</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679525523"><span class="hs-identifier hs-var">leftRegs</span></a></span><span>
</span><span id="line-717"></span><span>    </span><span id="local-6989586621679525505"><span class="annot"><span class="annottext">mleftPass :: MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525505"><span class="hs-identifier hs-var hs-var">mleftPass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall b a.
(Eq b, Hashable b) =&gt;
(a -&gt; b) -&gt; MultiSet a -&gt; MultiSet b
</span><a href="Internal.MultiSet.html#map"><span class="hs-identifier hs-var">MS.map</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. b -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-var">Pass</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; Bool) -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#filter"><span class="hs-identifier hs-var">MS.filter</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525511"><span class="hs-identifier hs-var">note</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525522"><span class="hs-identifier hs-var">leftPass</span></a></span><span>
</span><span id="line-718"></span><span>    </span><span id="local-6989586621679525504"><span class="annot"><span class="annottext">mrightRegs :: HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525504"><span class="hs-identifier hs-var hs-var">mrightRegs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall b a.
(Hashable b, Eq b) =&gt;
(a -&gt; b) -&gt; HashSet a -&gt; HashSet b
</span><span class="hs-identifier hs-var">S.map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. a -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-var">Reg</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; Bool) -&gt; HashSet a -&gt; HashSet a
</span><span class="hs-identifier hs-var">S.filter</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525511"><span class="hs-identifier hs-var">note</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679525520"><span class="hs-identifier hs-var">rightRegs</span></a></span><span>
</span><span id="line-719"></span><span>    </span><span id="local-6989586621679525503"><span class="annot"><span class="annottext">mrightPass :: MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525503"><span class="hs-identifier hs-var hs-var">mrightPass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall b a.
(Eq b, Hashable b) =&gt;
(a -&gt; b) -&gt; MultiSet a -&gt; MultiSet b
</span><a href="Internal.MultiSet.html#map"><span class="hs-identifier hs-var">MS.map</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. b -&gt; EdgeEither a b
</span><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-var">Pass</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; Bool) -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#filter"><span class="hs-identifier hs-var">MS.filter</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525511"><span class="hs-identifier hs-var">note</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525519"><span class="hs-identifier hs-var">rightPass</span></a></span><span>
</span><span id="line-720"></span><span>    </span><span id="local-6989586621679525509"><span class="annot"><span class="annottext">mandatoryLeft :: MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525509"><span class="hs-identifier hs-var hs-var">mandatoryLeft</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a.
(Foldable t, Eq a, Hashable a) =&gt;
t a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#fromSet"><span class="hs-identifier hs-var">MS.fromSet</span></a></span><span> </span><span class="annot"><span class="annottext">HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525506"><span class="hs-identifier hs-var">mleftRegs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525505"><span class="hs-identifier hs-var">mleftPass</span></a></span><span>
</span><span id="line-721"></span><span>    </span><span id="local-6989586621679525508"><span class="annot"><span class="annottext">mandatoryRight :: MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525508"><span class="hs-identifier hs-var hs-var">mandatoryRight</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a.
(Foldable t, Eq a, Hashable a) =&gt;
t a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#fromSet"><span class="hs-identifier hs-var">MS.fromSet</span></a></span><span> </span><span class="annot"><span class="annottext">HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525504"><span class="hs-identifier hs-var">mrightRegs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525503"><span class="hs-identifier hs-var">mrightPass</span></a></span><span>
</span><span id="line-722"></span><span>
</span><span id="line-723"></span><span>    </span><span class="hs-comment">-- the possible reductions of a (multiple) pitch are enumerated in three stages:</span><span>
</span><span id="line-724"></span><span>
</span><span id="line-725"></span><span>    </span><span class="hs-comment">-- stage 1: consume all mandatory edges on the left</span><span>
</span><span id="line-726"></span><span>    </span><span id="local-6989586621679525507"><span class="annot"><span class="annottext">enumerateOptions :: MultiSet (EdgeEither (StartStop n) n)
-&gt; MultiSet (EdgeEither (StartStop n) n)
-&gt; Int
-&gt; [[Elaboration
       (Edge n, (n, DoubleOrnament))
       (InnerEdge n, (n, PassingOrnament))
       (n, (n, RightOrnament))
       (n, (n, LeftOrnament))]]
</span><a href="#local-6989586621679525507"><span class="hs-identifier hs-var hs-var">enumerateOptions</span></a></span></span><span> </span><span id="local-6989586621679525502"><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525502"><span class="hs-identifier hs-var">ml</span></a></span></span><span> </span><span id="local-6989586621679525501"><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525501"><span class="hs-identifier hs-var">mr</span></a></span></span><span> </span><span id="local-6989586621679525500"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525500"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-727"></span><span>      </span><span class="hs-special">(</span><span id="local-6989586621679525499"><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525499"><span class="hs-identifier hs-var">mr'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525498"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525498"><span class="hs-identifier hs-var">n'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525497"><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525497"><span class="hs-identifier hs-var">acc</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) b a.
Monad m =&gt;
(b -&gt; a -&gt; m b) -&gt; b -&gt; MultiSet a -&gt; m b
</span><a href="Internal.MultiSet.html#foldM"><span class="hs-identifier hs-var">MS.foldM</span></a></span><span> </span><span class="annot"><span class="annottext">(MultiSet (EdgeEither (StartStop n) n), Int,
 [Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament))])
-&gt; EdgeEither (StartStop n) n
-&gt; [(MultiSet (EdgeEither (StartStop n) n), Int,
     [Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679525496"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525501"><span class="hs-identifier hs-var">mr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525500"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525502"><span class="hs-identifier hs-var">ml</span></a></span><span>
</span><span id="line-728"></span><span>      </span><span class="hs-special">(</span><span id="local-6989586621679525495"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525495"><span class="hs-identifier hs-var">n''</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525494"><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525494"><span class="hs-identifier hs-var">acc'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) b a.
Monad m =&gt;
(b -&gt; a -&gt; m b) -&gt; b -&gt; MultiSet a -&gt; m b
</span><a href="Internal.MultiSet.html#foldM"><span class="hs-identifier hs-var">MS.foldM</span></a></span><span> </span><span class="annot"><span class="annottext">(Int,
 [Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament))])
-&gt; EdgeEither (StartStop n) n
-&gt; [(Int,
     [Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679525493"><span class="hs-identifier hs-var">goR</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525498"><span class="hs-identifier hs-var">n'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525497"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525499"><span class="hs-identifier hs-var">mr'</span></a></span><span>
</span><span id="line-729"></span><span>      </span><span class="annot"><span class="annottext">forall {a}. [a] -&gt; Int -&gt; [a] -&gt; [[a]]
</span><a href="#local-6989586621679525492"><span class="hs-identifier hs-var">goFree</span></a></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525491"><span class="hs-identifier hs-var">freeOptions</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525495"><span class="hs-identifier hs-var">n''</span></a></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525494"><span class="hs-identifier hs-var">acc'</span></a></span><span>
</span><span id="line-730"></span><span>    </span><span id="local-6989586621679525496"><span class="annot"><span class="annottext">goL :: (MultiSet (EdgeEither (StartStop n) n), Int,
 [Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament))])
-&gt; EdgeEither (StartStop n) n
-&gt; [(MultiSet (EdgeEither (StartStop n) n), Int,
     [Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679525496"><span class="hs-identifier hs-var hs-var">goL</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-731"></span><span>    </span><span class="annot"><a href="#local-6989586621679525496"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525490"><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525490"><span class="hs-identifier hs-var">mr</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525489"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525489"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525488"><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525488"><span class="hs-identifier hs-var">acc</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679525487"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525487"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-732"></span><span>      </span><span class="hs-special">(</span><span id="local-6989586621679525486"><span class="annot"><span class="annottext">Elaboration
  (Edge n, (n, DoubleOrnament))
  (InnerEdge n, (n, PassingOrnament))
  (n, (n, RightOrnament))
  (n, (n, LeftOrnament))
</span><a href="#local-6989586621679525486"><span class="hs-identifier hs-var">new</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525485"><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525485"><span class="hs-identifier hs-var">mr'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Int
-&gt; EdgeEither (StartStop n) n
-&gt; MultiSet (EdgeEither (StartStop n) n)
-&gt; [(Elaboration
       (Edge n, (n, DoubleOrnament))
       (InnerEdge n, (n, PassingOrnament))
       (n, (n, RightOrnament))
       (n, (n, LeftOrnament)),
     MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679525484"><span class="hs-identifier hs-var">pickLeft</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525489"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525487"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525490"><span class="hs-identifier hs-var">mr</span></a></span><span>
</span><span id="line-733"></span><span>      </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525485"><span class="hs-identifier hs-var">mr'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525489"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Elaboration
  (Edge n, (n, DoubleOrnament))
  (InnerEdge n, (n, PassingOrnament))
  (n, (n, RightOrnament))
  (n, (n, LeftOrnament))
</span><a href="#local-6989586621679525486"><span class="hs-identifier hs-var">new</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525488"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-734"></span><span>    </span><span class="hs-comment">-- combine a mandatory left with a mandatory right or free right edge</span><span>
</span><span id="line-735"></span><span>    </span><span id="local-6989586621679525484"><span class="annot"><span class="annottext">pickLeft :: Int
-&gt; EdgeEither (StartStop n) n
-&gt; MultiSet (EdgeEither (StartStop n) n)
-&gt; [(Elaboration
       (Edge n, (n, DoubleOrnament))
       (InnerEdge n, (n, PassingOrnament))
       (n, (n, RightOrnament))
       (n, (n, LeftOrnament)),
     MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679525484"><span class="hs-identifier hs-var hs-var">pickLeft</span></a></span></span><span> </span><span id="local-6989586621679525483"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525483"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679525482"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525482"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679525481"><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525481"><span class="hs-identifier hs-var">mr</span></a></span></span><span>
</span><span id="line-736"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525483"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. MultiSet a -&gt; Int
</span><a href="Internal.MultiSet.html#size"><span class="hs-identifier hs-var">MS.size</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525481"><span class="hs-identifier hs-var">mr</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679525480"><span class="hs-identifier hs-var">mand</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679525479"><span class="hs-identifier hs-var">opt</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679525478"><span class="hs-identifier hs-var">single</span></a></span><span>
</span><span id="line-737"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679525480"><span class="hs-identifier hs-var">mand</span></a></span><span>
</span><span id="line-738"></span><span>     </span><span class="hs-keyword">where</span><span>
</span><span id="line-739"></span><span>      </span><span id="local-6989586621679525480"><span class="annot"><span class="annottext">mand :: [(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679525480"><span class="hs-identifier hs-var hs-var">mand</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-740"></span><span>        </span><span id="local-6989586621679525477"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525477"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall k. MultiSet k -&gt; [k]
</span><a href="Internal.MultiSet.html#distinctElems"><span class="hs-identifier hs-var">MS.distinctElems</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525481"><span class="hs-identifier hs-var">mr</span></a></span><span>
</span><span id="line-741"></span><span>        </span><span id="local-6989586621679525476"><span class="annot"><span class="annottext">Elaboration
  (Edge n, (n, DoubleOrnament))
  (InnerEdge n, (n, PassingOrnament))
  (n, (n, RightOrnament))
  (n, (n, LeftOrnament))
</span><a href="#local-6989586621679525476"><span class="hs-identifier hs-var">red</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; [a]
</span><span class="hs-identifier hs-var">maybeToList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall {n} {c} {d}.
(HasPitch n, Diatonic (ICOf (IntervalOf n)),
 Eq (ICOf (IntervalOf n))) =&gt;
Bool
-&gt; Bool
-&gt; EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        c
        d)
</span><a href="#local-6989586621679525475"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525482"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525511"><span class="hs-identifier hs-var">note</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525477"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-742"></span><span>        </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Elaboration
  (Edge n, (n, DoubleOrnament))
  (InnerEdge n, (n, PassingOrnament))
  (n, (n, RightOrnament))
  (n, (n, LeftOrnament))
</span><a href="#local-6989586621679525476"><span class="hs-identifier hs-var">red</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#delete"><span class="hs-identifier hs-var">MS.delete</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525477"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525481"><span class="hs-identifier hs-var">mr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-743"></span><span>      </span><span class="hs-comment">-- TODO: remove mr options here?</span><span>
</span><span id="line-744"></span><span>      </span><span id="local-6989586621679525474"><span class="annot"><span class="annottext">tryOpt :: EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament)))
</span><a href="#local-6989586621679525474"><span class="hs-identifier hs-var hs-var">tryOpt</span></a></span></span><span> </span><span id="local-6989586621679525473"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525473"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall {n} {c} {d}.
(HasPitch n, Diatonic (ICOf (IntervalOf n)),
 Eq (ICOf (IntervalOf n))) =&gt;
Bool
-&gt; Bool
-&gt; EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        c
        d)
</span><a href="#local-6989586621679525475"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525473"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; HashSet a -&gt; Bool
</span><span class="hs-operator hs-var">`S.member`</span></span><span> </span><span class="annot"><span class="annottext">HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525504"><span class="hs-identifier hs-var">mrightRegs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525482"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525511"><span class="hs-identifier hs-var">note</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525473"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-745"></span><span>      </span><span id="local-6989586621679525479"><span class="annot"><span class="annottext">opt :: [(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679525479"><span class="hs-identifier hs-var hs-var">opt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525481"><span class="hs-identifier hs-var">mr</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament)))
</span><a href="#local-6989586621679525474"><span class="hs-identifier hs-var">tryOpt</span></a></span><span> </span><span class="annot"><span class="annottext">[EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679525514"><span class="hs-identifier hs-var">innerR</span></a></span><span>
</span><span id="line-746"></span><span>      </span><span id="local-6989586621679525478"><span class="annot"><span class="annottext">single :: [(Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament)),
  MultiSet (EdgeEither (StartStop n) n))]
</span><a href="#local-6989586621679525478"><span class="hs-identifier hs-var hs-var">single</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">,</span><span class="annot"><span class="annottext">MultiSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525481"><span class="hs-identifier hs-var">mr</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; [a]
</span><span class="hs-identifier hs-var">maybeToList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall {a} {b} {a} {b} {d}.
(HasPitch a, Diatonic (ICOf (IntervalOf a)),
 Eq (ICOf (IntervalOf a))) =&gt;
a
-&gt; EdgeEither (StartStop a) b
-&gt; Maybe (Elaboration a b (a, (a, RightOrnament)) d)
</span><a href="#local-6989586621679525472"><span class="hs-identifier hs-var">tryLeftReduction</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525511"><span class="hs-identifier hs-var">note</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525482"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-747"></span><span>
</span><span id="line-748"></span><span>    </span><span class="hs-comment">-- stage 2: consume all remaining mandatory edges on the right</span><span>
</span><span id="line-749"></span><span>    </span><span id="local-6989586621679525493"><span class="annot"><span class="annottext">goR :: (Int,
 [Elaboration
    (Edge n, (n, DoubleOrnament))
    (InnerEdge n, (n, PassingOrnament))
    (n, (n, RightOrnament))
    (n, (n, LeftOrnament))])
-&gt; EdgeEither (StartStop n) n
-&gt; [(Int,
     [Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679525493"><span class="hs-identifier hs-var hs-var">goR</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-750"></span><span>    </span><span class="annot"><a href="#local-6989586621679525493"><span class="hs-identifier hs-var">goR</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525471"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525471"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525470"><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525470"><span class="hs-identifier hs-var">acc</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679525469"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525469"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-751"></span><span>      </span><span id="local-6989586621679525468"><span class="annot"><span class="annottext">Elaboration
  (Edge n, (n, DoubleOrnament))
  (InnerEdge n, (n, PassingOrnament))
  (n, (n, RightOrnament))
  (n, (n, LeftOrnament))
</span><a href="#local-6989586621679525468"><span class="hs-identifier hs-var">new</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
-&gt; [Elaboration
      (Edge n, (n, DoubleOrnament))
      (InnerEdge n, (n, PassingOrnament))
      (n, (n, RightOrnament))
      (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525467"><span class="hs-identifier hs-var">pickRight</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525469"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-752"></span><span>      </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525471"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Elaboration
  (Edge n, (n, DoubleOrnament))
  (InnerEdge n, (n, PassingOrnament))
  (n, (n, RightOrnament))
  (n, (n, LeftOrnament))
</span><a href="#local-6989586621679525468"><span class="hs-identifier hs-var">new</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525470"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-753"></span><span>    </span><span class="hs-comment">-- combine mandatory right with free left edge</span><span>
</span><span id="line-754"></span><span>    </span><span id="local-6989586621679525467"><span class="annot"><span class="annottext">pickRight :: EdgeEither (StartStop n) n
-&gt; [Elaboration
      (Edge n, (n, DoubleOrnament))
      (InnerEdge n, (n, PassingOrnament))
      (n, (n, RightOrnament))
      (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525467"><span class="hs-identifier hs-var hs-var">pickRight</span></a></span></span><span> </span><span id="local-6989586621679525466"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525466"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525465"><span class="hs-identifier hs-var">opt</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525464"><span class="hs-identifier hs-var">single</span></a></span><span>
</span><span id="line-755"></span><span>     </span><span class="hs-keyword">where</span><span>
</span><span id="line-756"></span><span>      </span><span id="local-6989586621679525463"><span class="annot"><span class="annottext">tryOpt :: EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament)))
</span><a href="#local-6989586621679525463"><span class="hs-identifier hs-var hs-var">tryOpt</span></a></span></span><span> </span><span id="local-6989586621679525462"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525462"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall {n} {c} {d}.
(HasPitch n, Diatonic (ICOf (IntervalOf n)),
 Eq (ICOf (IntervalOf n))) =&gt;
Bool
-&gt; Bool
-&gt; EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        c
        d)
</span><a href="#local-6989586621679525475"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525462"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; HashSet a -&gt; Bool
</span><span class="hs-operator hs-var">`S.member`</span></span><span> </span><span class="annot"><span class="annottext">HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525506"><span class="hs-identifier hs-var">mleftRegs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525462"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525511"><span class="hs-identifier hs-var">note</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525466"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-757"></span><span>      </span><span id="local-6989586621679525465"><span class="annot"><span class="annottext">opt :: [Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525465"><span class="hs-identifier hs-var hs-var">opt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        (n, (n, RightOrnament))
        (n, (n, LeftOrnament)))
</span><a href="#local-6989586621679525463"><span class="hs-identifier hs-var">tryOpt</span></a></span><span> </span><span class="annot"><span class="annottext">[EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679525515"><span class="hs-identifier hs-var">innerL</span></a></span><span>
</span><span id="line-758"></span><span>      </span><span id="local-6989586621679525464"><span class="annot"><span class="annottext">single :: [Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525464"><span class="hs-identifier hs-var hs-var">single</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; [a]
</span><span class="hs-identifier hs-var">maybeToList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall {a} {b} {a} {b} {c}.
(HasPitch a, Diatonic (ICOf (IntervalOf a)),
 Eq (ICOf (IntervalOf a))) =&gt;
a
-&gt; EdgeEither (StartStop a) b
-&gt; Maybe (Elaboration a b c (a, (a, LeftOrnament)))
</span><a href="#local-6989586621679525461"><span class="hs-identifier hs-var">tryRightReduction</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525511"><span class="hs-identifier hs-var">note</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525466"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-759"></span><span>
</span><span id="line-760"></span><span>    </span><span class="hs-comment">-- stage 3: explain all remaining notes through a combination of unknown edges</span><span>
</span><span id="line-761"></span><span>    </span><span id="local-6989586621679525492"><span class="annot"><span class="annottext">goFree :: [a] -&gt; Int -&gt; [a] -&gt; [[a]]
</span><a href="#local-6989586621679525492"><span class="hs-identifier hs-var hs-var">goFree</span></a></span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span id="local-6989586621679525450"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679525450"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679525450"><span class="hs-identifier hs-var">acc</span></a></span><span>
</span><span id="line-762"></span><span>    </span><span class="annot"><a href="#local-6989586621679525492"><span class="hs-identifier hs-var">goFree</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-763"></span><span>    </span><span class="annot"><a href="#local-6989586621679525492"><span class="hs-identifier hs-var">goFree</span></a></span><span> </span><span class="hs-special">[</span><span id="local-6989586621679525449"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525449"><span class="hs-identifier hs-var">lastOpt</span></a></span></span><span class="hs-special">]</span><span> </span><span id="local-6989586621679525448"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525448"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679525447"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679525447"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a. Int -&gt; a -&gt; [a]
</span><span class="hs-identifier hs-var">L.replicate</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525448"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525449"><span class="hs-identifier hs-var">lastOpt</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679525447"><span class="hs-identifier hs-var">acc</span></a></span><span>
</span><span id="line-764"></span><span>    </span><span class="annot"><a href="#local-6989586621679525492"><span class="hs-identifier hs-var">goFree</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525446"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525446"><span class="hs-identifier hs-var">opt</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621679525445"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679525445"><span class="hs-identifier hs-var">opts</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679525444"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525444"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679525443"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679525443"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-765"></span><span>      </span><span id="local-6989586621679525442"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525442"><span class="hs-identifier hs-var">nopt</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">..</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525444"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-766"></span><span>      </span><span class="annot"><span class="annottext">[a] -&gt; Int -&gt; [a] -&gt; [[a]]
</span><a href="#local-6989586621679525492"><span class="hs-identifier hs-var">goFree</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679525445"><span class="hs-identifier hs-var">opts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525444"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525442"><span class="hs-identifier hs-var">nopt</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Int -&gt; a -&gt; [a]
</span><span class="hs-identifier hs-var">L.replicate</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525442"><span class="hs-identifier hs-var">nopt</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525446"><span class="hs-identifier hs-var">opt</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621679525443"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-767"></span><span>    </span><span class="hs-comment">-- list all options for free reduction</span><span>
</span><span id="line-768"></span><span>    </span><span id="local-6989586621679525491"><span class="annot"><span class="annottext">freeOptions :: [Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525491"><span class="hs-identifier hs-var hs-var">freeOptions</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525441"><span class="hs-identifier hs-var">pickFreeBoth</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525440"><span class="hs-identifier hs-var">pickFreeLeft</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">[Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525439"><span class="hs-identifier hs-var">pickFreeRight</span></a></span><span>
</span><span id="line-769"></span><span>    </span><span class="hs-comment">-- combine two free edges</span><span>
</span><span id="line-770"></span><span>    </span><span id="local-6989586621679525441"><span class="annot"><span class="annottext">pickFreeBoth :: [Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525441"><span class="hs-identifier hs-var hs-var">pickFreeBoth</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-771"></span><span>      </span><span id="local-6989586621679525438"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525438"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679525515"><span class="hs-identifier hs-var">innerL</span></a></span><span>
</span><span id="line-772"></span><span>      </span><span id="local-6989586621679525437"><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525437"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679525514"><span class="hs-identifier hs-var">innerR</span></a></span><span>
</span><span id="line-773"></span><span>      </span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; [a]
</span><span class="hs-identifier hs-var">maybeToList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-774"></span><span>        </span><span class="annot"><span class="annottext">forall {n} {c} {d}.
(HasPitch n, Diatonic (ICOf (IntervalOf n)),
 Eq (ICOf (IntervalOf n))) =&gt;
Bool
-&gt; Bool
-&gt; EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        c
        d)
</span><a href="#local-6989586621679525475"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525438"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; HashSet a -&gt; Bool
</span><span class="hs-operator hs-var">`S.member`</span></span><span> </span><span class="annot"><span class="annottext">HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525506"><span class="hs-identifier hs-var">mleftRegs</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525437"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; HashSet a -&gt; Bool
</span><span class="hs-operator hs-var">`S.member`</span></span><span> </span><span class="annot"><span class="annottext">HashSet (EdgeEither (StartStop n) n)
</span><a href="#local-6989586621679525504"><span class="hs-identifier hs-var">mrightRegs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525438"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525511"><span class="hs-identifier hs-var">note</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525437"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-775"></span><span>    </span><span class="hs-comment">-- reduce to left using free edge</span><span>
</span><span id="line-776"></span><span>    </span><span id="local-6989586621679525440"><span class="annot"><span class="annottext">pickFreeLeft :: [Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525440"><span class="hs-identifier hs-var hs-var">pickFreeLeft</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall {a} {b} {a} {b} {d}.
(HasPitch a, Diatonic (ICOf (IntervalOf a)),
 Eq (ICOf (IntervalOf a))) =&gt;
a
-&gt; EdgeEither (StartStop a) b
-&gt; Maybe (Elaboration a b (a, (a, RightOrnament)) d)
</span><a href="#local-6989586621679525472"><span class="hs-identifier hs-var">tryLeftReduction</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525511"><span class="hs-identifier hs-var">note</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679525515"><span class="hs-identifier hs-var">innerL</span></a></span><span>
</span><span id="line-777"></span><span>    </span><span class="hs-comment">-- reduce to right using free edge</span><span>
</span><span id="line-778"></span><span>    </span><span id="local-6989586621679525439"><span class="annot"><span class="annottext">pickFreeRight :: [Elaboration
   (Edge n, (n, DoubleOrnament))
   (InnerEdge n, (n, PassingOrnament))
   (n, (n, RightOrnament))
   (n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525439"><span class="hs-identifier hs-var hs-var">pickFreeRight</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall {a} {b} {a} {b} {c}.
(HasPitch a, Diatonic (ICOf (IntervalOf a)),
 Eq (ICOf (IntervalOf a))) =&gt;
a
-&gt; EdgeEither (StartStop a) b
-&gt; Maybe (Elaboration a b c (a, (a, LeftOrnament)))
</span><a href="#local-6989586621679525461"><span class="hs-identifier hs-var">tryRightReduction</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525511"><span class="hs-identifier hs-var">note</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[EdgeEither (StartStop n) n]
</span><a href="#local-6989586621679525514"><span class="hs-identifier hs-var">innerR</span></a></span><span>
</span><span id="line-779"></span><span>
</span><span id="line-780"></span><span>  </span><span class="hs-comment">-- at all stages: try out potential reductions:</span><span>
</span><span id="line-781"></span><span>
</span><span id="line-782"></span><span>  </span><span class="hs-comment">-- two terminal edges: any ornament</span><span>
</span><span id="line-783"></span><span>  </span><span id="local-6989586621679525475"><span class="annot"><span class="annottext">tryReduction :: Bool
-&gt; Bool
-&gt; EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe
     (Elaboration
        (Edge n, (n, DoubleOrnament))
        (InnerEdge n, (n, PassingOrnament))
        c
        d)
</span><a href="#local-6989586621679525475"><span class="hs-identifier hs-var hs-var">tryReduction</span></a></span></span><span> </span><span id="local-6989586621679525421"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679525421"><span class="hs-identifier hs-var">lIsUsed</span></a></span></span><span> </span><span id="local-6989586621679525420"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679525420"><span class="hs-identifier hs-var">rIsUsed</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span id="local-6989586621679525419"><span class="annot"><span class="annottext">StartStop n
</span><a href="#local-6989586621679525419"><span class="hs-identifier hs-var">notel</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679525418"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525418"><span class="hs-identifier hs-var">notem</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span id="local-6989586621679525417"><span class="annot"><span class="annottext">StartStop n
</span><a href="#local-6989586621679525417"><span class="hs-identifier hs-var">noter</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-784"></span><span>    </span><span id="local-6989586621679525416"><span class="annot"><span class="annottext">EdgeEither (DoubleOrnament, Edge n) (PassingOrnament, InnerEdge n)
</span><a href="#local-6989586621679525416"><span class="hs-identifier hs-var">reduction</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall n.
IsNote n =&gt;
StartStop n
-&gt; StartStop n
-&gt; StartStop n
-&gt; Bool
-&gt; Bool
-&gt; Maybe
     (EdgeEither
        (DoubleOrnament, Edge n) (PassingOrnament, InnerEdge n))
</span><a href="PVGrammar.Parse.html#findOrnament"><span class="hs-identifier hs-var">findOrnament</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><a href="#local-6989586621679525419"><span class="hs-identifier hs-var">notel</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; StartStop a
</span><a href="Common.html#Inner"><span class="hs-identifier hs-var">Inner</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525418"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><a href="#local-6989586621679525417"><span class="hs-identifier hs-var">noter</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679525421"><span class="hs-identifier hs-var">lIsUsed</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679525420"><span class="hs-identifier hs-var">rIsUsed</span></a></span><span>
</span><span id="line-785"></span><span>    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">EdgeEither (DoubleOrnament, Edge n) (PassingOrnament, InnerEdge n)
</span><a href="#local-6989586621679525416"><span class="hs-identifier hs-var">reduction</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-786"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525415"><span class="annot"><span class="annottext">DoubleOrnament
</span><a href="#local-6989586621679525415"><span class="hs-identifier hs-var">orn</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525414"><span class="annot"><span class="annottext">Edge n
</span><a href="#local-6989586621679525414"><span class="hs-identifier hs-var">parent</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a b c d. a -&gt; Elaboration a b c d
</span><a href="PVGrammar.Parse.html#EReg"><span class="hs-identifier hs-var">EReg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Edge n
</span><a href="#local-6989586621679525414"><span class="hs-identifier hs-var">parent</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525418"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">DoubleOrnament
</span><a href="#local-6989586621679525415"><span class="hs-identifier hs-var">orn</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-787"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-type">Pass</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525413"><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679525413"><span class="hs-identifier hs-var">pass</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525412"><span class="annot"><span class="annottext">InnerEdge n
</span><a href="#local-6989586621679525412"><span class="hs-identifier hs-var">parent</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a b c d. b -&gt; Elaboration a b c d
</span><a href="PVGrammar.Parse.html#EPass"><span class="hs-identifier hs-var">EPass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">InnerEdge n
</span><a href="#local-6989586621679525412"><span class="hs-identifier hs-var">parent</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525418"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679525413"><span class="hs-identifier hs-var">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-788"></span><span>  </span><span class="hs-comment">-- a non-terminal edge left and a terminal edge right: passing note</span><span>
</span><span id="line-789"></span><span>  </span><span class="annot"><a href="#local-6989586621679525475"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679525411"><span class="annot"><span class="annottext">notel :: EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525411"><span class="hs-identifier hs-var">notel</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-type">Pass</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679525410"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525410"><span class="hs-identifier hs-var">notem</span></a></span></span><span> </span><span id="local-6989586621679525409"><span class="annot"><span class="annottext">noter :: EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525409"><span class="hs-identifier hs-var">noter</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-790"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679525408"><span class="annot"><span class="annottext">InnerEdge n
</span><a href="#local-6989586621679525408"><span class="hs-identifier hs-var">parent</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525407"><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679525407"><span class="hs-identifier hs-var">pass</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall n.
IsNote n =&gt;
EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe (InnerEdge n, PassingOrnament)
</span><a href="PVGrammar.Parse.html#findPassing"><span class="hs-identifier hs-var">findPassing</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525411"><span class="hs-identifier hs-var">notel</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525410"><span class="hs-identifier hs-var">notem</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525409"><span class="hs-identifier hs-var">noter</span></a></span><span>
</span><span id="line-791"></span><span>    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b c d. b -&gt; Elaboration a b c d
</span><a href="PVGrammar.Parse.html#EPass"><span class="hs-identifier hs-var">EPass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">InnerEdge n
</span><a href="#local-6989586621679525408"><span class="hs-identifier hs-var">parent</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525410"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679525407"><span class="hs-identifier hs-var">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-792"></span><span>  </span><span class="hs-comment">-- a terminal edge left and a non-terminal edge right: passing note</span><span>
</span><span id="line-793"></span><span>  </span><span class="annot"><a href="#local-6989586621679525475"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679525406"><span class="annot"><span class="annottext">notel :: EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525406"><span class="hs-identifier hs-var">notel</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop n
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679525405"><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525405"><span class="hs-identifier hs-var">notem</span></a></span></span><span> </span><span id="local-6989586621679525404"><span class="annot"><span class="annottext">noter :: EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525404"><span class="hs-identifier hs-var">noter</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Pass"><span class="hs-identifier hs-type">Pass</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-794"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679525403"><span class="annot"><span class="annottext">InnerEdge n
</span><a href="#local-6989586621679525403"><span class="hs-identifier hs-var">parent</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525402"><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679525402"><span class="hs-identifier hs-var">pass</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall n.
IsNote n =&gt;
EdgeEither (StartStop n) n
-&gt; n
-&gt; EdgeEither (StartStop n) n
-&gt; Maybe (InnerEdge n, PassingOrnament)
</span><a href="PVGrammar.Parse.html#findPassing"><span class="hs-identifier hs-var">findPassing</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525406"><span class="hs-identifier hs-var">notel</span></a></span><span> </span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525405"><span class="hs-identifier hs-var">notem</span></a></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><a href="#local-6989586621679525404"><span class="hs-identifier hs-var">noter</span></a></span><span>
</span><span id="line-795"></span><span>    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b c d. b -&gt; Elaboration a b c d
</span><a href="PVGrammar.Parse.html#EPass"><span class="hs-identifier hs-var">EPass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">InnerEdge n
</span><a href="#local-6989586621679525403"><span class="hs-identifier hs-var">parent</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">n
</span><a href="#local-6989586621679525405"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679525402"><span class="hs-identifier hs-var">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-796"></span><span>  </span><span class="hs-comment">-- all other combinations are forbidden</span><span>
</span><span id="line-797"></span><span>  </span><span class="annot"><a href="#local-6989586621679525475"><span class="hs-identifier hs-var">tryReduction</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">n
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop n) n
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-798"></span><span>
</span><span id="line-799"></span><span>  </span><span class="hs-comment">-- single reduction to a left parent</span><span>
</span><span id="line-800"></span><span>  </span><span id="local-6989586621679525472"><span class="annot"><span class="annottext">tryLeftReduction :: a
-&gt; EdgeEither (StartStop a) b
-&gt; Maybe (Elaboration a b (a, (a, RightOrnament)) d)
</span><a href="#local-6989586621679525472"><span class="hs-identifier hs-var hs-var">tryLeftReduction</span></a></span></span><span> </span><span id="local-6989586621679525392"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525392"><span class="hs-identifier hs-var">notem</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679525391"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525391"><span class="hs-identifier hs-var">notel</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-801"></span><span>    </span><span id="local-6989586621679525390"><span class="annot"><span class="annottext">RightOrnament
</span><a href="#local-6989586621679525390"><span class="hs-identifier hs-var">orn</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall n. IsNote n =&gt; n -&gt; n -&gt; Maybe RightOrnament
</span><a href="PVGrammar.Parse.html#findRightOrnament"><span class="hs-identifier hs-var">findRightOrnament</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525391"><span class="hs-identifier hs-var">notel</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525392"><span class="hs-identifier hs-var">notem</span></a></span><span>
</span><span id="line-802"></span><span>    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b c d. c -&gt; Elaboration a b c d
</span><a href="PVGrammar.Parse.html#ER"><span class="hs-identifier hs-var">ER</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525391"><span class="hs-identifier hs-var">notel</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525392"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">RightOrnament
</span><a href="#local-6989586621679525390"><span class="hs-identifier hs-var">orn</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-803"></span><span>  </span><span class="annot"><a href="#local-6989586621679525472"><span class="hs-identifier hs-var">tryLeftReduction</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop a) b
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-804"></span><span>
</span><span id="line-805"></span><span>  </span><span class="hs-comment">-- single reduction to a right parent</span><span>
</span><span id="line-806"></span><span>  </span><span id="local-6989586621679525461"><span class="annot"><span class="annottext">tryRightReduction :: a
-&gt; EdgeEither (StartStop a) b
-&gt; Maybe (Elaboration a b c (a, (a, LeftOrnament)))
</span><a href="#local-6989586621679525461"><span class="hs-identifier hs-var hs-var">tryRightReduction</span></a></span></span><span> </span><span id="local-6989586621679525380"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525380"><span class="hs-identifier hs-var">notem</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.Parse.html#Reg"><span class="hs-identifier hs-type">Reg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Inner"><span class="hs-identifier hs-type">Inner</span></a></span><span> </span><span id="local-6989586621679525379"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525379"><span class="hs-identifier hs-var">noter</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-807"></span><span>    </span><span id="local-6989586621679525378"><span class="annot"><span class="annottext">LeftOrnament
</span><a href="#local-6989586621679525378"><span class="hs-identifier hs-var">orn</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall n. IsNote n =&gt; n -&gt; n -&gt; Maybe LeftOrnament
</span><a href="PVGrammar.Parse.html#findLeftOrnament"><span class="hs-identifier hs-var">findLeftOrnament</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525380"><span class="hs-identifier hs-var">notem</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525379"><span class="hs-identifier hs-var">noter</span></a></span><span>
</span><span id="line-808"></span><span>    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b c d. d -&gt; Elaboration a b c d
</span><a href="PVGrammar.Parse.html#EL"><span class="hs-identifier hs-var">EL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525379"><span class="hs-identifier hs-var">noter</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525380"><span class="hs-identifier hs-var">notem</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">LeftOrnament
</span><a href="#local-6989586621679525378"><span class="hs-identifier hs-var">orn</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-809"></span><span>  </span><span class="annot"><a href="#local-6989586621679525461"><span class="hs-identifier hs-var">tryRightReduction</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">EdgeEither (StartStop a) b
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-810"></span><span>
</span><span id="line-811"></span><span>  </span><span class="hs-comment">-- compute all possible combinations of reduction options</span><span>
</span><span id="line-812"></span><span>  </span><span class="hs-glyph">!</span><span id="local-6989586621679525516"><span class="annot"><span class="annottext">combinations :: [([(Edge n, (n, DoubleOrnament))],
  [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
  [(n, (n, LeftOrnament))])]
</span><a href="#local-6989586621679525516"><span class="hs-identifier hs-var hs-var">combinations</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-813"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">any</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">L.null</span></span><span> </span><span class="annot"><span class="annottext">[[([(Edge n, (n, DoubleOrnament))],
   [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
   [(n, (n, LeftOrnament))])]]
</span><a href="#local-6989586621679525513"><span class="hs-identifier hs-var">options</span></a></span><span> </span><span class="hs-comment">-- check if any note has no options</span><span>
</span><span id="line-814"></span><span>      </span><span class="hs-keyword">then</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- if yes, then no reduction is possible at all</span><span>
</span><span id="line-815"></span><span>      </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (m :: * -&gt; *) b a.
(Foldable t, Monad m) =&gt;
(b -&gt; a -&gt; m b) -&gt; b -&gt; t a -&gt; m b
</span><span class="hs-identifier hs-var">foldM</span></span><span> </span><span class="annot"><span class="annottext">forall {m :: * -&gt; *} {a} {b} {c} {d}.
(Monad m, Semigroup a, Semigroup b, Semigroup c, Semigroup d) =&gt;
(a, b, c, d) -&gt; m (a, b, c, d) -&gt; m (a, b, c, d)
</span><a href="#local-6989586621679525377"><span class="hs-identifier hs-var">pickOption</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[[([(Edge n, (n, DoubleOrnament))],
   [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
   [(n, (n, LeftOrnament))])]]
</span><a href="#local-6989586621679525513"><span class="hs-identifier hs-var">options</span></a></span><span> </span><span class="hs-comment">-- otherwise, compute all combinations</span><span>
</span><span id="line-816"></span><span>      </span><span class="hs-comment">-- picks all different options for a single note in the list monad</span><span>
</span><span id="line-817"></span><span>  </span><span id="local-6989586621679525377"><span class="annot"><span class="annottext">pickOption :: (a, b, c, d) -&gt; m (a, b, c, d) -&gt; m (a, b, c, d)
</span><a href="#local-6989586621679525377"><span class="hs-identifier hs-var hs-var">pickOption</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525364"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525364"><span class="hs-identifier hs-var">accReg</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525363"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679525363"><span class="hs-identifier hs-var">accPass</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525362"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679525362"><span class="hs-identifier hs-var">accL</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525361"><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679525361"><span class="hs-identifier hs-var">accR</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679525360"><span class="annot"><span class="annottext">m (a, b, c, d)
</span><a href="#local-6989586621679525360"><span class="hs-identifier hs-var">opts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-818"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679525359"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525359"><span class="hs-identifier hs-var">regs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525358"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679525358"><span class="hs-identifier hs-var">pass</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525357"><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679525357"><span class="hs-identifier hs-var">ls</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525356"><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679525356"><span class="hs-identifier hs-var">rs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m (a, b, c, d)
</span><a href="#local-6989586621679525360"><span class="hs-identifier hs-var">opts</span></a></span><span>
</span><span id="line-819"></span><span>    </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525359"><span class="hs-identifier hs-var">regs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525364"><span class="hs-identifier hs-var">accReg</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679525358"><span class="hs-identifier hs-var">pass</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679525363"><span class="hs-identifier hs-var">accPass</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679525357"><span class="hs-identifier hs-var">ls</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">c
</span><a href="#local-6989586621679525362"><span class="hs-identifier hs-var">accL</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679525356"><span class="hs-identifier hs-var">rs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">d
</span><a href="#local-6989586621679525361"><span class="hs-identifier hs-var">accR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-820"></span><span>
</span><span id="line-821"></span><span>  </span><span class="hs-comment">-- convert a combination into a derivation operation:</span><span>
</span><span id="line-822"></span><span>  </span><span class="hs-comment">-- turn the accumulated information into the format expected from the evaluator</span><span>
</span><span id="line-823"></span><span>  </span><span id="local-6989586621679525517"><span class="annot"><span class="annottext">mkTop :: ([(Edge n, (n, DoubleOrnament))],
 [(InnerEdge n, (n, PassingOrnament))], [(n, (n, RightOrnament))],
 [(n, (n, LeftOrnament))])
-&gt; (Edges n, Split n)
</span><a href="#local-6989586621679525517"><span class="hs-identifier hs-var hs-var">mkTop</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525355"><span class="annot"><span class="annottext">[(Edge n, (n, DoubleOrnament))]
</span><a href="#local-6989586621679525355"><span class="hs-identifier hs-var">regs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525354"><span class="annot"><span class="annottext">[(InnerEdge n, (n, PassingOrnament))]
</span><a href="#local-6989586621679525354"><span class="hs-identifier hs-var">pass</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525353"><span class="annot"><span class="annottext">[(n, (n, RightOrnament))]
</span><a href="#local-6989586621679525353"><span class="hs-identifier hs-var">rs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525352"><span class="annot"><span class="annottext">[(n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525352"><span class="hs-identifier hs-var">ls</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-824"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="hs-comment">-- validate</span><span>
</span><span id="line-825"></span><span>      </span><span class="hs-keyword">then</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679525351"><span class="hs-identifier hs-var">top</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall n.
Map (Edge n) [(n, DoubleOrnament)]
-&gt; Map (InnerEdge n) [(n, PassingOrnament)]
-&gt; Map n [(n, RightOrnament)]
-&gt; Map n [(n, LeftOrnament)]
-&gt; HashSet (Edge n)
-&gt; HashSet (Edge n)
-&gt; MultiSet (InnerEdge n)
-&gt; MultiSet (InnerEdge n)
-&gt; Split n
</span><a href="PVGrammar.html#SplitOp"><span class="hs-identifier hs-var">SplitOp</span></a></span><span> </span><span class="annot"><span class="annottext">Map (Edge n) [(n, DoubleOrnament)]
</span><a href="#local-6989586621679525350"><span class="hs-identifier hs-var">tmap</span></a></span><span> </span><span class="annot"><span class="annottext">Map (InnerEdge n) [(n, PassingOrnament)]
</span><a href="#local-6989586621679525349"><span class="hs-identifier hs-var">ntmap</span></a></span><span> </span><span class="annot"><span class="annottext">Map n [(n, RightOrnament)]
</span><a href="#local-6989586621679525348"><span class="hs-identifier hs-var">rmap</span></a></span><span> </span><span class="annot"><span class="annottext">Map n [(n, LeftOrnament)]
</span><a href="#local-6989586621679525347"><span class="hs-identifier hs-var">lmap</span></a></span><span> </span><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679525523"><span class="hs-identifier hs-var">leftRegs</span></a></span><span> </span><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679525520"><span class="hs-identifier hs-var">rightRegs</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525346"><span class="hs-identifier hs-var">passL</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525345"><span class="hs-identifier hs-var">passR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-826"></span><span>      </span><span class="hs-keyword">else</span><span>
</span><span id="line-827"></span><span>        </span><span class="annot"><span class="annottext">forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-828"></span><span>          </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;invalid unsplit:\n  notesl=&quot;</span></span><span>
</span><span id="line-829"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679525524"><span class="hs-identifier hs-var">notesl</span></a></span><span>
</span><span id="line-830"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n  notesr=&quot;</span></span><span>
</span><span id="line-831"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679525518"><span class="hs-identifier hs-var">notesr</span></a></span><span>
</span><span id="line-832"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n  notesm=&quot;</span></span><span>
</span><span id="line-833"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall n. MultiSet n -&gt; Notes n
</span><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-var">Notes</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679525521"><span class="hs-identifier hs-var">notesm</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-834"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n  left=&quot;</span></span><span>
</span><span id="line-835"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall n. HashSet (Edge n) -&gt; MultiSet (InnerEdge n) -&gt; Edges n
</span><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-var">Edges</span></a></span><span> </span><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679525523"><span class="hs-identifier hs-var">leftRegs</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525522"><span class="hs-identifier hs-var">leftPass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-836"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n  right=&quot;</span></span><span>
</span><span id="line-837"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall n. HashSet (Edge n) -&gt; MultiSet (InnerEdge n) -&gt; Edges n
</span><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-var">Edges</span></a></span><span> </span><span class="annot"><span class="annottext">HashSet (Edge n)
</span><a href="#local-6989586621679525520"><span class="hs-identifier hs-var">rightRegs</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525519"><span class="hs-identifier hs-var">rightPass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-838"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n  top=&quot;</span></span><span>
</span><span id="line-839"></span><span>            </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679525351"><span class="hs-identifier hs-var">top</span></a></span><span>
</span><span id="line-840"></span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-841"></span><span>    </span><span class="hs-comment">-- validate =</span><span>
</span><span id="line-842"></span><span>    </span><span class="hs-comment">--   all ((`L.elem` innerNotes notesl) . fst . fst) regs</span><span>
</span><span id="line-843"></span><span>    </span><span class="hs-comment">--     &amp;&amp; all ((`L.elem` innerNotes notesr) . snd . fst)   regs</span><span>
</span><span id="line-844"></span><span>    </span><span class="hs-comment">--     &amp;&amp; all ((`L.elem` innerNotes notesl) . Inner . fst) rs</span><span>
</span><span id="line-845"></span><span>    </span><span class="hs-comment">--     &amp;&amp; all ((`L.elem` innerNotes notesr) . Inner . fst) ls</span><span>
</span><span id="line-846"></span><span>
</span><span id="line-847"></span><span>    </span><span class="hs-comment">-- collect all operations</span><span>
</span><span id="line-848"></span><span>    </span><span id="local-6989586621679525339"><span class="annot"><span class="annottext">mapify :: [(k, a)] -&gt; Map k [a]
</span><a href="#local-6989586621679525339"><span class="hs-identifier hs-var hs-var">mapify</span></a></span></span><span> </span><span id="local-6989586621679525338"><span class="annot"><span class="annottext">[(k, a)]
</span><a href="#local-6989586621679525338"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall k a. Ord k =&gt; (a -&gt; a -&gt; a) -&gt; [(k, a)] -&gt; Map k a
</span><span class="hs-identifier hs-var">M.fromListWith</span></span><span> </span><span class="annot"><span class="annottext">forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">(&lt;&gt;)</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[(k, a)]
</span><a href="#local-6989586621679525338"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-849"></span><span>    </span><span id="local-6989586621679525350"><span class="annot"><span class="annottext">tmap :: Map (Edge n) [(n, DoubleOrnament)]
</span><a href="#local-6989586621679525350"><span class="hs-identifier hs-var hs-var">tmap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall {k} {a}. Ord k =&gt; [(k, a)] -&gt; Map k [a]
</span><a href="#local-6989586621679525339"><span class="hs-identifier hs-var">mapify</span></a></span><span> </span><span class="annot"><span class="annottext">[(Edge n, (n, DoubleOrnament))]
</span><a href="#local-6989586621679525355"><span class="hs-identifier hs-var">regs</span></a></span><span>
</span><span id="line-850"></span><span>    </span><span id="local-6989586621679525349"><span class="annot"><span class="annottext">ntmap :: Map (InnerEdge n) [(n, PassingOrnament)]
</span><a href="#local-6989586621679525349"><span class="hs-identifier hs-var hs-var">ntmap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall {k} {a}. Ord k =&gt; [(k, a)] -&gt; Map k [a]
</span><a href="#local-6989586621679525339"><span class="hs-identifier hs-var">mapify</span></a></span><span> </span><span class="annot"><span class="annottext">[(InnerEdge n, (n, PassingOrnament))]
</span><a href="#local-6989586621679525354"><span class="hs-identifier hs-var">pass</span></a></span><span>
</span><span id="line-851"></span><span>    </span><span id="local-6989586621679525347"><span class="annot"><span class="annottext">lmap :: Map n [(n, LeftOrnament)]
</span><a href="#local-6989586621679525347"><span class="hs-identifier hs-var hs-var">lmap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall {k} {a}. Ord k =&gt; [(k, a)] -&gt; Map k [a]
</span><a href="#local-6989586621679525339"><span class="hs-identifier hs-var">mapify</span></a></span><span> </span><span class="annot"><span class="annottext">[(n, (n, LeftOrnament))]
</span><a href="#local-6989586621679525352"><span class="hs-identifier hs-var">ls</span></a></span><span>
</span><span id="line-852"></span><span>    </span><span id="local-6989586621679525348"><span class="annot"><span class="annottext">rmap :: Map n [(n, RightOrnament)]
</span><a href="#local-6989586621679525348"><span class="hs-identifier hs-var hs-var">rmap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall {k} {a}. Ord k =&gt; [(k, a)] -&gt; Map k [a]
</span><a href="#local-6989586621679525339"><span class="hs-identifier hs-var">mapify</span></a></span><span> </span><span class="annot"><span class="annottext">[(n, (n, RightOrnament))]
</span><a href="#local-6989586621679525353"><span class="hs-identifier hs-var">rs</span></a></span><span>
</span><span id="line-853"></span><span>    </span><span id="local-6989586621679525351"><span class="annot"><span class="annottext">top :: Edges n
</span><a href="#local-6989586621679525351"><span class="hs-identifier hs-var hs-var">top</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall n. HashSet (Edge n) -&gt; MultiSet (InnerEdge n) -&gt; Edges n
</span><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-var">Edges</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; [a] -&gt; HashSet a
</span><span class="hs-identifier hs-var">S.fromList</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[(Edge n, (n, DoubleOrnament))]
</span><a href="#local-6989586621679525355"><span class="hs-identifier hs-var">regs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a.
(Foldable t, Eq a, Hashable a) =&gt;
t a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#fromList"><span class="hs-identifier hs-var">MS.fromList</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><span class="hs-identifier hs-var">fst</span></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">[(InnerEdge n, (n, PassingOrnament))]
</span><a href="#local-6989586621679525354"><span class="hs-identifier hs-var">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-854"></span><span>    </span><span id="local-6989586621679525346"><span class="annot"><span class="annottext">passL :: MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525346"><span class="hs-identifier hs-var hs-var">passL</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#delete"><span class="hs-identifier hs-var">MS.delete</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525522"><span class="hs-identifier hs-var">leftPass</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">forall {a} {b} {b}. ((a, b), (b, PassingOrnament)) -&gt; Maybe (a, b)
</span><a href="#local-6989586621679525337"><span class="hs-identifier hs-var">leftPassingChild</span></a></span><span> </span><span class="annot"><span class="annottext">[(InnerEdge n, (n, PassingOrnament))]
</span><a href="#local-6989586621679525354"><span class="hs-identifier hs-var">pass</span></a></span><span>
</span><span id="line-855"></span><span>    </span><span id="local-6989586621679525345"><span class="annot"><span class="annottext">passR :: MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525345"><span class="hs-identifier hs-var hs-var">passR</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; a -&gt; MultiSet a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#delete"><span class="hs-identifier hs-var">MS.delete</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge n)
</span><a href="#local-6989586621679525519"><span class="hs-identifier hs-var">rightPass</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">forall {a} {b} {a}. ((a, b), (a, PassingOrnament)) -&gt; Maybe (a, b)
</span><a href="#local-6989586621679525336"><span class="hs-identifier hs-var">rightPassingChild</span></a></span><span> </span><span class="annot"><span class="annottext">[(InnerEdge n, (n, PassingOrnament))]
</span><a href="#local-6989586621679525354"><span class="hs-identifier hs-var">pass</span></a></span><span>
</span><span id="line-856"></span><span>    </span><span id="local-6989586621679525337"><span class="annot"><span class="annottext">leftPassingChild :: ((a, b), (b, PassingOrnament)) -&gt; Maybe (a, b)
</span><a href="#local-6989586621679525337"><span class="hs-identifier hs-var hs-var">leftPassingChild</span></a></span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span id="local-6989586621679525334"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525334"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525333"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679525333"><span class="hs-identifier hs-var">_r</span></a></span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525332"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679525332"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525331"><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679525331"><span class="hs-identifier hs-var">orn</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-857"></span><span>      </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679525331"><span class="hs-identifier hs-var">orn</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="PVGrammar.html#PassingRight"><span class="hs-identifier hs-var">PassingRight</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525334"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679525332"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-858"></span><span>    </span><span id="local-6989586621679525336"><span class="annot"><span class="annottext">rightPassingChild :: ((a, b), (a, PassingOrnament)) -&gt; Maybe (a, b)
</span><a href="#local-6989586621679525336"><span class="hs-identifier hs-var hs-var">rightPassingChild</span></a></span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span id="local-6989586621679525329"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525329"><span class="hs-identifier hs-var">_l</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525328"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679525328"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525327"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525327"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525326"><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679525326"><span class="hs-identifier hs-var">orn</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-859"></span><span>      </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="#local-6989586621679525326"><span class="hs-identifier hs-var">orn</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">PassingOrnament
</span><a href="PVGrammar.html#PassingLeft"><span class="hs-identifier hs-var">PassingLeft</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679525327"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679525328"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-860"></span><span>
</span><span id="line-861"></span><span class="hs-comment">{- | Computes all potential ways a surface transition could have been frozen.
 In this grammar, this operation is unique and just turns ties into edges.
-}</span><span>
</span><span id="line-864"></span><span id="local-6989586621679527038"><span id="local-6989586621679527039"><span class="annot"><a href="PVGrammar.Parse.html#pvThaw"><span class="hs-identifier hs-type">pvThaw</span></a></span><span>
</span><span id="line-865"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679527039"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679527038"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679527038"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-866"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#StartStop"><span class="hs-identifier hs-type">StartStop</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527038"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-867"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679527039"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527038"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-868"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Common.html#StartStop"><span class="hs-identifier hs-type">StartStop</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527038"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-869"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527038"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Freeze"><span class="hs-identifier hs-type">Freeze</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span></span></span><span>
</span><span id="line-870"></span><span id="pvThaw"><span class="annot"><span class="annottext">pvThaw :: forall (t :: * -&gt; *) n.
(Foldable t, Ord n, Hashable n) =&gt;
StartStop (Notes n)
-&gt; Maybe (t (Edge n)) -&gt; StartStop (Notes n) -&gt; [(Edges n, Freeze)]
</span><a href="PVGrammar.Parse.html#pvThaw"><span class="hs-identifier hs-var hs-var">pvThaw</span></a></span></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621679525314"><span class="annot"><span class="annottext">Maybe (t (Edge n))
</span><a href="#local-6989586621679525314"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall n. HashSet (Edge n) -&gt; MultiSet (InnerEdge n) -&gt; Edges n
</span><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-var">Edges</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. (Eq a, Hashable a) =&gt; [a] -&gt; HashSet a
</span><span class="hs-identifier hs-var">S.fromList</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; [a]
</span><span class="hs-identifier hs-var">toList</span></span><span> </span><span class="annot"><span class="annottext">Maybe (t (Edge n))
</span><a href="#local-6989586621679525314"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall a. MultiSet a
</span><a href="Internal.MultiSet.html#empty"><span class="hs-identifier hs-var">MS.empty</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Freeze
</span><a href="PVGrammar.html#FreezeOp"><span class="hs-identifier hs-var">FreezeOp</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-871"></span><span>
</span><span id="line-872"></span><span id="local-6989586621679527035"><span id="local-6989586621679527036"><span class="annot"><a href="PVGrammar.Parse.html#pvSlice"><span class="hs-identifier hs-type">pvSlice</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679527036"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679527035"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679527035"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679527036"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527035"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679527035"><span class="hs-identifier hs-type">n</span></a></span></span></span><span>
</span><span id="line-873"></span><span id="pvSlice"><span class="annot"><span class="annottext">pvSlice :: forall (t :: * -&gt; *) n.
(Foldable t, Eq n, Hashable n) =&gt;
t n -&gt; Notes n
</span><a href="PVGrammar.Parse.html#pvSlice"><span class="hs-identifier hs-var hs-var">pvSlice</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall n. MultiSet n -&gt; Notes n
</span><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-var">Notes</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a.
(Foldable t, Eq a, Hashable a) =&gt;
t a -&gt; MultiSet a
</span><a href="Internal.MultiSet.html#fromList"><span class="hs-identifier hs-var">MS.fromList</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; [a]
</span><span class="hs-identifier hs-var">toList</span></span><span>
</span><span id="line-874"></span><span>
</span><span id="line-875"></span><span class="hs-comment">-- evaluators in specific semirings</span><span>
</span><span id="line-876"></span><span class="hs-comment">-- ================================</span><span>
</span><span id="line-877"></span><span>
</span><span id="line-878"></span><span class="hs-comment">{- | A restricted version of the PV evaluator
 that prohibits split operations in which one of the parent slices is repeated entirely.
-}</span><span>
</span><span id="line-881"></span><span id="local-6989586621679525301"><span id="local-6989586621679525302"><span id="local-6989586621679525303"><span class="annot"><a href="PVGrammar.Parse.html#protoVoiceEvaluatorNoRepSplit"><span class="hs-identifier hs-type">protoVoiceEvaluatorNoRepSplit</span></a></span><span>
</span><span id="line-882"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679525303"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679525302"><span class="hs-identifier hs-type">t2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679525301"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679525301"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679525301"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679525301"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679525301"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-883"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679525301"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679525303"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679525301"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679525301"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679525302"><span class="hs-identifier hs-type">t2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679525301"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#PVLeftmost"><span class="hs-identifier hs-type">PVLeftmost</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679525301"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-884"></span><span id="protoVoiceEvaluatorNoRepSplit"><span class="annot"><span class="annottext">protoVoiceEvaluatorNoRepSplit :: forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
</span><a href="PVGrammar.Parse.html#protoVoiceEvaluatorNoRepSplit"><span class="hs-identifier hs-var hs-var">protoVoiceEvaluatorNoRepSplit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall tr tr' slc slc' v.
UnspreadMiddle tr slc v
-&gt; UnspreadLeft tr slc
-&gt; UnspreadRight tr slc
-&gt; Unsplit tr slc v
-&gt; (StartStop slc
    -&gt; Maybe tr' -&gt; StartStop slc -&gt; Bool -&gt; [(tr, v)])
-&gt; (slc' -&gt; slc)
-&gt; Eval tr tr' slc slc' v
</span><a href="Common.html#Eval"><span class="hs-identifier hs-var">Eval</span></a></span><span> </span><span class="annot"><span class="annottext">UnspreadMiddle (Edges n) (Notes n) (PVLeftmost n)
</span><a href="#local-6989586621679525289"><span class="hs-identifier hs-var">vm</span></a></span><span> </span><span class="annot"><span class="annottext">UnspreadLeft (Edges n) (Notes n)
</span><a href="#local-6989586621679525288"><span class="hs-identifier hs-var">vl</span></a></span><span> </span><span class="annot"><span class="annottext">UnspreadRight (Edges n) (Notes n)
</span><a href="#local-6989586621679525287"><span class="hs-identifier hs-var">vr</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
-&gt; Edges n
-&gt; Notes n
-&gt; Edges n
-&gt; StartStop (Notes n)
-&gt; SplitType
-&gt; [(Edges n, PVLeftmost n)]
</span><a href="#local-6989586621679525286"><span class="hs-identifier hs-var">filterSplit</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
-&gt; Maybe (t (Edge n))
-&gt; StartStop (Notes n)
-&gt; Bool
-&gt; [(Edges n, PVLeftmost n)]
</span><a href="#local-6989586621679525285"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">t2 n -&gt; Notes n
</span><a href="#local-6989586621679525284"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-885"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-886"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span> </span><span id="local-6989586621679525289"><span class="annot"><span class="annottext">UnspreadMiddle (Edges n) (Notes n) (PVLeftmost n)
</span><a href="#local-6989586621679525289"><span class="hs-identifier hs-var">vm</span></a></span></span><span> </span><span id="local-6989586621679525288"><span class="annot"><span class="annottext">UnspreadLeft (Edges n) (Notes n)
</span><a href="#local-6989586621679525288"><span class="hs-identifier hs-var">vl</span></a></span></span><span> </span><span id="local-6989586621679525287"><span class="annot"><span class="annottext">UnspreadRight (Edges n) (Notes n)
</span><a href="#local-6989586621679525287"><span class="hs-identifier hs-var">vr</span></a></span></span><span> </span><span id="local-6989586621679525273"><span class="annot"><span class="annottext">StartStop (Notes n)
-&gt; Edges n
-&gt; Notes n
-&gt; Edges n
-&gt; StartStop (Notes n)
-&gt; SplitType
-&gt; [(Edges n, PVLeftmost n)]
</span><a href="#local-6989586621679525273"><span class="hs-identifier hs-var">mg</span></a></span></span><span> </span><span id="local-6989586621679525285"><span class="annot"><span class="annottext">StartStop (Notes n)
-&gt; Maybe (t (Edge n))
-&gt; StartStop (Notes n)
-&gt; Bool
-&gt; [(Edges n, PVLeftmost n)]
</span><a href="#local-6989586621679525285"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679525284"><span class="annot"><span class="annottext">t2 n -&gt; Notes n
</span><a href="#local-6989586621679525284"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
</span><a href="PVGrammar.Parse.html#protoVoiceEvaluator"><span class="hs-identifier hs-var">protoVoiceEvaluator</span></a></span><span>
</span><span id="line-887"></span><span>  </span><span id="local-6989586621679525286"><span class="annot"><span class="annottext">filterSplit :: StartStop (Notes n)
-&gt; Edges n
-&gt; Notes n
-&gt; Edges n
-&gt; StartStop (Notes n)
-&gt; SplitType
-&gt; [(Edges n, PVLeftmost n)]
</span><a href="#local-6989586621679525286"><span class="hs-identifier hs-var hs-var">filterSplit</span></a></span></span><span> </span><span id="local-6989586621679525272"><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679525272"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679525271"><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679525271"><span class="hs-identifier hs-var">lt</span></a></span></span><span> </span><span id="local-6989586621679525270"><span class="annot"><span class="annottext">Notes n
</span><a href="#local-6989586621679525270"><span class="hs-identifier hs-var">mid</span></a></span></span><span> </span><span id="local-6989586621679525269"><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679525269"><span class="hs-identifier hs-var">rt</span></a></span></span><span> </span><span id="local-6989586621679525268"><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679525268"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span id="local-6989586621679525267"><span class="annot"><span class="annottext">SplitType
</span><a href="#local-6989586621679525267"><span class="hs-identifier hs-var">typ</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">filter</span></span><span> </span><span class="annot"><span class="annottext">forall {a} {a} {f} {h}. (a, Leftmost (Split a) f h) -&gt; Bool
</span><a href="#local-6989586621679525266"><span class="hs-identifier hs-var">ok</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
-&gt; Edges n
-&gt; Notes n
-&gt; Edges n
-&gt; StartStop (Notes n)
-&gt; SplitType
-&gt; [(Edges n, PVLeftmost n)]
</span><a href="#local-6989586621679525273"><span class="hs-identifier hs-var">mg</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679525272"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679525271"><span class="hs-identifier hs-var">lt</span></a></span><span> </span><span class="annot"><span class="annottext">Notes n
</span><a href="#local-6989586621679525270"><span class="hs-identifier hs-var">mid</span></a></span><span> </span><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679525269"><span class="hs-identifier hs-var">rt</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
</span><a href="#local-6989586621679525268"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">SplitType
</span><a href="#local-6989586621679525267"><span class="hs-identifier hs-var">typ</span></a></span><span>
</span><span id="line-888"></span><span>  </span><span id="local-6989586621679525266"><span class="annot"><span class="annottext">ok :: (a, Leftmost (Split a) f h) -&gt; Bool
</span><a href="#local-6989586621679525266"><span class="hs-identifier hs-var hs-var">ok</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Common.html#LMSplitLeft"><span class="hs-identifier hs-type">LMSplitLeft</span></a></span><span> </span><span id="local-6989586621679525264"><span class="annot"><span class="annottext">Split a
</span><a href="#local-6989586621679525264"><span class="hs-identifier hs-var">op</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall {a}. Split a -&gt; Bool
</span><a href="#local-6989586621679525262"><span class="hs-identifier hs-var">onlyRepeats</span></a></span><span> </span><span class="annot"><span class="annottext">Split a
</span><a href="#local-6989586621679525264"><span class="hs-identifier hs-var">op</span></a></span><span>
</span><span id="line-889"></span><span>  </span><span class="annot"><a href="#local-6989586621679525266"><span class="hs-identifier hs-var">ok</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Common.html#LMSplitOnly"><span class="hs-identifier hs-type">LMSplitOnly</span></a></span><span> </span><span id="local-6989586621679525260"><span class="annot"><span class="annottext">Split a
</span><a href="#local-6989586621679525260"><span class="hs-identifier hs-var">op</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall {a}. Split a -&gt; Bool
</span><a href="#local-6989586621679525262"><span class="hs-identifier hs-var">onlyRepeats</span></a></span><span> </span><span class="annot"><span class="annottext">Split a
</span><a href="#local-6989586621679525260"><span class="hs-identifier hs-var">op</span></a></span><span>
</span><span id="line-890"></span><span>  </span><span class="annot"><a href="#local-6989586621679525266"><span class="hs-identifier hs-var">ok</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Common.html#LMSplitRight"><span class="hs-identifier hs-type">LMSplitRight</span></a></span><span> </span><span id="local-6989586621679525258"><span class="annot"><span class="annottext">Split a
</span><a href="#local-6989586621679525258"><span class="hs-identifier hs-var">op</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall {a}. Split a -&gt; Bool
</span><a href="#local-6989586621679525262"><span class="hs-identifier hs-var">onlyRepeats</span></a></span><span> </span><span class="annot"><span class="annottext">Split a
</span><a href="#local-6989586621679525258"><span class="hs-identifier hs-var">op</span></a></span><span>
</span><span id="line-891"></span><span>  </span><span class="annot"><a href="#local-6989586621679525266"><span class="hs-identifier hs-var">ok</span></a></span><span> </span><span class="annot"><span class="annottext">(a, Leftmost (Split a) f h)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-892"></span><span>  </span><span id="local-6989586621679525262"><span class="annot"><span class="annottext">onlyRepeats :: Split a -&gt; Bool
</span><a href="#local-6989586621679525262"><span class="hs-identifier hs-var hs-var">onlyRepeats</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#SplitOp"><span class="hs-identifier hs-type">SplitOp</span></a></span><span> </span><span id="local-6989586621679525245"><span class="annot"><span class="annottext">Map (Edge a) [(a, DoubleOrnament)]
</span><a href="#local-6989586621679525245"><span class="hs-identifier hs-var">regs</span></a></span></span><span> </span><span id="local-6989586621679525244"><span class="annot"><span class="annottext">Map (InnerEdge a) [(a, PassingOrnament)]
</span><a href="#local-6989586621679525244"><span class="hs-identifier hs-var">pass</span></a></span></span><span> </span><span id="local-6989586621679525243"><span class="annot"><span class="annottext">Map a [(a, RightOrnament)]
</span><a href="#local-6989586621679525243"><span class="hs-identifier hs-var">rs</span></a></span></span><span> </span><span id="local-6989586621679525242"><span class="annot"><span class="annottext">Map a [(a, LeftOrnament)]
</span><a href="#local-6989586621679525242"><span class="hs-identifier hs-var">ls</span></a></span></span><span> </span><span class="annot"><span class="annottext">HashSet (Edge a)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">HashSet (Edge a)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge a)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">MultiSet (InnerEdge a)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-893"></span><span>    </span><span class="annot"><span class="annottext">forall k a. Map k a -&gt; Bool
</span><span class="hs-identifier hs-var">M.null</span></span><span> </span><span class="annot"><span class="annottext">Map (InnerEdge a) [(a, PassingOrnament)]
</span><a href="#local-6989586621679525244"><span class="hs-identifier hs-var">pass</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679525240"><span class="hs-identifier hs-var">allRepetitionsLeft</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679525239"><span class="hs-identifier hs-var">allRepetitionsRight</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-894"></span><span>   </span><span class="hs-keyword">where</span><span>
</span><span id="line-895"></span><span>    </span><span id="local-6989586621679525238"><span class="annot"><span class="annottext">allSinglesRepeat :: Bool
</span><a href="#local-6989586621679525238"><span class="hs-identifier hs-var hs-var">allSinglesRepeat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-896"></span><span>      </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall {t :: * -&gt; *} {b} {a} {a}.
Foldable t =&gt;
(b -&gt; Bool) -&gt; (a, t (a, b)) -&gt; Bool
</span><a href="#local-6989586621679525236"><span class="hs-identifier hs-var">check</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">RightOrnament
</span><a href="PVGrammar.html#RightRepeat"><span class="hs-identifier hs-var">RightRepeat</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">M.toList</span></span><span> </span><span class="annot"><span class="annottext">Map a [(a, RightOrnament)]
</span><a href="#local-6989586621679525243"><span class="hs-identifier hs-var">rs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-897"></span><span>        </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall {t :: * -&gt; *} {b} {a} {a}.
Foldable t =&gt;
(b -&gt; Bool) -&gt; (a, t (a, b)) -&gt; Bool
</span><a href="#local-6989586621679525236"><span class="hs-identifier hs-var">check</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">LeftOrnament
</span><a href="PVGrammar.html#LeftRepeat"><span class="hs-identifier hs-var">LeftRepeat</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">M.toList</span></span><span> </span><span class="annot"><span class="annottext">Map a [(a, LeftOrnament)]
</span><a href="#local-6989586621679525242"><span class="hs-identifier hs-var">ls</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-898"></span><span>    </span><span id="local-6989586621679525240"><span class="annot"><span class="annottext">allRepetitionsLeft :: Bool
</span><a href="#local-6989586621679525240"><span class="hs-identifier hs-var hs-var">allRepetitionsLeft</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-899"></span><span>      </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall {t :: * -&gt; *} {b} {a} {a}.
Foldable t =&gt;
(b -&gt; Bool) -&gt; (a, t (a, b)) -&gt; Bool
</span><a href="#local-6989586621679525236"><span class="hs-identifier hs-var">check</span></a></span><span> </span><span class="annot"><span class="annottext">DoubleOrnament -&gt; Bool
</span><a href="PVGrammar.html#isRepetitionOnLeft"><span class="hs-identifier hs-var">isRepetitionOnLeft</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">M.toList</span></span><span> </span><span class="annot"><span class="annottext">Map (Edge a) [(a, DoubleOrnament)]
</span><a href="#local-6989586621679525245"><span class="hs-identifier hs-var">regs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679525238"><span class="hs-identifier hs-var">allSinglesRepeat</span></a></span><span>
</span><span id="line-900"></span><span>    </span><span id="local-6989586621679525239"><span class="annot"><span class="annottext">allRepetitionsRight :: Bool
</span><a href="#local-6989586621679525239"><span class="hs-identifier hs-var hs-var">allRepetitionsRight</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-901"></span><span>      </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall {t :: * -&gt; *} {b} {a} {a}.
Foldable t =&gt;
(b -&gt; Bool) -&gt; (a, t (a, b)) -&gt; Bool
</span><a href="#local-6989586621679525236"><span class="hs-identifier hs-var">check</span></a></span><span> </span><span class="annot"><span class="annottext">DoubleOrnament -&gt; Bool
</span><a href="PVGrammar.html#isRepetitionOnRight"><span class="hs-identifier hs-var">isRepetitionOnRight</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">M.toList</span></span><span> </span><span class="annot"><span class="annottext">Map (Edge a) [(a, DoubleOrnament)]
</span><a href="#local-6989586621679525245"><span class="hs-identifier hs-var">regs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679525238"><span class="hs-identifier hs-var">allSinglesRepeat</span></a></span><span>
</span><span id="line-902"></span><span>  </span><span id="local-6989586621679525236"><span class="annot"><span class="annottext">check :: (b -&gt; Bool) -&gt; (a, t (a, b)) -&gt; Bool
</span><a href="#local-6989586621679525236"><span class="hs-identifier hs-var hs-var">check</span></a></span></span><span> </span><span id="local-6989586621679525230"><span class="annot"><span class="annottext">b -&gt; Bool
</span><a href="#local-6989586621679525230"><span class="hs-identifier hs-var">fpred</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525229"><span class="annot"><span class="annottext">t (a, b)
</span><a href="#local-6989586621679525229"><span class="hs-identifier hs-var">os</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">all</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">b -&gt; Bool
</span><a href="#local-6989586621679525230"><span class="hs-identifier hs-var">fpred</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">t (a, b)
</span><a href="#local-6989586621679525229"><span class="hs-identifier hs-var">os</span></a></span><span>
</span><span id="line-903"></span><span>
</span><span id="line-904"></span><span id="local-6989586621679526803"><span id="local-6989586621679526804"><span id="local-6989586621679526805"><span class="annot"><a href="PVGrammar.Parse.html#protoVoiceEvaluatorLimitedSize"><span class="hs-identifier hs-type">protoVoiceEvaluatorLimitedSize</span></a></span><span>
</span><span id="line-905"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679526805"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679526804"><span class="hs-identifier hs-type">t2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679526803"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679526803"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526803"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679526803"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679526803"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-906"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>
</span><span id="line-907"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526803"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679526805"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526803"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526803"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679526804"><span class="hs-identifier hs-type">t2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526803"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#PVLeftmost"><span class="hs-identifier hs-type">PVLeftmost</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526803"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-908"></span><span id="protoVoiceEvaluatorLimitedSize"><span class="annot"><span class="annottext">protoVoiceEvaluatorLimitedSize :: forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Int -&gt; Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
</span><a href="PVGrammar.Parse.html#protoVoiceEvaluatorLimitedSize"><span class="hs-identifier hs-var hs-var">protoVoiceEvaluatorLimitedSize</span></a></span></span><span> </span><span id="local-6989586621679525216"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525216"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall tr tr' slc slc' v.
UnspreadMiddle tr slc v
-&gt; UnspreadLeft tr slc
-&gt; UnspreadRight tr slc
-&gt; Unsplit tr slc v
-&gt; (StartStop slc
    -&gt; Maybe tr' -&gt; StartStop slc -&gt; Bool -&gt; [(tr, v)])
-&gt; (slc' -&gt; slc)
-&gt; Eval tr tr' slc slc' v
</span><a href="Common.html#Eval"><span class="hs-identifier hs-var">Eval</span></a></span><span> </span><span class="annot"><span class="annottext">(Notes n, Edges n, Notes n) -&gt; Maybe (Notes n, PVLeftmost n)
</span><a href="#local-6989586621679525215"><span class="hs-identifier hs-var">filterUnspreadM</span></a></span><span> </span><span class="annot"><span class="annottext">UnspreadLeft (Edges n) (Notes n)
</span><a href="#local-6989586621679525214"><span class="hs-identifier hs-var">vl</span></a></span><span> </span><span class="annot"><span class="annottext">UnspreadRight (Edges n) (Notes n)
</span><a href="#local-6989586621679525213"><span class="hs-identifier hs-var">vr</span></a></span><span> </span><span class="annot"><span class="annottext">Unsplit (Edges n) (Notes n) (PVLeftmost n)
</span><a href="#local-6989586621679525212"><span class="hs-identifier hs-var">mg</span></a></span><span> </span><span class="annot"><span class="annottext">StartStop (Notes n)
-&gt; Maybe (t (Edge n))
-&gt; StartStop (Notes n)
-&gt; Bool
-&gt; [(Edges n, PVLeftmost n)]
</span><a href="#local-6989586621679525211"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">t2 n -&gt; Notes n
</span><a href="#local-6989586621679525210"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-909"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-910"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span> </span><span id="local-6989586621679525199"><span class="annot"><span class="annottext">(Notes n, Edges n, Notes n) -&gt; Maybe (Notes n, PVLeftmost n)
</span><a href="#local-6989586621679525199"><span class="hs-identifier hs-var">vm</span></a></span></span><span> </span><span id="local-6989586621679525214"><span class="annot"><span class="annottext">UnspreadLeft (Edges n) (Notes n)
</span><a href="#local-6989586621679525214"><span class="hs-identifier hs-var">vl</span></a></span></span><span> </span><span id="local-6989586621679525213"><span class="annot"><span class="annottext">UnspreadRight (Edges n) (Notes n)
</span><a href="#local-6989586621679525213"><span class="hs-identifier hs-var">vr</span></a></span></span><span> </span><span id="local-6989586621679525212"><span class="annot"><span class="annottext">Unsplit (Edges n) (Notes n) (PVLeftmost n)
</span><a href="#local-6989586621679525212"><span class="hs-identifier hs-var">mg</span></a></span></span><span> </span><span id="local-6989586621679525211"><span class="annot"><span class="annottext">StartStop (Notes n)
-&gt; Maybe (t (Edge n))
-&gt; StartStop (Notes n)
-&gt; Bool
-&gt; [(Edges n, PVLeftmost n)]
</span><a href="#local-6989586621679525211"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679525210"><span class="annot"><span class="annottext">t2 n -&gt; Notes n
</span><a href="#local-6989586621679525210"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
</span><a href="PVGrammar.Parse.html#protoVoiceEvaluator"><span class="hs-identifier hs-var">protoVoiceEvaluator</span></a></span><span>
</span><span id="line-911"></span><span>
</span><span id="line-912"></span><span>  </span><span id="local-6989586621679525215"><span class="annot"><span class="annottext">filterUnspreadM :: (Notes n, Edges n, Notes n) -&gt; Maybe (Notes n, PVLeftmost n)
</span><a href="#local-6989586621679525215"><span class="hs-identifier hs-var hs-var">filterUnspreadM</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679525198"><span class="annot"><span class="annottext">Notes n
</span><a href="#local-6989586621679525198"><span class="hs-identifier hs-var">sl</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525197"><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679525197"><span class="hs-identifier hs-var">tm</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525196"><span class="annot"><span class="annottext">Notes n
</span><a href="#local-6989586621679525196"><span class="hs-identifier hs-var">sr</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-913"></span><span>    </span><span id="local-6989586621679525195"><span class="annot"><span class="annottext">(Notes n, PVLeftmost n)
</span><a href="#local-6989586621679525195"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(Notes n, Edges n, Notes n) -&gt; Maybe (Notes n, PVLeftmost n)
</span><a href="#local-6989586621679525199"><span class="hs-identifier hs-var">vm</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Notes n
</span><a href="#local-6989586621679525198"><span class="hs-identifier hs-var">sl</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Edges n
</span><a href="#local-6989586621679525197"><span class="hs-identifier hs-var">tm</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Notes n
</span><a href="#local-6989586621679525196"><span class="hs-identifier hs-var">sr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-914"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">(Notes n, PVLeftmost n)
</span><a href="#local-6989586621679525195"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-915"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span id="local-6989586621679525194"><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679525194"><span class="hs-identifier hs-var">ns</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679525193"><span class="annot"><span class="annottext">PVLeftmost n
</span><a href="#local-6989586621679525193"><span class="hs-identifier hs-var">v'</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-916"></span><span>        </span><span class="hs-glyph">|</span><span>  </span><span class="annot"><span class="annottext">forall a. MultiSet a -&gt; Int
</span><a href="Internal.MultiSet.html#size"><span class="hs-identifier hs-var">MS.size</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679525194"><span class="hs-identifier hs-var">ns</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679525216"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall n. MultiSet n -&gt; Notes n
</span><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-var">Notes</span></a></span><span> </span><span class="annot"><span class="annottext">MultiSet n
</span><a href="#local-6989586621679525194"><span class="hs-identifier hs-var">ns</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">PVLeftmost n
</span><a href="#local-6989586621679525193"><span class="hs-identifier hs-var">v'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-917"></span><span>        </span><span class="hs-glyph">|</span><span>  </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-918"></span><span>
</span><span id="line-919"></span><span class="hs-comment">-- | An evaluator for protovoices that produces values in the 'Derivations' semiring.</span><span>
</span><span id="line-920"></span><span id="local-6989586621679526797"><span id="local-6989586621679526798"><span id="local-6989586621679526799"><span class="annot"><a href="PVGrammar.Parse.html#pvDerivUnrestricted"><span class="hs-identifier hs-type">pvDerivUnrestricted</span></a></span><span>
</span><span id="line-921"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679526799"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679526798"><span class="hs-identifier hs-type">t2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679526797"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679526797"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526797"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679526797"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679526797"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-922"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span>
</span><span id="line-923"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526797"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-924"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679526799"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526797"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-925"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526797"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-926"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679526798"><span class="hs-identifier hs-type">t2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526797"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-927"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Derivations"><span class="hs-identifier hs-type">Derivations</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#PVLeftmost"><span class="hs-identifier hs-type">PVLeftmost</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526797"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-928"></span><span id="pvDerivUnrestricted"><span class="annot"><span class="annottext">pvDerivUnrestricted :: forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval
  (Edges n)
  (t (Edge n))
  (Notes n)
  (t2 n)
  (Derivations (PVLeftmost n))
</span><a href="PVGrammar.Parse.html#pvDerivUnrestricted"><span class="hs-identifier hs-var hs-var">pvDerivUnrestricted</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall v w tr tr' slc slc'.
(v -&gt; w) -&gt; Eval tr tr' slc slc' v -&gt; Eval tr tr' slc slc' w
</span><a href="Common.html#mapEvalScore"><span class="hs-identifier hs-var">mapEvalScore</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Derivations a
</span><a href="Common.html#Do"><span class="hs-identifier hs-var">Do</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
</span><a href="PVGrammar.Parse.html#protoVoiceEvaluator"><span class="hs-identifier hs-var">protoVoiceEvaluator</span></a></span><span>
</span><span id="line-929"></span><span>
</span><span id="line-930"></span><span class="hs-comment">{- | An evaluator for protovoices that produces values in the 'Derivations' semiring.

 - Enforces right-branching spreads (see 'rightBranchSpread').
-}</span><span>
</span><span id="line-934"></span><span id="local-6989586621679526783"><span id="local-6989586621679526784"><span id="local-6989586621679526785"><span class="annot"><a href="PVGrammar.Parse.html#pvDerivRightBranch"><span class="hs-identifier hs-type">pvDerivRightBranch</span></a></span><span>
</span><span id="line-935"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679526785"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679526784"><span class="hs-identifier hs-type">t2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679526783"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679526783"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526783"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679526783"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679526783"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-936"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span>
</span><span id="line-937"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Merged"><span class="hs-identifier hs-type">Merged</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#RightBranchSpread"><span class="hs-identifier hs-type">RightBranchSpread</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526783"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-938"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679526785"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526783"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-939"></span><span>      </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526783"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-940"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679526784"><span class="hs-identifier hs-type">t2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526783"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-941"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Derivations"><span class="hs-identifier hs-type">Derivations</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#PVLeftmost"><span class="hs-identifier hs-type">PVLeftmost</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526783"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-942"></span><span id="pvDerivRightBranch"><span class="annot"><span class="annottext">pvDerivRightBranch :: forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval
  (Merged, (RightBranchSpread, Edges n))
  (t (Edge n))
  ((), ((), Notes n))
  (t2 n)
  (Derivations (PVLeftmost n))
</span><a href="PVGrammar.Parse.html#pvDerivRightBranch"><span class="hs-identifier hs-var hs-var">pvDerivRightBranch</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-943"></span><span>  </span><span class="annot"><span class="annottext">forall tr tr' slc slc' w.
Eval tr tr' slc slc' w -&gt; Eval (Merged, tr) tr' ((), slc) slc' w
</span><a href="Common.html#splitFirst"><span class="hs-identifier hs-var">splitFirst</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall tr tr' slc slc' w.
Eval tr tr' slc slc' w
-&gt; Eval (RightBranchSpread, tr) tr' ((), slc) slc' w
</span><a href="Common.html#rightBranchSpread"><span class="hs-identifier hs-var">rightBranchSpread</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">forall v w tr tr' slc slc'.
(v -&gt; w) -&gt; Eval tr tr' slc slc' v -&gt; Eval tr tr' slc slc' w
</span><a href="Common.html#mapEvalScore"><span class="hs-identifier hs-var">mapEvalScore</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Derivations a
</span><a href="Common.html#Do"><span class="hs-identifier hs-var">Do</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
</span><a href="PVGrammar.Parse.html#protoVoiceEvaluatorNoRepSplit"><span class="hs-identifier hs-var">protoVoiceEvaluatorNoRepSplit</span></a></span><span>
</span><span id="line-944"></span><span>
</span><span id="line-945"></span><span class="hs-comment">-- | An evaluator for protovoices that produces values in the counting semiring.</span><span>
</span><span id="line-946"></span><span id="local-6989586621679526765"><span id="local-6989586621679526766"><span id="local-6989586621679526767"><span class="annot"><a href="PVGrammar.Parse.html#pvCountUnrestricted"><span class="hs-identifier hs-type">pvCountUnrestricted</span></a></span><span>
</span><span id="line-947"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679526767"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679526766"><span class="hs-identifier hs-type">t2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679526765"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679526765"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526765"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679526765"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679526765"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-948"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526765"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679526767"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526765"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526765"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679526766"><span class="hs-identifier hs-type">t2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526765"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span></span></span></span><span>
</span><span id="line-949"></span><span id="pvCountUnrestricted"><span class="annot"><span class="annottext">pvCountUnrestricted :: forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) Int
</span><a href="PVGrammar.Parse.html#pvCountUnrestricted"><span class="hs-identifier hs-var hs-var">pvCountUnrestricted</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall v w tr tr' slc slc'.
(v -&gt; w) -&gt; Eval tr tr' slc slc' v -&gt; Eval tr tr' slc slc' w
</span><a href="Common.html#mapEvalScore"><span class="hs-identifier hs-var">mapEvalScore</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
</span><a href="PVGrammar.Parse.html#protoVoiceEvaluator"><span class="hs-identifier hs-var">protoVoiceEvaluator</span></a></span><span>
</span><span id="line-950"></span><span>
</span><span id="line-951"></span><span class="hs-comment">{- | An evaluator for protovoices that produces values in the counting semiring.

 - Prohibits split operations in which one of the parent slices is repeated entirely (see 'protoVoiceEvaluatorNoRepSplit').
-}</span><span>
</span><span id="line-955"></span><span id="local-6989586621679525142"><span id="local-6989586621679525143"><span id="local-6989586621679525144"><span class="annot"><a href="PVGrammar.Parse.html#pvCountNoRepSplit"><span class="hs-identifier hs-type">pvCountNoRepSplit</span></a></span><span>
</span><span id="line-956"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679525144"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679525143"><span class="hs-identifier hs-type">t2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679525142"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679525142"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679525142"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679525142"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679525142"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-957"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679525142"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679525144"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679525142"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679525142"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679525143"><span class="hs-identifier hs-type">t2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679525142"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span></span></span></span><span>
</span><span id="line-958"></span><span id="pvCountNoRepSplit"><span class="annot"><span class="annottext">pvCountNoRepSplit :: forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) Int
</span><a href="PVGrammar.Parse.html#pvCountNoRepSplit"><span class="hs-identifier hs-var hs-var">pvCountNoRepSplit</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall v w tr tr' slc slc'.
(v -&gt; w) -&gt; Eval tr tr' slc slc' v -&gt; Eval tr tr' slc slc' w
</span><a href="Common.html#mapEvalScore"><span class="hs-identifier hs-var">mapEvalScore</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
</span><a href="PVGrammar.Parse.html#protoVoiceEvaluatorNoRepSplit"><span class="hs-identifier hs-var">protoVoiceEvaluatorNoRepSplit</span></a></span><span>
</span><span id="line-959"></span><span>
</span><span id="line-960"></span><span class="hs-comment">{- | An evaluator for protovoices that produces values in the counting semiring.

 - Prohibits split operations in which one of the parent slices is repeated entirely (see 'protoVoiceEvaluatorNoRepSplit').
 - Enforces right-branching spreads (see 'rightBranchSpread').
-}</span><span>
</span><span id="line-965"></span><span id="local-6989586621679526754"><span id="local-6989586621679526755"><span id="local-6989586621679526756"><span class="annot"><a href="PVGrammar.Parse.html#pvCountNoRepSplitRightBranch"><span class="hs-identifier hs-type">pvCountNoRepSplitRightBranch</span></a></span><span>
</span><span id="line-966"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679526756"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679526755"><span class="hs-identifier hs-type">t2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679526754"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679526754"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526754"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679526754"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679526754"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-967"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#RightBranchSpread"><span class="hs-identifier hs-type">RightBranchSpread</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526754"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679526756"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526754"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526754"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679526755"><span class="hs-identifier hs-type">t2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526754"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span></span></span></span><span>
</span><span id="line-968"></span><span id="pvCountNoRepSplitRightBranch"><span class="annot"><span class="annottext">pvCountNoRepSplitRightBranch :: forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval
  (RightBranchSpread, Edges n) (t (Edge n)) ((), Notes n) (t2 n) Int
</span><a href="PVGrammar.Parse.html#pvCountNoRepSplitRightBranch"><span class="hs-identifier hs-var hs-var">pvCountNoRepSplitRightBranch</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall tr tr' slc slc' w.
Eval tr tr' slc slc' w
-&gt; Eval (RightBranchSpread, tr) tr' ((), slc) slc' w
</span><a href="Common.html#rightBranchSpread"><span class="hs-identifier hs-var">rightBranchSpread</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) Int
</span><a href="PVGrammar.Parse.html#pvCountNoRepSplit"><span class="hs-identifier hs-var">pvCountNoRepSplit</span></a></span><span>
</span><span id="line-969"></span><span>
</span><span id="line-970"></span><span class="hs-comment">{- | An evaluator for protovoices that produces values in the counting semiring.

 - Prohibits split operations in which one of the parent slices is repeated entirely (see 'protoVoiceEvaluatorNoRepSplit').
 - Enforces right-branching spreads (see 'rightBranchSpread').
 - Normalizes the order of adjacent split and spread operations to split-before-spread (see 'splitFirst').
-}</span><span>
</span><span id="line-976"></span><span id="local-6989586621679526748"><span id="local-6989586621679526749"><span id="local-6989586621679526750"><span class="annot"><a href="PVGrammar.Parse.html#pvCountNoRepSplitRightBranchSplitFirst"><span class="hs-identifier hs-type">pvCountNoRepSplitRightBranchSplitFirst</span></a></span><span>
</span><span id="line-977"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679526750"><span class="hs-identifier hs-type">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Foldable</span></span><span> </span><span class="annot"><a href="#local-6989586621679526749"><span class="hs-identifier hs-type">t2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Eq</span></span><span> </span><span class="annot"><a href="#local-6989586621679526748"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621679526748"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.Parse.html#IsNote"><span class="hs-identifier hs-type">IsNote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526748"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Notation</span></span><span> </span><span class="annot"><a href="#local-6989586621679526748"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Hashable</span></span><span> </span><span class="annot"><a href="#local-6989586621679526748"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-978"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Common.html#Eval"><span class="hs-identifier hs-type">Eval</span></a></span><span>
</span><span id="line-979"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#Merged"><span class="hs-identifier hs-type">Merged</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Common.html#RightBranchSpread"><span class="hs-identifier hs-type">RightBranchSpread</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Edges"><span class="hs-identifier hs-type">Edges</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526748"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-980"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679526750"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="PVGrammar.html#Edge"><span class="hs-identifier hs-type">Edge</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526748"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-981"></span><span>      </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="PVGrammar.html#Notes"><span class="hs-identifier hs-type">Notes</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526748"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-982"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679526749"><span class="hs-identifier hs-type">t2</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679526748"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-983"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span></span></span></span><span>
</span><span id="line-984"></span><span id="pvCountNoRepSplitRightBranchSplitFirst"><span class="annot"><span class="annottext">pvCountNoRepSplitRightBranchSplitFirst :: forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval
  (Merged, (RightBranchSpread, Edges n))
  (t (Edge n))
  ((), ((), Notes n))
  (t2 n)
  Int
</span><a href="PVGrammar.Parse.html#pvCountNoRepSplitRightBranchSplitFirst"><span class="hs-identifier hs-var hs-var">pvCountNoRepSplitRightBranchSplitFirst</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall tr tr' slc slc' w.
Eval tr tr' slc slc' w -&gt; Eval (Merged, tr) tr' ((), slc) slc' w
</span><a href="Common.html#splitFirst"><span class="hs-identifier hs-var">splitFirst</span></a></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (t2 :: * -&gt; *) n.
(Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n,
 Hashable n) =&gt;
Eval
  (RightBranchSpread, Edges n) (t (Edge n)) ((), Notes n) (t2 n) Int
</span><a href="PVGrammar.Parse.html#pvCountNoRepSplitRightBranch"><span class="hs-identifier hs-var">pvCountNoRepSplitRightBranch</span></a></span><span>
</span><span id="line-985"></span></pre></body></html>