-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/chfin/proto-voice-model#readme</a>
@package proto-voice-model
@version 0.1.0.0


-- | Common types and functionality that are used throughout the model.
module Common

-- | A Path is a datastructure that represents a sequence of alternating
--   objects, <i>arounds</i> and <i>betweens</i>, starting and ending with
--   the same type. An example would be a path in a graph, starting and
--   ending with a node with edges in-between.
data Path around between
Path :: !around -> !between -> !Path around between -> Path around between
PathEnd :: !around -> Path around between

-- | Returns the number of <i>arounds</i> in the path.
pathLen :: Path a b -> Int

-- | Returns the first <i>around</i> in the path.
pathHead :: Path a b -> a

-- | Replaces the first <i>around</i> in the path.
pathSetHead :: Path a b -> a -> Path a b

-- | Maps a function over every <i>around</i> in the path.
mapArounds :: (a -> a') -> Path a b -> Path a' b

-- | Maps a function over every <i>around</i> in the path together with its
--   index.
mapAroundsWithIndex :: Int -> (Int -> a -> a') -> Path a b -> Path a' b

-- | Maps a function over every <i>between</i> and its adjacent
--   <i>arounds</i> in the path.
mapBetweens :: (a -> b -> a -> c) -> Path a b -> [c]

-- | Reverses the path.
reversePath :: Path a b -> Path a b

-- | Returns the list of <i>arounds</i> in the path.
pathArounds :: Path a b -> [a]

-- | Returns the list of <i>betweens</i> in the path).
pathBetweens :: Path a b -> [b]

-- | A container type that augements the type <tt>a</tt> with symbols for
--   beginning (<a>Start</a>, ⋊) and end (<a>Stop</a>, ⋉). Every other
--   value is wrapped in an <tt>Inner</tt> constructor.
data StartStop a
Start :: StartStop a
Inner :: !a -> StartStop a
Stop :: StartStop a

-- | From a list of <tt>StartStop</tt>s returns only the elements that are
--   not <tt>:⋊</tt> or <tt>:⋉</tt>, unwrapped to their original type.
onlyInner :: [StartStop a] -> [a]

-- | Returns the content of an <a>Inner</a>, or <a>Nothing</a>.
getInner :: StartStop a -> Maybe a

-- | Returns the content of an <a>Inner</a>, or a <a>Left</a> with an error
--   message.
getInnerE :: StartStop a -> Either String a

-- | Returns <a>True</a> iff the argument is an <a>Inner</a>.
isInner :: StartStop a -> Bool

-- | Returns <a>True</a> iff the argument is <a>Start</a>.
isStart :: StartStop a -> Bool

-- | Returns <a>True</a> iff the argument is <a>Stop</a>.
isStop :: StartStop a -> Bool

-- | Turns a pair within a <a>StartStop</a> into a pair of
--   <a>StartStop</a>s
distStartStop :: StartStop (a, b) -> (StartStop a, StartStop b)

-- | A flag that indicates where a split has been performed, on the left
--   transition, the right transition, or the only transition
data SplitType
LeftOfTwo :: SplitType
RightOfTwo :: SplitType
SingleOfOne :: SplitType

-- | An evaluator for unspreads. Takes the two child slices and the middle
--   transition. Returns the parent slice and the spread operation, if
--   possible.
type UnspreadMiddle tr slc v = (slc, tr, slc) -> Maybe (slc, v)

-- | An evaluator returning the possible left parent edges of an unspread.
--   The first argument is a pair of left child transition and left child
--   slice. The second argument is the parent slice.
type UnspreadLeft tr slc = (tr, slc) -> slc -> [tr]

-- | An evaluator returning the possible right parent edges of an unspread.
--   The first argument is a pair of right child slice and right child
--   transition. The second argument is the parent slice.
type UnspreadRight tr slc = (slc, tr) -> slc -> [tr]

-- | An evaluator for unsplits. Returns possible unsplits of a given pair
--   of transitions.
type Unsplit tr slc v = StartStop slc -> tr -> slc -> tr -> StartStop slc -> SplitType -> [(tr, v)]

-- | A combined evaluator for unsplits, unspreads, and unfreezes.
--   Additionally, contains a function for mapping terminal slices to
--   derivation slices.
data Eval tr tr' slc slc' v
Eval :: !UnspreadMiddle tr slc v -> !UnspreadLeft tr slc -> !UnspreadRight tr slc -> !Unsplit tr slc v -> !StartStop slc -> Maybe tr' -> StartStop slc -> IsLast -> [(tr, v)] -> !slc' -> slc -> Eval tr tr' slc slc' v
[evalUnspreadMiddle] :: Eval tr tr' slc slc' v -> !UnspreadMiddle tr slc v
[evalUnspreadLeft] :: Eval tr tr' slc slc' v -> !UnspreadLeft tr slc
[evalUnspreadRight] :: Eval tr tr' slc slc' v -> !UnspreadRight tr slc
[evalUnsplit] :: Eval tr tr' slc slc' v -> !Unsplit tr slc v
[evalUnfreeze] :: Eval tr tr' slc slc' v -> !StartStop slc -> Maybe tr' -> StartStop slc -> IsLast -> [(tr, v)]
[evalSlice] :: Eval tr tr' slc slc' v -> !slc' -> slc

-- | A flag indicating whether an operation is performed on the last
--   transition.
type IsLast = Bool

-- | Maps a function over all scores produced by the evaluator.
mapEvalScore :: (v -> w) -> Eval tr tr' slc slc' v -> Eval tr tr' slc slc' w

-- | Combine two evaluators into a product evaluator. Each evaluation
--   function returns the product of the two component evaluators' results.
productEval :: Eval tr1 tr' slc1 slc' v1 -> Eval tr2 tr' slc2 slc' v2 -> Eval (tr1, tr2) tr' (slc1, slc2) slc' (v1, v2)

-- | A combined evaluator for unsplits, unspreads, and unfreezes with an
--   impure unsplit evaluator. Additionally, contains a function for
--   mapping terminal slices to derivation slices.
data EvalImpure tr tr' slc slc' v
EvalImpure :: Eval tr tr' slc slc' v -> UnsplitImpure tr slc v -> EvalImpure tr tr' slc slc' v
[evalPure] :: EvalImpure tr tr' slc slc' v -> Eval tr tr' slc slc' v
[evalUnsplitRandom] :: EvalImpure tr tr' slc slc' v -> UnsplitImpure tr slc v

-- | A flag that is used to restrict spread operations to right branching.
data RightBranchSpread
RBBranches :: RightBranchSpread
RBClear :: RightBranchSpread

-- | An evaluator that doesn't parse the input but restricts spread
--   operations to right branching. Legal combinations will just return a
--   singleton <tt>()</tt> while illegal combinations return nothing.
--   Combine this with any evaluator as a product (using <a>productEval</a>
--   or <a>rightBranchSpread</a>) to make the evaluator right-branching.
evalRightBranchSpread :: Eval RightBranchSpread tr' () slc' ()

-- | Restrict any evaluator to right-branching spreads.
rightBranchSpread :: Eval tr tr' slc slc' w -> Eval (RightBranchSpread, tr) tr' ((), slc) slc' w

-- | A flag for indicating whether a transition is the result of a split or
--   not. This is used for restricting the order of splits and spreads.
data Merged
Merged :: Merged
NotMerged :: Merged

-- | An evaluator that doesn't parse the input but restricts the order of
--   operations to always have splits before spreads on the left and right
--   transitions at a spread. Legal combinations will just return a
--   singleton <tt>()</tt> while illegal combinations return nothing.
--   Combine this with any evaluator as a product (using <a>productEval</a>
--   or <a>splitFirst</a>) to make the evaluator order-restricted.
evalSplitBeforeSpread :: Eval Merged tr' () slc' ()

-- | Restrict any evaluator to split-before-spread order.
splitFirst :: Eval tr tr' slc slc' w -> Eval (Merged, tr) tr' ((), slc) slc' w

-- | A combined datatype for all leftmost-derivation operations.
data Leftmost s f h
LMSingle :: !LeftmostSingle s f -> Leftmost s f h
LMDouble :: !LeftmostDouble s f h -> Leftmost s f h
pattern LMFreezeLeft :: f -> Leftmost s f h
pattern LMFreezeOnly :: f -> Leftmost s f h
pattern LMSplitLeft :: s -> Leftmost s f h
pattern LMSplitOnly :: s -> Leftmost s f h
pattern LMSplitRight :: s -> Leftmost s f h
pattern LMSpread :: h -> Leftmost s f h

-- | Generative operations on a single transition (split or freeze).
data LeftmostSingle s f
LMSingleSplit :: !s -> LeftmostSingle s f
LMSingleFreeze :: !f -> LeftmostSingle s f

-- | Generative operations on two transitions (split left, freeze left,
--   split right, or spread)
data LeftmostDouble s f h
LMDoubleSplitLeft :: !s -> LeftmostDouble s f h
LMDoubleFreezeLeft :: !f -> LeftmostDouble s f h
LMDoubleSplitRight :: !s -> LeftmostDouble s f h
LMDoubleSpread :: !h -> LeftmostDouble s f h

-- | Encodes an analysis of a piece, consisting of a "top" (the starting
--   point of the derivation, i.e., the smallest reduction in the analysis)
--   and a derivation of the piece's surface from the top.
--   
--   Use this type's <a>FromJSON</a> instance to load an analysis exported
--   by the protovoice annotation tool.
data Analysis s f h tr slc
Analysis :: [Leftmost s f h] -> Path tr slc -> Analysis s f h tr slc

-- | The derivation steps.
[anaDerivation] :: Analysis s f h tr slc -> [Leftmost s f h]

-- | The starting configuration of the derivation. Starts with the first
--   transition, <a>Start</a> and <a>Stop</a> are implied.
[anaTop] :: Analysis s f h tr slc -> Path tr slc

-- | Prints the steps and intermediate configurations of a derivation.
debugAnalysis :: forall tr slc s f h. (Show tr, Show slc, Show s, Show h) => (s -> tr -> Either String (tr, slc, tr)) -> (f -> tr -> Either String tr) -> (h -> tr -> slc -> tr -> Either String (tr, slc, tr, slc, tr)) -> Analysis s f h tr slc -> IO (Either String ())

-- | Create a leftmost evaluator from position-independent evaluation
--   functions that just return spread, split, and freeze operations by
--   wrapping those into the appropriate <a>Leftmost</a> constructors.
mkLeftmostEval :: UnspreadMiddle tr slc h -> UnspreadLeft tr slc -> UnspreadRight tr slc -> (StartStop slc -> tr -> slc -> tr -> StartStop slc -> [(tr, s)]) -> (StartStop slc -> Maybe tr' -> StartStop slc -> [(tr, f)]) -> (slc' -> slc) -> Eval tr tr' slc slc' (Leftmost s f h)
mkLeftmostEvalImpure :: UnspreadMiddle tr slc h -> UnspreadLeft tr slc -> UnspreadRight tr slc -> (StartStop slc -> tr -> slc -> tr -> StartStop slc -> [(tr, s)]) -> (StartStop slc -> tr -> slc -> tr -> StartStop slc -> IO [(tr, s)]) -> (StartStop slc -> Maybe tr' -> StartStop slc -> [(tr, f)]) -> (slc' -> slc) -> EvalImpure tr tr' slc slc' (Leftmost s f h)

-- | A wrapper around leftmost derivations that tracks information about
--   the derivation state in the type. Number of open transitions:
--   <tt>openTrans</tt>. Whether a right split has been performed at the
--   current point: <tt>afterRightSplit</tt>.
newtype PartialDerivation s f h (openTrans :: Nat) (afterRightSplit :: Bool)
PD :: [Leftmost s f h] -> PartialDerivation s f h (openTrans :: Nat) (afterRightSplit :: Bool)
[runPD] :: PartialDerivation s f h (openTrans :: Nat) (afterRightSplit :: Bool) -> [Leftmost s f h]

-- | A type-level wrapper for partial derivation info. Encodes the number
--   of open transitions and whether the last operation was a right split.
data DerivationInfo a b

-- | An "indexed" version of a writer monad, i.e. one where the monad type
--   between two steps can change. This can be used for tracking the number
--   of open transitions in a derivation on the type level while still
--   providing an monadic interface for constructing a derivation.
data IndexedWriter w i j a

-- | <a>tell</a> for <a>IndexedWriter</a>.
itell :: Monoid w => w -> IndexedWriter w i j ()

-- | The type of a monadic derivation action that modifies the derivation
--   state (number of open transitions, after right split).
type DerivationAction s f h n n' afterRight afterRight' = IndexedWriter [Leftmost s f h] (DerivationInfo n afterRight) (DerivationInfo n' afterRight') ()

-- | Turn a monadically constructed derivation into a proper left-most
--   derivation. This function assumes the derivation to start with a
--   single transition.
buildDerivation :: DerivationAction s f h 1 n 'False snd -> [Leftmost s f h]

-- | Turn a monadically constructed partial derivation into a left-most
--   derivation. This function does not restrict the number of transitions
--   in the starting configuration.
buildPartialDerivation :: forall n n' snd s f h. DerivationAction s f h n n' 'False snd -> [Leftmost s f h]

-- | Turn a split operation into a monadic (left or single) split action.
split :: forall n s f h. (KnownNat n, 1 <= n) => s -> DerivationAction s f h n (n + 1) 'False 'False

-- | Turn a freeze operation into a monadic (left or single) freeze action.
freeze :: forall n s h f. (KnownNat n, 1 <= n) => f -> DerivationAction s f h n (n - 1) 'False 'False

-- | Turn a split operation into a monadic right-split action.
splitRight :: 2 <= n => s -> DerivationAction s f h n (n + 1) snd 'True

-- | Turn a spread operation into a monadic spread action.
spread :: 2 <= n => h -> DerivationAction s f h n (n + 1) snd 'False

-- | The derivations semiring. Similar to a free semiring, encodes
--   sequences, alternatives, and neutral values directly. However,
--   semiring equivalences are not idendified by default.
data Derivations a

-- | a single operation
Do :: !a -> Derivations a

-- | combines alternative derivations
Or :: !Derivations a -> !Derivations a -> Derivations a

-- | combines sequential derivations
Then :: !Derivations a -> !Derivations a -> Derivations a

-- | the neutral element to <a>Then</a>
NoOp :: Derivations a

-- | the neutral element to <a>Or</a>
Cannot :: Derivations a

-- | Map the <a>Derivations</a> semiring to another semiring.
mapDerivations :: Semiring r => (a -> r) -> Derivations a -> r

-- | Flatten the prefix-tree structure of <a>Derivations</a> into a simple
--   set of derivations.
flattenDerivations :: Ord a => Derivations a -> Set [a]

-- | Flatten the prefix-tree structure of <a>Derivations</a> into a simple
--   list of (potentially redundant) derivations.
flattenDerivationsRed :: Ord a => Derivations a -> [[a]]

-- | Obtain the first derivation from a <a>Derivations</a> tree.
firstDerivation :: Ord a => Derivations a -> Maybe [a]

-- | The global trace level. Only trace messages &gt;= this level are
--   shown.
traceLevel :: Int

-- | A helper for conditionally tracing a message.
traceIf :: Int -> [Char] -> Bool -> Bool

-- | Convert special characters to TeX commands.
showTex :: Show a => a -> String

-- | Convert special characters to TeX commands (using <a>Text</a>)
showTexT :: Show a => a -> Text
instance GHC.Generics.Generic (Common.Path around between)
instance (GHC.Classes.Ord around, GHC.Classes.Ord between) => GHC.Classes.Ord (Common.Path around between)
instance (GHC.Classes.Eq around, GHC.Classes.Eq between) => GHC.Classes.Eq (Common.Path around between)
instance Data.Traversable.Traversable Common.StartStop
instance Data.Foldable.Foldable Common.StartStop
instance GHC.Base.Functor Common.StartStop
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Common.StartStop a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Common.StartStop a)
instance GHC.Generics.Generic (Common.StartStop a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Common.StartStop a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Common.StartStop a)
instance Data.Hashable.Class.Hashable Common.RightBranchSpread
instance Control.DeepSeq.NFData Common.RightBranchSpread
instance GHC.Generics.Generic Common.RightBranchSpread
instance GHC.Show.Show Common.RightBranchSpread
instance GHC.Classes.Ord Common.RightBranchSpread
instance GHC.Classes.Eq Common.RightBranchSpread
instance Data.Hashable.Class.Hashable Common.Merged
instance Control.DeepSeq.NFData Common.Merged
instance GHC.Generics.Generic Common.Merged
instance GHC.Show.Show Common.Merged
instance GHC.Classes.Ord Common.Merged
instance GHC.Classes.Eq Common.Merged
instance Data.Traversable.Traversable (Common.LeftmostSingle s)
instance Data.Foldable.Foldable (Common.LeftmostSingle s)
instance GHC.Base.Functor (Common.LeftmostSingle s)
instance (Control.DeepSeq.NFData s, Control.DeepSeq.NFData f) => Control.DeepSeq.NFData (Common.LeftmostSingle s f)
instance GHC.Generics.Generic (Common.LeftmostSingle s f)
instance (GHC.Show.Show s, GHC.Show.Show f) => GHC.Show.Show (Common.LeftmostSingle s f)
instance (GHC.Classes.Ord s, GHC.Classes.Ord f) => GHC.Classes.Ord (Common.LeftmostSingle s f)
instance (GHC.Classes.Eq s, GHC.Classes.Eq f) => GHC.Classes.Eq (Common.LeftmostSingle s f)
instance (Control.DeepSeq.NFData s, Control.DeepSeq.NFData f, Control.DeepSeq.NFData h) => Control.DeepSeq.NFData (Common.LeftmostDouble s f h)
instance GHC.Generics.Generic (Common.LeftmostDouble s f h)
instance (GHC.Show.Show s, GHC.Show.Show f, GHC.Show.Show h) => GHC.Show.Show (Common.LeftmostDouble s f h)
instance (GHC.Classes.Ord s, GHC.Classes.Ord f, GHC.Classes.Ord h) => GHC.Classes.Ord (Common.LeftmostDouble s f h)
instance (GHC.Classes.Eq s, GHC.Classes.Eq f, GHC.Classes.Eq h) => GHC.Classes.Eq (Common.LeftmostDouble s f h)
instance (Control.DeepSeq.NFData s, Control.DeepSeq.NFData f, Control.DeepSeq.NFData h) => Control.DeepSeq.NFData (Common.Leftmost s f h)
instance GHC.Generics.Generic (Common.Leftmost s f h)
instance (GHC.Show.Show s, GHC.Show.Show f, GHC.Show.Show h) => GHC.Show.Show (Common.Leftmost s f h)
instance (GHC.Classes.Ord s, GHC.Classes.Ord f, GHC.Classes.Ord h) => GHC.Classes.Ord (Common.Leftmost s f h)
instance (GHC.Classes.Eq s, GHC.Classes.Eq f, GHC.Classes.Eq h) => GHC.Classes.Eq (Common.Leftmost s f h)
instance GHC.Generics.Generic (Common.Analysis s f h tr slc)
instance (GHC.Show.Show s, GHC.Show.Show f, GHC.Show.Show h, GHC.Show.Show tr, GHC.Show.Show slc) => GHC.Show.Show (Common.Analysis s f h tr slc)
instance (GHC.Classes.Ord s, GHC.Classes.Ord f, GHC.Classes.Ord h, GHC.Classes.Ord tr, GHC.Classes.Ord slc) => GHC.Classes.Ord (Common.Analysis s f h tr slc)
instance (GHC.Classes.Eq s, GHC.Classes.Eq f, GHC.Classes.Eq h, GHC.Classes.Eq tr, GHC.Classes.Eq slc) => GHC.Classes.Eq (Common.Analysis s f h tr slc)
instance GHC.Generics.Generic (Common.Derivations a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Common.Derivations a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Common.Derivations a)
instance GHC.Classes.Eq Common.DerivOp
instance GHC.Show.Show a => GHC.Show.Show (Common.Derivations a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Common.Derivations a)
instance Data.Semiring.Semiring (Common.Derivations a)
instance Data.Functor.Indexed.IxFunctor (Common.IndexedWriter w)
instance GHC.Base.Monoid w => Data.Functor.Indexed.IxPointed (Common.IndexedWriter w)
instance GHC.Base.Monoid w => Data.Functor.Indexed.IxApplicative (Common.IndexedWriter w)
instance GHC.Base.Monoid w => Control.Monad.Indexed.IxMonad (Common.IndexedWriter w)
instance (Data.Aeson.Types.FromJSON.FromJSON s, Data.Aeson.Types.FromJSON.FromJSON f, Data.Aeson.Types.FromJSON.FromJSON h, Data.Aeson.Types.FromJSON.FromJSON tr, Data.Aeson.Types.FromJSON.FromJSON slc) => Data.Aeson.Types.FromJSON.FromJSON (Common.Analysis s f h tr slc)
instance (Data.Aeson.Types.FromJSON.FromJSON s, Data.Aeson.Types.FromJSON.FromJSON f, Data.Aeson.Types.FromJSON.FromJSON h) => Data.Aeson.Types.FromJSON.FromJSON (Common.Leftmost s f h)
instance (Data.Aeson.Types.ToJSON.ToJSON s, Data.Aeson.Types.ToJSON.ToJSON f, Data.Aeson.Types.ToJSON.ToJSON h) => Data.Aeson.Types.ToJSON.ToJSON (Common.Leftmost s f h)
instance (Data.Aeson.Types.ToJSON.ToJSON s, Data.Aeson.Types.ToJSON.ToJSON f, Data.Aeson.Types.ToJSON.ToJSON h) => Data.Aeson.Types.ToJSON.ToJSON (Common.LeftmostDouble s f h)
instance (Data.Aeson.Types.ToJSON.ToJSON s, Data.Aeson.Types.ToJSON.ToJSON f) => Data.Aeson.Types.ToJSON.ToJSON (Common.LeftmostSingle s f)
instance GHC.Show.Show a => GHC.Show.Show (Common.StartStop a)
instance Musicology.Pitch.Class.Notation a => Musicology.Pitch.Class.Notation (Common.StartStop a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Common.StartStop a)
instance Data.Bifunctor.Bifunctor Common.Path
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Common.Path a b)


-- | This module contains functions for visualizing derivations using LaTeX
--   and TikZ. These functions are generic over slice and transition
--   contents and are thus somewhat limited. For protovoice derivations, an
--   alternative to plotting a derivation would be to export an
--   <a>Analysis</a> to JSON and view it interactively in the <a>protovoice
--   annotation tool</a> (not implemented yet).
--   
--   Plotting happens in two steps. First, a the derivation is "replayed"
--   using a (generic or grammar-specific) "player" to construct a
--   <a>DerivationGraph</a>, which contains all graphical objects and their
--   positions explicitly. The <a>DerivationGraph</a> can then be plotted
--   using different backends (currently only TikZ, but a diagrams/SVG
--   backed would be useful too).
module Display

-- | A derivation graph. Contains the graphical objects of a derivation
--   plot as well as intermediate information that is used during a replay.
data DerivationGraph slc tr
DGraph :: !Int -> !Set (DerivSlice slc) -> !Set (DerivTrans slc tr) -> !Set (DerivSlice slc, DerivSlice slc) -> ![DerivTrans slc tr] -> ![DerivTrans slc tr] -> ![DerivTrans slc tr] -> DerivationGraph slc tr

-- | a counter for generating new IDs (used during replay)
[dgNextId] :: DerivationGraph slc tr -> !Int

-- | the positioned slices of the derivation graph
[dgSlices] :: DerivationGraph slc tr -> !Set (DerivSlice slc)

-- | the positioned transitionn in the derivation graph
[dgTransitions] :: DerivationGraph slc tr -> !Set (DerivTrans slc tr)

-- | the "horizontalization" edges (connecting the parent slice of a spread
--   to its children)
[dgHoriEdges] :: DerivationGraph slc tr -> !Set (DerivSlice slc, DerivSlice slc)

-- | the open transitions of the current surface
[dgOpen] :: DerivationGraph slc tr -> ![DerivTrans slc tr]

-- | the frozen transitions of the current surface in reverse order
[dgFrozen] :: DerivationGraph slc tr -> ![DerivTrans slc tr]

-- | the root transitions
[dgRoot] :: DerivationGraph slc tr -> ![DerivTrans slc tr]

-- | A slice together with a depth and an ID
data DerivSlice slc
DerivSlice :: !Int -> !Int -> !StartStop slc -> DerivSlice slc
[dslDepth] :: DerivSlice slc -> !Int
[dslId] :: DerivSlice slc -> !Int
[dslContent] :: DerivSlice slc -> !StartStop slc

-- | A transition between two <a>DerivSlice</a>s.
type DerivTrans slc tr = (DerivSlice slc, tr, DerivSlice slc)

-- | Replay a derivation from <tt>⋊——⋉</tt>.
replayDerivation :: (Foldable t, Ord slc, Ord tr) => DerivationPlayer s f h slc tr -> t (Leftmost s f h) -> Either String (DerivationGraph slc tr)

-- | Replay a derivation from <tt>n</tt> top-level transitions.
replayDerivation' :: (Foldable t, Ord slc, Ord tr) => Path tr slc -> DerivationPlayer s f h slc tr -> t (Leftmost s f h) -> Either String (DerivationGraph slc tr)

-- | Replay a derivation from <tt>⋊——⋉</tt> and ensure that the dervation
--   is complete (freezing all transitions). Return an error message if
--   not.
replayDerivationFull :: (Foldable t, Ord slc, Ord tr) => DerivationPlayer s f h slc tr -> t (Leftmost s f h) -> Either String (DerivationGraph slc tr)

-- | Replays a derivation from <tt>⋊——⋉</tt> and returns every intermediate
--   derivation graph.
unfoldDerivation :: (Ord slc, Ord tr) => DerivationPlayer s f h slc tr -> [Leftmost s f h] -> [Either String (DerivationGraph slc tr)]

-- | Replays a derivation from <tt>n</tt> top-level transitions and returns
--   every intermediate derivation graph.
unfoldDerivation' :: (Ord slc, Ord tr) => Path tr slc -> DerivationPlayer s f h slc tr -> [Leftmost s f h] -> [Either String (DerivationGraph slc tr)]

-- | A derivation player. Contains functions for replaying derivations of a
--   particular grammar, i.e. for deriving child elements from parent
--   elements.
data DerivationPlayer s f h slc tr
DerivationPlayer :: !tr -> !s -> tr -> Either String (tr, slc, tr) -> !f -> tr -> Either String tr -> !h -> tr -> slc -> tr -> Either String (tr, slc, tr, slc, tr) -> DerivationPlayer s f h slc tr

-- | the grammars default starting transition for <tt>⋊——⋉</tt>
[dpTopTrans] :: DerivationPlayer s f h slc tr -> !tr

-- | replay a split operation
[dpSplit] :: DerivationPlayer s f h slc tr -> !s -> tr -> Either String (tr, slc, tr)

-- | replay a freeze operation
[dpFreeze] :: DerivationPlayer s f h slc tr -> !f -> tr -> Either String tr

-- | replay a spread operation
[dpSpread] :: DerivationPlayer s f h slc tr -> !h -> tr -> slc -> tr -> Either String (tr, slc, tr, slc, tr)

-- | A derivation player that uses <tt>()</tt> for slice and transition
--   contents. The actual derivation operations are ignored, so only the
--   outer structure is produced.
derivationPlayerUnit :: DerivationPlayer s f h () ()

-- | A derivation player that uses <a>Empty</a> for slice and transition
--   content. The actual derivation operations are ignored, so only the
--   outer structure is produced.
derivationPlayerEmpty :: DerivationPlayer s f h Empty Empty

-- | A helper type that is like <tt>()</tt> but has a <a>Show</a> instance
--   that returns the empty string.
data Empty

-- | Convert a derivation graph into a series of TikZ commands.
tikzDerivationGraph :: (Eq slc, Eq tr) => (slc -> Text) -> (tr -> Text) -> DerivationGraph slc tr -> Text

-- | Wraps TikZ commands in a <tt>tikzpicture</tt> environment.
tikzPic :: (Semigroup a, IsString a) => a -> a

-- | Wraps latex code (e.g. a <tt>tikzpicture</tt>) in a complete
--   standalone document. This environment includes default styles for
--   slices, transitions, and hori edges.
tikzStandalone :: (Semigroup a, IsString a) => Bool -> a -> a

-- | Write a single derivation graph to a <tt>tex</tt> file.
writeGraph :: (Show slc, Eq slc, Eq tr, Show tr) => FilePath -> DerivationGraph slc tr -> IO ()

-- | Write a several derivation graphs to a <tt>tex</tt> file.
writeGraphs :: (Show tr, Show slc, Eq slc, Eq tr) => FilePath -> [DerivationGraph slc tr] -> IO ()

-- | Write a single derivation graph to a <tt>tex</tt> file and compile the
--   file using <tt>pdflatex</tt>.
viewGraph :: (Eq slc, Eq tr, Show slc, Show tr) => FilePath -> DerivationGraph slc tr -> IO ()

-- | Write a several derivation graphs to a <tt>tex</tt> file and compile
--   the file using <tt>pdflatex</tt>.
viewGraphs :: (Show tr, Show slc, Eq slc, Eq tr) => FilePath -> [DerivationGraph slc tr] -> IO ()
instance GHC.Show.Show slc => GHC.Show.Show (Display.DerivSlice slc)
instance GHC.Classes.Ord slc => GHC.Classes.Ord (Display.DerivSlice slc)
instance GHC.Classes.Eq slc => GHC.Classes.Eq (Display.DerivSlice slc)
instance (GHC.Show.Show slc, GHC.Show.Show tr) => GHC.Show.Show (Display.DerivationGraph slc tr)
instance (GHC.Classes.Ord slc, GHC.Classes.Ord tr) => GHC.Classes.Ord (Display.DerivationGraph slc tr)
instance (GHC.Classes.Eq slc, GHC.Classes.Eq tr) => GHC.Classes.Eq (Display.DerivationGraph slc tr)
instance GHC.Classes.Ord Display.Empty
instance GHC.Classes.Eq Display.Empty
instance GHC.Show.Show Display.Empty


-- | This module contains a simple greedy parser for path grammars. The
--   grammar is provided by an evaluator (<a>Eval</a>). In addition, the
--   parser takes a policy function that picks a reduction option in each
--   step.
module GreedyParser

-- | A transition during greedy parsing. Augments transition data with a
--   flag that indicates whether the transition is a transitive right (2nd)
--   parent of a spread.
data Trans tr
Trans :: !tr -> !Bool -> Trans tr

-- | content of the transition
[_tContent] :: Trans tr -> !tr

-- | flag that indicates (transitive) right parents of spreads
[_t2nd] :: Trans tr -> !Bool

-- | The state of the greedy parse between steps. Generally, the current
--   reduction consists of frozen transitions between the ⋊ and the current
--   location and open transitions between the current location and ⋉.
--   
--   <pre>
--   ⋊==[1]==[2]==[3]——[4]——[5]——⋉
--     └ frozen  ┘  | └   open  ┘
--               midSlice (current position)
--   
--   frozen:   ==[2]==[1]==
--   midSlice: [3]
--   open:     ——[4]——[5]——
--   </pre>
--   
--   This is the <a>GSSemiOpen</a> case: The slice at the current pointer
--   (<tt>[3]</tt>) is represented as an individual slice
--   (<tt>midSlice</tt>). The frozen part is represented by a <a>Path</a>
--   of frozen transitions (<tt>tr'</tt>) and slices (<tt>slc</tt>). <b>in
--   reverse direction</b>, i.e. from <tt>midslice</tt> back to ⋊
--   (excluding ⋊). The open part is a <a>Path</a> of open transitions
--   (<tt>tr</tt>) and slices (<tt>slc</tt>) in forward direction from
--   <tt>midSlice</tt> up to ⋉.
--   
--   There are two special cases. All transitions can be frozen
--   (<a>GSFrozen</a>), in which case state only contains the backward
--   <a>Path</a> of frozen transitions (excluding ⋊ and ⋉):
--   
--   <pre>
--   ⋊==[1]==[2]==[3]==⋉
--                      └ current position
--   represented as: ==[3]==[2]==[1]==
--   </pre>
--   
--   Or all transitions can be open (<a>GSOpen</a>), in which case the
--   state is just the forward path of open transitions:
--   
--   <pre>
--   ⋊——[1]——[2]——[3]——⋉
--   └ current position
--   represented as: ——[1]——[2]——[3]——
--   </pre>
--   
--   The open and semiopen case additionally have a list of operations in
--   generative order.
data GreedyState tr tr' slc op
GSFrozen :: !Path (Maybe tr') slc -> GreedyState tr tr' slc op
GSSemiOpen :: !Path (Maybe tr') slc -> !slc -> !Path (Trans tr) slc -> ![op] -> GreedyState tr tr' slc op

-- | frozen transitions and slices from current point leftward
[_gsFrozen] :: GreedyState tr tr' slc op -> !Path (Maybe tr') slc

-- | the slice at the current posision between gsFrozen and gsOpen
[_gsMidSlice] :: GreedyState tr tr' slc op -> !slc

-- | non-frozen transitions and slices from current point rightward
[_gsOpen] :: GreedyState tr tr' slc op -> !Path (Trans tr) slc

-- | derivation from current reduction to original surface
[_gsDeriv] :: GreedyState tr tr' slc op -> ![op]
GSOpen :: !Path (Trans tr) slc -> ![op] -> GreedyState tr tr' slc op

-- | Helper function for showing the frozen part of a piece.
showFrozen :: Show slc => Path tr' slc -> String

-- | Helper function for showing the open part of a piece.
showOpen :: Show slc => Path tr slc -> String

-- | A parsing action (reduction step) with a single parent transition.
--   Combines the parent elements with a single-transition derivation
--   operation.
data ActionSingle slc tr s f
ActionSingle :: (StartStop slc, Trans tr, StartStop slc) -> LeftmostSingle s f -> ActionSingle slc tr s f

-- | A parsing action (reduction step) with two parent transitions.
--   Combines the parent elements with a double-transition derivation
--   operation.
data ActionDouble slc tr s f h
ActionDouble :: (StartStop slc, Trans tr, slc, Trans tr, StartStop slc) -> LeftmostDouble s f h -> ActionDouble slc tr s f h

-- | An alias that combines <a>ActionSingle</a> and <a>ActionDouble</a>,
--   representing all possible reduction steps.
type Action slc tr s f h = Either (ActionSingle slc tr s f) (ActionDouble slc tr s f h)

-- | Parse a piece in a greedy fashion. At each step, a policy chooses from
--   the possible reduction actions, the reduction is applied, and parsing
--   continues until the piece is fully reduced or no more reduction
--   operations are available. Returns the full derivation from the top
--   (<tt>⋊——⋉</tt>) or an error message.
parseGreedy :: forall m tr tr' slc slc' s f h. (Monad m, MonadIO m, Show tr', Show slc, Show tr, Show s, Show f, Show h) => Eval tr tr' slc slc' (Leftmost s f h) -> ([Action slc tr s f h] -> ExceptT String m (Action slc tr s f h)) -> Path slc' tr' -> ExceptT String m (Analysis s f h tr slc)

-- | A policy that picks the next action at random. Must be partially
--   applied with a random generator before passing to <a>parseGreedy</a>.
pickRandom :: StatefulGen g m => g -> [slc] -> ExceptT String m slc

-- | Parse a piece randomly using a fresh random number generator.
parseRandom :: (Show tr', Show slc, Show tr, Show s, Show f, Show h) => Eval tr tr' slc slc' (Leftmost s f h) -> Path slc' tr' -> ExceptT String IO (Analysis s f h tr slc)

-- | Parse a piece randomly using an existing random number generator.
parseRandom' :: (Show tr', Show slc, Show tr, Show s, Show f, Show h, StatefulGen g IO) => g -> Eval tr tr' slc slc' (Leftmost s f h) -> Path slc' tr' -> ExceptT String IO (Analysis s f h tr slc)
instance GHC.Show.Show tr => GHC.Show.Show (GreedyParser.Trans tr)
instance (GHC.Show.Show slc, GHC.Show.Show tr, GHC.Show.Show s, GHC.Show.Show f) => GHC.Show.Show (GreedyParser.ActionSingle slc tr s f)
instance (GHC.Show.Show slc, GHC.Show.Show tr, GHC.Show.Show s, GHC.Show.Show f, GHC.Show.Show h) => GHC.Show.Show (GreedyParser.ActionDouble slc tr s f h)
instance (GHC.Show.Show slc, GHC.Show.Show o) => GHC.Show.Show (GreedyParser.GreedyState tr tr' slc o)

module Harmony.ChordLabel

-- | DCML Chord Types
data ChordType
Major :: ChordType
Minor :: ChordType
DominantSeventh :: ChordType
Diminished :: ChordType
FullDiminished :: ChordType
MinorSeventh :: ChordType
HalfDiminished :: ChordType
MajorSeventh :: ChordType
Augmented :: ChordType
GermanSixth :: ChordType
ItalianSixth :: ChordType
FrenchSixth :: ChordType
MinorMajorSeventh :: ChordType
AugmentedSeventh :: ChordType
data ChordLabel
ChordLabel :: ChordType -> SPC -> ChordLabel
[chordType] :: ChordLabel -> ChordType
[rootNote] :: ChordLabel -> SPC
mkLbl :: Int -> ChordType -> ChordLabel
instance GHC.Classes.Ord Harmony.ChordLabel.ChordType
instance GHC.Enum.Bounded Harmony.ChordLabel.ChordType
instance GHC.Enum.Enum Harmony.ChordLabel.ChordType
instance GHC.Classes.Eq Harmony.ChordLabel.ChordType
instance GHC.Classes.Ord Harmony.ChordLabel.ChordLabel
instance GHC.Classes.Eq Harmony.ChordLabel.ChordLabel
instance GHC.Generics.Generic Harmony.ChordLabel.ChordLabel
instance GHC.Show.Show Harmony.ChordLabel.ChordLabel
instance GHC.Read.Read Harmony.ChordLabel.ChordType
instance GHC.Show.Show Harmony.ChordLabel.ChordType

module Harmony.Params
data Params
Params :: Vector Double -> Vector (Vector Double) -> Vector (Vector Double) -> Vector Double -> Vector Double -> Double -> Double -> Params
[params_p_harmony] :: Params -> Vector Double
[params_p_chordtones] :: Params -> Vector (Vector Double)
[params_p_ornaments] :: Params -> Vector (Vector Double)
[alpha_p_ict] :: Params -> Vector Double
[beta_p_ict] :: Params -> Vector Double
[alpha_rate_notes] :: Params -> Double
[beta_rate_notes] :: Params -> Double
params :: Params
chordToneParams :: Vector (Vector Double)
ornamentParams :: Vector (Vector Double)
labelParams :: Vector Double
instance GHC.Show.Show Harmony.Params.Params
instance GHC.Generics.Generic Harmony.Params.Params

module HarmonyModel


-- | A simple implementation of multisets as hash maps to counts. Supports
--   just what is needed for protovoice slices.
module Internal.MultiSet

-- | A hash multiset. A unordered collection of items that can occur
--   several times.
newtype MultiSet a
MS :: HashMap a Int -> MultiSet a
[unMS] :: MultiSet a -> HashMap a Int
toList :: MultiSet a -> [a]
all :: (a -> Bool) -> MultiSet a -> Bool
toOccurList :: MultiSet k -> [(k, Int)]
distinctElems :: MultiSet k -> [k]
union :: (Eq a, Hashable a) => MultiSet a -> MultiSet a -> MultiSet a
unions :: (Foldable t, Eq a0, Hashable a0) => t (MultiSet a0) -> MultiSet a0
maxUnion :: (Eq a, Hashable a) => MultiSet a -> MultiSet a -> MultiSet a
deleteN :: Int -> Int -> Maybe Int
(\\) :: (Eq a, Hashable a) => MultiSet a -> MultiSet a -> MultiSet a
toSet :: MultiSet k -> HashSet k
size :: MultiSet a -> Int
map :: (Eq b, Hashable b) => (a -> b) -> MultiSet a -> MultiSet b
traverse :: (Eq b, Hashable b, Applicative f) => (a -> f b) -> MultiSet a -> f (MultiSet b)
filter :: (a -> Bool) -> MultiSet a -> MultiSet a
fromList :: (Foldable t, Eq a, Hashable a) => t a -> MultiSet a
fromSet :: (Foldable t, Eq a, Hashable a) => t a -> MultiSet a
null :: MultiSet k -> Bool
delete :: (Eq a, Hashable a) => a -> MultiSet a -> MultiSet a
empty :: MultiSet a
foldM :: Monad m => (b -> a -> m b) -> b -> MultiSet a -> m b
insertMany :: (Eq a, Hashable a) => a -> Int -> MultiSet a -> MultiSet a
insert :: (Eq a, Hashable a) => a -> MultiSet a -> MultiSet a
singleton :: Hashable a => a -> MultiSet a
member :: (Eq k, Hashable k) => k -> MultiSet k -> Bool
lookup :: (Eq k, Hashable k) => k -> MultiSet k -> Int
(!) :: (Eq k, Hashable k) => MultiSet k -> k -> Int
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Internal.MultiSet.MultiSet a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Internal.MultiSet.MultiSet a)
instance GHC.Generics.Generic (Internal.MultiSet.MultiSet a)
instance GHC.Show.Show a => GHC.Show.Show (Internal.MultiSet.MultiSet a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Internal.MultiSet.MultiSet a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Internal.MultiSet.MultiSet a)
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => GHC.Base.Semigroup (Internal.MultiSet.MultiSet a)


-- | This module contains common datatypes and functions specific to the
--   protovoice grammar. In a protovoice derivations, slices are multisets
--   of notes while transitions contain connections between these notes.
--   
--   Code that is specific to parsing can be found in
--   <a>PVGrammar.Parse</a>, while generative code is located in
--   <a>PVGrammar.Generate</a>.
module PVGrammar

-- | The content type of slices in the protovoice model. Contains a
--   multiset of pitches, representing the notes in a slice.
newtype Notes n
Notes :: MultiSet n -> Notes n

-- | Return the notes or start/stop symbols inside a slice. This is useful
--   to get all objects that an <a>Edge</a> can connect to.
innerNotes :: StartStop (Notes n) -> [StartStop n]

-- | The content type of transitions in the protovoice model. Contains a
--   multiset of regular edges and a multiset of passing edges. The
--   represented edges are those that are definitely used later on. Edges
--   that are not used are dropped before creating a child transition. A
--   transition that contains passing edges cannot be frozen.
data Edges n
Edges :: !HashSet (Edge n) -> !MultiSet (InnerEdge n) -> Edges n

-- | regular edges
[edgesReg] :: Edges n -> !HashSet (Edge n)

-- | passing edges
[edgesPass] :: Edges n -> !MultiSet (InnerEdge n)

-- | The starting transition of a derivation (<tt>⋊——⋉</tt>).
topEdges :: Hashable n => Edges n

-- | A proto-voice edge between two nodes (i.e. notes or start/stop
--   symbols).
type Edge n = (StartStop n, StartStop n)

-- | A proto-voice edge between two notes (excluding start/stop symbols).
type InnerEdge n = (n, n)

-- | Represents a freeze operation. Since this just ties all remaining
--   edges (which must all be repetitions) no decisions have to be encoded.
data Freeze
FreezeOp :: Freeze

-- | Encodes the decisions made in a split operation. Contains a list of
--   elaborations for every parent edge and note. Each elaboration contains
--   the child pitch, and the corresponding ornament. For every produced
--   edge, a decisions is made whether to keep it or not.
data Split n
SplitOp :: !Map (Edge n) [(n, DoubleOrnament)] -> !Map (InnerEdge n) [(n, PassingOrnament)] -> !Map n [(n, RightOrnament)] -> !Map n [(n, LeftOrnament)] -> !HashSet (Edge n) -> !HashSet (Edge n) -> !MultiSet (InnerEdge n) -> !MultiSet (InnerEdge n) -> Split n

-- | Maps every regular edge to a list of ornamentations.
[splitReg] :: Split n -> !Map (Edge n) [(n, DoubleOrnament)]

-- | Maps every passing edge to a passing tone. Since every passing edge is
--   elaborated exactly once but there can be several instances of the same
--   edge in a transition, the "same" edge can be elaborated with several
--   passing notes, one for each instance of the edge.
[splitPass] :: Split n -> !Map (InnerEdge n) [(n, PassingOrnament)]

-- | Maps notes from the left parent slice to lists of ornamentations.
[fromLeft] :: Split n -> !Map n [(n, RightOrnament)]

-- | Maps notes from the right parent slice to lists of ornamentations.
[fromRight] :: Split n -> !Map n [(n, LeftOrnament)]

-- | The set of regular edges to keep in the left child transition.
[keepLeft] :: Split n -> !HashSet (Edge n)

-- | The set of regular edges to keep in the right child transition.
[keepRight] :: Split n -> !HashSet (Edge n)

-- | Contains the new passing edges introduced in the left child transition
--   (excluding those passed down from the parent transition).
[passLeft] :: Split n -> !MultiSet (InnerEdge n)

-- | Contains the new passing edges introduced in the right child
--   transition (excluding those passed down from the parent transition).
[passRight] :: Split n -> !MultiSet (InnerEdge n)

-- | Two-sided ornament types (two parents).
data DoubleOrnament

-- | a full neighbor note
FullNeighbor :: DoubleOrnament

-- | a repetition of both parents (which have the same pitch)
FullRepeat :: DoubleOrnament

-- | a repetition of the right parent
LeftRepeatOfRight :: DoubleOrnament

-- | a repetitions of the left parent
RightRepeatOfLeft :: DoubleOrnament

-- | a note inserted at the top of the piece (between ⋊ and ⋉)
RootNote :: DoubleOrnament

-- | Returns <a>True</a> if the child repeats the left parent
isRepetitionOnLeft :: DoubleOrnament -> Bool

-- | Returns <a>True</a> if the child repeats the right parent
isRepetitionOnRight :: DoubleOrnament -> Bool

-- | Types of passing notes (two parents).
data PassingOrnament

-- | a connecting passing note (step to both parents)
PassingMid :: PassingOrnament

-- | a step from the left parent
PassingLeft :: PassingOrnament

-- | a step from the right parent
PassingRight :: PassingOrnament

-- | Types of single-sided ornaments left of the parent
--   (<tt>child-parent</tt>)
--   
--   <pre>
--   [ ] [p]
--       /
--     [c]
--   </pre>
data LeftOrnament

-- | an incomplete left neighbor
LeftNeighbor :: LeftOrnament

-- | an incomplete left repetition
LeftRepeat :: LeftOrnament

-- | Types of single-sided ornaments right of the parent
--   (<tt>parent--child</tt>).
--   
--   <pre>
--   [p] [ ]
--     \
--     [c]
--   </pre>
data RightOrnament

-- | an incomplete right neighbor
RightNeighbor :: RightOrnament

-- | an incomplete right repetition
RightRepeat :: RightOrnament

-- | Represents a spread operation. Records for every pitch how it is
--   distributed (see <a>SpreadDirection</a>). The resulting edges
--   (repetitions and passing edges) are represented in a child transition.
data Spread n
SpreadOp :: !HashMap n SpreadDirection -> !Edges n -> Spread n

-- | Encodes the distribution of a pitch in a spread.
--   
--   All instances of a pitch must be either moved completely to the left
--   or the right (or both). In addition, some instances may be repeated on
--   the other side. The difference is indicated by the field of the
--   <a>ToLeft</a> and <a>ToRight</a> constructors. For example, <tt>ToLeft
--   3</tt> indicates that out of <tt>n</tt> instances, all <tt>n</tt> are
--   moved to the left and <tt>n-3</tt> are replicated on the right.
data SpreadDirection

-- | all to the left, n fewer to the right
ToLeft :: !Int -> SpreadDirection

-- | all to the right, n fewer to the left
ToRight :: !Int -> SpreadDirection

-- | all to both
ToBoth :: SpreadDirection

-- | <a>Leftmost</a> specialized to the split, freeze, and spread
--   operations of the grammar.
type PVLeftmost n = Leftmost (Split n) Freeze (Spread n)

-- | An <a>Analysis</a> specialized to PV types.
type PVAnalysis n = Analysis (Split n) Freeze (Spread n) (Edges n) (Notes n)

-- | Apply an applicative action to all pitches in an analysis.
analysisTraversePitch :: (Applicative f, Eq n', Hashable n', Ord n') => (n -> f n') -> PVAnalysis n -> f (PVAnalysis n')

-- | Map a function over all pitches in an analysis.
analysisMapPitch :: (Eq n', Hashable n', Ord n') => (n -> n') -> PVAnalysis n -> PVAnalysis n'

-- | Loads an analysis from a JSON file (as exported by the annotation
--   tool).
loadAnalysis :: FilePath -> IO (Either String (PVAnalysis SPitch))

-- | Loads an analysis from a JSON file (as exported by the annotation
--   tool). Converts all pitches to pitch classes.
loadAnalysis' :: FilePath -> IO (Either String (PVAnalysis SPC))

-- | Loads a MusicXML file and returns a list of salami slices. Each note
--   is expressed as a pitch and a flag that indicates whether the note
--   continues in the next slice.
slicesFromFile :: FilePath -> IO [[(SPitch, RightTied)]]

-- | Converts salami slices (as returned by <a>slicesFromFile</a>) to a
--   path as expected by parsers.
slicesToPath :: (Interval i, Ord i, Eq i) => [[(Pitch i, RightTied)]] -> Path [Pitch i] [Edge (Pitch i)]

-- | Loads a MusicXML File and returns a surface path as input to parsers.
loadSurface :: FilePath -> IO (Path [Pitch SInterval] [Edge (Pitch SInterval)])

-- | Loads a MusicXML File and returns a surface path of the given range of
--   slices.
loadSurface' :: FilePath -> Int -> Int -> IO (Path [Pitch SInterval] [Edge (Pitch SInterval)])
instance Data.Hashable.Class.Hashable n => Data.Hashable.Class.Hashable (PVGrammar.Notes n)
instance Control.DeepSeq.NFData n => Control.DeepSeq.NFData (PVGrammar.Notes n)
instance GHC.Generics.Generic (PVGrammar.Notes n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (PVGrammar.Notes n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (PVGrammar.Notes n)
instance Data.Hashable.Class.Hashable n => Data.Hashable.Class.Hashable (PVGrammar.Edges n)
instance Control.DeepSeq.NFData n => Control.DeepSeq.NFData (PVGrammar.Edges n)
instance GHC.Generics.Generic (PVGrammar.Edges n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (PVGrammar.Edges n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (PVGrammar.Edges n)
instance Control.DeepSeq.NFData PVGrammar.DoubleOrnament
instance Data.Aeson.Types.FromJSON.FromJSON PVGrammar.DoubleOrnament
instance Data.Aeson.Types.ToJSON.ToJSON PVGrammar.DoubleOrnament
instance GHC.Generics.Generic PVGrammar.DoubleOrnament
instance GHC.Show.Show PVGrammar.DoubleOrnament
instance GHC.Classes.Ord PVGrammar.DoubleOrnament
instance GHC.Classes.Eq PVGrammar.DoubleOrnament
instance Control.DeepSeq.NFData PVGrammar.PassingOrnament
instance Data.Aeson.Types.FromJSON.FromJSON PVGrammar.PassingOrnament
instance Data.Aeson.Types.ToJSON.ToJSON PVGrammar.PassingOrnament
instance GHC.Generics.Generic PVGrammar.PassingOrnament
instance GHC.Show.Show PVGrammar.PassingOrnament
instance GHC.Classes.Ord PVGrammar.PassingOrnament
instance GHC.Classes.Eq PVGrammar.PassingOrnament
instance Control.DeepSeq.NFData PVGrammar.LeftOrnament
instance Data.Aeson.Types.FromJSON.FromJSON PVGrammar.LeftOrnament
instance Data.Aeson.Types.ToJSON.ToJSON PVGrammar.LeftOrnament
instance GHC.Generics.Generic PVGrammar.LeftOrnament
instance GHC.Show.Show PVGrammar.LeftOrnament
instance GHC.Classes.Ord PVGrammar.LeftOrnament
instance GHC.Classes.Eq PVGrammar.LeftOrnament
instance Control.DeepSeq.NFData PVGrammar.RightOrnament
instance Data.Aeson.Types.FromJSON.FromJSON PVGrammar.RightOrnament
instance Data.Aeson.Types.ToJSON.ToJSON PVGrammar.RightOrnament
instance GHC.Generics.Generic PVGrammar.RightOrnament
instance GHC.Show.Show PVGrammar.RightOrnament
instance GHC.Classes.Ord PVGrammar.RightOrnament
instance GHC.Classes.Eq PVGrammar.RightOrnament
instance Control.DeepSeq.NFData n => Control.DeepSeq.NFData (PVGrammar.Split n)
instance GHC.Generics.Generic (PVGrammar.Split n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (PVGrammar.Split n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (PVGrammar.Split n)
instance Control.DeepSeq.NFData PVGrammar.Freeze
instance GHC.Generics.Generic PVGrammar.Freeze
instance GHC.Classes.Ord PVGrammar.Freeze
instance GHC.Classes.Eq PVGrammar.Freeze
instance Control.DeepSeq.NFData PVGrammar.SpreadDirection
instance GHC.Generics.Generic PVGrammar.SpreadDirection
instance GHC.Show.Show PVGrammar.SpreadDirection
instance GHC.Classes.Ord PVGrammar.SpreadDirection
instance GHC.Classes.Eq PVGrammar.SpreadDirection
instance Control.DeepSeq.NFData n => Control.DeepSeq.NFData (PVGrammar.Spread n)
instance GHC.Generics.Generic (PVGrammar.Spread n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (PVGrammar.Spread n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (PVGrammar.Spread n)
instance Musicology.Pitch.Class.Notation n => GHC.Show.Show (PVGrammar.Spread n)
instance (Musicology.Pitch.Class.Notation n, GHC.Classes.Eq n, Data.Hashable.Class.Hashable n) => Data.Aeson.Types.FromJSON.FromJSON (PVGrammar.Spread n)
instance GHC.Base.Semigroup PVGrammar.SpreadDirection
instance GHC.Base.Monoid PVGrammar.SpreadDirection
instance GHC.Show.Show PVGrammar.Freeze
instance Data.Aeson.Types.FromJSON.FromJSON PVGrammar.Freeze
instance Musicology.Pitch.Class.Notation n => GHC.Show.Show (PVGrammar.Split n)
instance (GHC.Classes.Ord n, Data.Hashable.Class.Hashable n) => GHC.Base.Semigroup (PVGrammar.Split n)
instance (GHC.Classes.Ord n, Data.Hashable.Class.Hashable n) => GHC.Base.Monoid (PVGrammar.Split n)
instance (Musicology.Pitch.Class.Notation n, GHC.Classes.Ord n, Data.Hashable.Class.Hashable n) => Data.Aeson.Types.FromJSON.FromJSON (PVGrammar.Split n)
instance (Data.Hashable.Class.Hashable n, GHC.Classes.Eq n) => GHC.Base.Semigroup (PVGrammar.Edges n)
instance (Data.Hashable.Class.Hashable n, GHC.Classes.Eq n) => GHC.Base.Monoid (PVGrammar.Edges n)
instance Musicology.Pitch.Class.Notation n => GHC.Show.Show (PVGrammar.Edges n)
instance (GHC.Classes.Eq n, Data.Hashable.Class.Hashable n, Musicology.Pitch.Class.Notation n) => Data.Aeson.Types.FromJSON.FromJSON (PVGrammar.Edges n)
instance Musicology.Pitch.Class.Notation n => GHC.Show.Show (PVGrammar.Notes n)
instance (Musicology.Pitch.Class.Notation n, GHC.Classes.Eq n, Data.Hashable.Class.Hashable n) => Data.Aeson.Types.FromJSON.FromJSON (PVGrammar.Notes n)


-- | This module contains
module PBHModel
data HarmonicProfileData
HarmonicProfileData :: Params -> [String] -> HarmonicProfileData
[params] :: HarmonicProfileData -> Params
[chordtypes] :: HarmonicProfileData -> [String]

-- | Load the paramaters from the JSON
loadParams :: FilePath -> IO HarmonicProfileData
data ChordLabel
ChordLabel :: String -> SPC -> ChordLabel
[chordType] :: ChordLabel -> String
[rootNote] :: ChordLabel -> SPC

-- | Provides a score measuring how much the slice matches the chord
--   annoation
evaluateSlice :: HarmonicProfileData -> Notes SIC -> String -> Double
mostLikelyChordFromSlice :: HarmonicProfileData -> Notes SPitch -> (SPC, String, Double)
chordToneLogLikelihood :: HarmonicProfileData -> ChordLabel -> SIC -> Double
multinomialLogProb :: [Double] -> [Double] -> Double
categoricalLogProb :: Int -> [Double] -> Double
transposeNote :: Pitch SIC -> SPitch -> SIC
ornamentLogLikelihood :: HarmonicProfileData -> ChordLabel -> SIC -> Double
ornamentLogLikelihoodDouble :: HarmonicProfileData -> ChordLabel -> ChordLabel -> SPitch -> Double
sliceChordLogLikelihood :: HarmonicProfileData -> ChordLabel -> Notes SIC -> Double
chordToneLogLikelihoodDouble :: HarmonicProfileData -> ChordLabel -> ChordLabel -> SPitch -> Double
sliceChordWeightedLogLikelihoods :: HarmonicProfileData -> Notes SPitch -> [(Double, SPC, Int)]
sliceChordWeightedLogLikelihood :: HarmonicProfileData -> String -> Notes SIC -> Double

-- | Provides a score measuring how much the slice matches the chord
--   annoation
scoreSegment :: HarmonicProfileData -> Notes SPitch -> ChordLabel -> Double

-- | Provides a score measuring how much the slice matches the chord
--   annoation
scoreSegment' :: HarmonicProfileData -> Notes SPitch -> ChordLabel -> Double
scoreSegments :: HarmonicProfileData -> (HarmonicProfileData -> Notes SPitch -> ChordLabel -> Double) -> [Notes SPitch] -> [ChordLabel] -> Double
instance GHC.Classes.Eq PBHModel.ChordLabel
instance GHC.Generics.Generic PBHModel.ChordLabel
instance GHC.Show.Show PBHModel.Params
instance GHC.Generics.Generic PBHModel.Params
instance GHC.Show.Show PBHModel.HarmonicProfileData
instance GHC.Generics.Generic PBHModel.HarmonicProfileData
instance Data.Aeson.Types.FromJSON.FromJSON PBHModel.HarmonicProfileData
instance Data.Aeson.Types.FromJSON.FromJSON PBHModel.Params
instance GHC.Show.Show PBHModel.ChordLabel


-- | This module contains functions for the generative aspects of
--   protovoice derivations:
--   
--   <ul>
--   <li>manually constructing protovoice operations (see <a>PVGrammar</a>)
--   using a monadic interface</li>
--   <li>applying ("replaying") these operations.</li>
--   </ul>
module PVGrammar.Generate

-- | Create a freeze operation (alias for <a>FreezeOp</a>). Can be used
--   together with the <a>freeze</a> action within a monadic derivation.
mkFreeze :: Freeze

-- | Create a split operation monadically
--   
--   <pre>
--   mkSplit $ do
--     ... -- internal split actions
--   </pre>
--   
--   Can be used together with the <a>split</a> action within a monadic
--   derivation.
mkSplit :: Writer (Split n) a -> Split n

-- | During a split, split an existing regular edge between two notes.
splitRegular :: (Ord n, Hashable n) => StartStop n -> StartStop n -> n -> DoubleOrnament -> Bool -> Bool -> Writer (Split n) ()

-- | During a split, split an existing passing edge, introducing a new
--   passing note.
splitPassing :: (Ord n, Hashable n) => n -> n -> n -> PassingOrnament -> Bool -> Bool -> Writer (Split n) ()

-- | During a split, add a new single-sided ornament to a left parent note.
addToLeft :: (Ord n, Hashable n) => n -> n -> RightOrnament -> Bool -> Writer (Split n) ()

-- | During a split, add a new single-sided ornament to a right parent
--   note.
addToRight :: (Ord n, Hashable n) => n -> n -> LeftOrnament -> Bool -> Writer (Split n) ()

-- | During a split, add a new passing edge between the left parent slice
--   and the child slice.
addPassingLeft :: (Ord n, Hashable n) => n -> n -> Writer (Split n) ()

-- | During a split, add a new passing edge between the child slice and the
--   right parent slice.
addPassingRight :: (Ord n, Hashable n) => n -> n -> Writer (Split n) ()

-- | Create a spread operation monadically
--   
--   <pre>
--   mkSpread $ do
--     ... -- internal spread actions
--   </pre>
--   
--   Can be used together with the <a>spread</a> action within a monadic
--   derivation.
mkSpread :: Writer (Endo (Spread n)) () -> Spread n

-- | During a spread, distribute one of the parent notes to the child
--   slices of a spread.
spreadNote :: (Ord n, Hashable n) => n -> SpreadDirection -> Bool -> Writer (Endo (Spread n)) ()

-- | During a spread, add a new passing edge between the child slices of a
--   spread.
addPassing :: (Ord n, Hashable n) => n -> n -> Writer (Endo (Spread n)) ()

-- | During a spread, add a new repetition edge between two notes of the
--   same pitch class but from different octaves.
addOctaveRepetition :: (Ord n, Hashable n) => n -> n -> Writer (Endo (Spread n)) ()

-- | A derivation player for protovoices. The default version of the PV
--   player drops all edges that are not used later on when generating
--   child transitions. This behaviour matches the intermediate
--   representation of the parsers, which only track edges that are
--   necessary to explain the downstream notes. If you want to generate all
--   edges (i.e., all functional relations between notes) use
--   <a>derivationPlayerPVAllEdges</a>.
derivationPlayerPV :: (Eq n, Ord n, Notation n, Hashable n, Eq (IntervalOf n), HasPitch n) => DerivationPlayer (Split n) Freeze (Spread n) (Notes n) (Edges n)

-- | A derivation player for protovoices that produces all edges that
--   express a functional relation between two notes. For a version that
--   only produces "necessary" edges, use <a>derivationPlayerPV</a>.
derivationPlayerPVAllEdges :: (Eq n, Ord n, Notation n, Hashable n, Eq (IntervalOf n), HasPitch n) => DerivationPlayer (Split n) Freeze (Spread n) (Notes n) (Edges n)

-- | Tries to apply a split operation to the parent transition.
applySplit :: forall n. (Ord n, Notation n, Hashable n) => Split n -> Edges n -> Either String (Edges n, Notes n, Edges n)

-- | A variant of <a>applySplit</a> that inserts all protovoice edges into
--   the child transitions, even those that are not "kept" (used for
--   further elaboration). This is useful when you want to see all
--   relations between notes in the piece.
applySplitAllEdges :: forall n. (Ord n, Notation n, Hashable n) => Split n -> Edges n -> Either String (Edges n, Notes n, Edges n)

-- | Tries to apply a freeze operation to a transition.
applyFreeze :: (Eq (IntervalOf n), HasPitch n) => Freeze -> Edges n -> Either String (Edges n)

-- | Tries to apply a spread operation to the parent transitions and slice.
applySpread :: forall n. (Ord n, Notation n, Hashable n) => Spread n -> Edges n -> Notes n -> Edges n -> Either String (Edges n, Notes n, Edges n, Notes n, Edges n)

-- | Indicates whether a transition can be frozen (i.e., doesn't contain
--   non-"tie" edges).
freezable :: (Eq (IntervalOf n), HasPitch n) => Edges n -> Bool

-- | A specialized version of <a>debugAnalysis</a> for protovoice
--   derivations. Prints the steps and intermediate configurations of a
--   derivation.
debugPVAnalysis :: (Notation n, Ord n, Hashable n, HasPitch n, Eq (IntervalOf n)) => PVAnalysis n -> IO (Either String ())

-- | Compares the output of a derivation with the original piece (as
--   provided to the parser). Returns <a>True</a> if the output matches the
--   original and <a>False</a> if the output doesn't match or the
--   derivation is invalid.
checkDerivation :: (Ord n, Notation n, Hashable n, Eq (IntervalOf n), HasPitch n, Show n) => [Leftmost (Split n) Freeze (Spread n)] -> Path [n] [Edge n] -> Bool


-- | This module contains a simple (and musically rather naive)
--   probabilistic model of protovoice derivations. This model can be used
--   to sample a derivation, evaluate a derivations probability, or infer
--   posterior distributions of the model parmeters from given derivations
--   (i.e., "learn" the model's probabilities).
--   
--   This model is a <i>locally conjugate</i> model: It samples a
--   derivation using a sequence of random decisions with certain
--   probabilities. These probabilities are generally unknown, so they are
--   themselves modeled as random variables with prior distributions. The
--   full model &lt;math&gt; thus splits into &lt;math&gt; the prior over
--   the probability variables &lt;math&gt; and the likelihood of the
--   derivation(s) given these probabilities &lt;math&gt; Given all prior
--   decisions, the likelihood of a decision &lt;math&gt; based on some
--   parameter &lt;math&gt; &lt;math&gt; is <a>conjugate</a> with the prior
--   of that parameter &lt;math&gt;, which means that the posterior of the
--   parameters given one (or several) derivation(s) &lt;math&gt; can be
--   computed analytically.
--   
--   The parameters &lt;math&gt; and their prior distributions are
--   represented by the higher-kinded type <a>PVParams</a>. Different
--   instantiations of this type (using <a>Hyper</a> or <a>Probs</a>)
--   results in concrete record types that represent prior or posterior
--   distributions or concrete values (probabilities) for the parameters.
--   <a>PVParams</a> also supports <a>jeffreysPrior</a> and
--   <a>uniformPrior</a> as default priors, as well as <a>sampleProbs</a>
--   for sampling from a prior (see <a>Inferenc.Conjugate</a>).
--   
--   The likelihood &lt;math&gt; of a derivation is represented by
--   <a>sampleDerivation</a>. It can be executed under different "modes"
--   (probability monads) for sampling, inference, or tracing (see
--   <a>Inference.Conjugate</a>). The decisions during the derivation are
--   represented by a <a>Trace</a> (here <tt>Trace PVParams</tt>). In order
--   to learn from a given derivation, the corresponding trace can be
--   obtained using <a>observeDerivation</a>. A combination of getting a
--   trace and learning from it is provided by <a>trainSinglePiece</a>.
module PVGrammar.Prob.Simple

-- | The combined parameters for inner and outer operations.
data PVParams f
PVParams :: PVParamsOuter f -> PVParamsInner f -> PVParams f
[_pOuter] :: PVParams f -> PVParamsOuter f
[_pInner] :: PVParams f -> PVParamsInner f

-- | Parameters for decisions about outer operations (split, spread,
--   freeze).
data PVParamsOuter f
PVParamsOuter :: f Beta -> f Beta -> f Beta -> f Beta -> PVParamsOuter f
[_pSingleFreeze] :: PVParamsOuter f -> f Beta
[_pDoubleLeft] :: PVParamsOuter f -> f Beta
[_pDoubleLeftFreeze] :: PVParamsOuter f -> f Beta
[_pDoubleRightSplit] :: PVParamsOuter f -> f Beta

-- | Parameters for decisions about inner operations (elaboration and
--   distribution within splits and spreads).
data PVParamsInner f
PVParamsInner :: f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f Beta -> f (Dirichlet 3) -> f Beta -> f Beta -> PVParamsInner f
[_pElaborateRegular] :: PVParamsInner f -> f Beta
[_pElaborateL] :: PVParamsInner f -> f Beta
[_pElaborateR] :: PVParamsInner f -> f Beta
[_pRootFifths] :: PVParamsInner f -> f Beta
[_pKeepL] :: PVParamsInner f -> f Beta
[_pKeepR] :: PVParamsInner f -> f Beta
[_pRepeatOverNeighbor] :: PVParamsInner f -> f Beta
[_pNBChromatic] :: PVParamsInner f -> f Beta
[_pNBAlt] :: PVParamsInner f -> f Beta
[_pRepeatLeftOverRight] :: PVParamsInner f -> f Beta
[_pRepeatAlter] :: PVParamsInner f -> f Beta
[_pRepeatAlterUp] :: PVParamsInner f -> f Beta
[_pRepeatAlterSemis] :: PVParamsInner f -> f Beta
[_pConnect] :: PVParamsInner f -> f Beta
[_pConnectChromaticLeftOverRight] :: PVParamsInner f -> f Beta
[_pPassUp] :: PVParamsInner f -> f Beta
[_pPassLeftOverRight] :: PVParamsInner f -> f Beta
[_pNewPassingLeft] :: PVParamsInner f -> f Beta
[_pNewPassingRight] :: PVParamsInner f -> f Beta
[_pNewPassingMid] :: PVParamsInner f -> f Beta
[_pNoteSpreadDirection] :: PVParamsInner f -> f (Dirichlet 3)
[_pNotesOnOtherSide] :: PVParamsInner f -> f Beta
[_pSpreadRepetitionEdge] :: PVParamsInner f -> f Beta

-- | A probabilistic program that samples a derivation starting from a
--   given root path. Can be interpreted by the interpreter functions in
--   <a>Inference.Conjugate</a>.
sampleDerivation :: _ => Path (Edges SPitch) (Notes SPitch) -> m (Either String [PVLeftmost SPitch])

-- | A shorthand for <a>sampleDerivation</a> starting from ⋊——⋉.
sampleDerivation' :: _ => m (Either String [PVLeftmost SPitch])

-- | Walk through a derivation (starting at a given root path) and return
--   the corresponding <a>Trace</a> (if possible). The trace can be used
--   together with <a>sampleDerivation</a> for inference
--   (<a>getPosterior</a>) or for showing the trace (<a>printTrace</a>).
observeDerivation :: [PVLeftmost SPitch] -> Path (Edges SPitch) (Notes SPitch) -> Either String (Trace PVParams)

-- | A shorthand for <a>observeDerivation</a> starting from ⋊——⋉.
observeDerivation' :: [PVLeftmost SPitch] -> Either String (Trace PVParams)

-- | A helper function that tests whether <a>observeDerivation'</a>
--   followed by <a>sampleDerivation'</a> restores the original derivation.
--   Useful for testing the compatibility of the two functions.
roundtrip :: FilePath -> IO (Either String [PVLeftmost SPitch])

-- | Helper function: Load a single derivation and infer the corresponding
--   posterior for a uniform prior.
trainSinglePiece :: FilePath -> IO (Maybe (PVParams HyperRep))
instance GHC.Show.Show PVGrammar.Prob.Simple.MagicalOctaves
instance GHC.Classes.Ord PVGrammar.Prob.Simple.MagicalOctaves
instance GHC.Classes.Eq PVGrammar.Prob.Simple.MagicalOctaves
instance Inference.Conjugate.Distribution PVGrammar.Prob.Simple.MagicalOctaves
instance GHC.Generics.Generic (PVGrammar.Prob.Simple.PVParams f)
instance (GHC.Show.Show (f Inference.Conjugate.Beta), GHC.Show.Show (f Inference.Conjugate.Beta), GHC.Show.Show (f Inference.Conjugate.Beta), GHC.Show.Show (f (Inference.Conjugate.Dirichlet 3)), GHC.Show.Show (f Inference.Conjugate.Beta)) => GHC.Show.Show (PVGrammar.Prob.Simple.PVParams f)
instance GHC.Generics.Generic (PVGrammar.Prob.Simple.PVParamsInner f)
instance (GHC.Show.Show (f Inference.Conjugate.Beta), GHC.Show.Show (f Inference.Conjugate.Beta), GHC.Show.Show (f Inference.Conjugate.Beta), GHC.Show.Show (f (Inference.Conjugate.Dirichlet 3)), GHC.Show.Show (f Inference.Conjugate.Beta)) => GHC.Show.Show (PVGrammar.Prob.Simple.PVParamsInner f)
instance GHC.Generics.Generic (PVGrammar.Prob.Simple.PVParamsOuter f)
instance GHC.Show.Show (f Inference.Conjugate.Beta) => GHC.Show.Show (PVGrammar.Prob.Simple.PVParamsOuter f)

module Probability

-- | Computes the multinomial log probability density function
--   parameterised by prob, evaluated at the vector xs. The sum of the
--   observations for all categories must add up to the number of samples,
--   n. The probabilties must be NORMALISED!
multinomialLogProb :: Vector Double -> Vector Double -> Double
sampleR :: StatefulGen g IO => g -> Int -> [a] -> IO [a]
categoricalLogProb :: Int -> Vector Double -> Maybe Double
pickRandomChoice :: StatefulGen g IO => g -> [slc] -> MaybeT IO slc
pickReservoir10 :: StatefulGen g IO => g -> [slc] -> MaybeT IO [slc]
collectRandomSample :: StatefulGen g IO => g -> MaybeT IO [a] -> IO [a]
collectRandomChoice :: StatefulGen g IO => g -> MaybeT IO a -> IO [a]
mixture :: Maybe (Vector Double) -> Maybe (Vector Double) -> Maybe (Vector Double)

-- | Sample n elements from a list sample :: Show a =&gt; Int -&gt; [a]
--   -&gt; Reservoir a [a] sample n xs = do let len = length xs let
--   updateReservoir x = do ys &lt;- get i &lt;- lift $ randomRIO (0, len)
--   if i &lt; n then put (take i ys ++ [x] ++ drop (i + 1) ys) else return
--   () liftIO $ putStrLn "Reservoir sampling..." liftIO $ putStrLn $ "List
--   length: " ++ show len liftIO $ putStrLn $ "Reservoir size: " ++ show n
--   liftIO $ putStrLn "Reservoir:" liftIO $ putStrLn "---------" put (take
--   n xs) forM_ (drop n xs) $ x -&gt; do updateReservoir x get &gt;&gt;=
--   liftIO . putStrLn . show get
data Prob a
data RandomChoice a
testProb :: IO ()
poissonSample :: StatefulGen g IO => g -> Double -> IO Int
sample :: RandomChoice a -> StdGen -> [a] -> Prob a
reservoirSample :: StatefulGen g IO => g -> Int -> [a] -> IO [a]
pickRandom :: StatefulGen g m => g -> [a] -> m (Maybe a)


-- | This module contains code that is specific to parsing the protovoice
--   grammar. It implements a number of evaluators (<a>Eval</a>) that can
--   be used with the various parsers.
module PVGrammar.Parse

-- | A constraint alias for note types.
type IsNote n = (HasPitch n, Diatonic (ICOf (IntervalOf n)), Eq (ICOf (IntervalOf n)))

-- | The evaluator that represents the proto-voice grammar. As scores it
--   returns a representation of each operation. These scores do not form a
--   semiring, but can be embedded into different semirings using
--   <a>mapEvalScore</a>.
protoVoiceEvaluator :: (Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n, Hashable n) => Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
protoVoiceEvaluatorImpure :: (Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n, Hashable n) => EvalImpure (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)

-- | A restricted version of the PV evaluator that prohibits split
--   operations in which one of the parent slices is repeated entirely.
protoVoiceEvaluatorNoRepSplit :: (Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n, Hashable n) => Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)
protoVoiceEvaluatorLimitedSize :: (Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n, Hashable n) => Int -> Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (PVLeftmost n)

-- | An evaluator for protovoices that produces values in the
--   <a>Derivations</a> semiring.
pvDerivUnrestricted :: (Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n, Hashable n) => Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) (Derivations (PVLeftmost n))

-- | An evaluator for protovoices that produces values in the
--   <a>Derivations</a> semiring.
--   
--   <ul>
--   <li>Enforces right-branching spreads (see
--   <a>rightBranchSpread</a>).</li>
--   </ul>
pvDerivRightBranch :: (Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n, Hashable n) => Eval (Merged, (RightBranchSpread, Edges n)) (t (Edge n)) ((), ((), Notes n)) (t2 n) (Derivations (PVLeftmost n))

-- | An evaluator for protovoices that produces values in the counting
--   semiring.
pvCountUnrestricted :: (Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n, Hashable n) => Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) Int

-- | An evaluator for protovoices that produces values in the counting
--   semiring.
--   
--   <ul>
--   <li>Prohibits split operations in which one of the parent slices is
--   repeated entirely (see <a>protoVoiceEvaluatorNoRepSplit</a>).</li>
--   </ul>
pvCountNoRepSplit :: (Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n, Hashable n) => Eval (Edges n) (t (Edge n)) (Notes n) (t2 n) Int

-- | An evaluator for protovoices that produces values in the counting
--   semiring.
--   
--   <ul>
--   <li>Prohibits split operations in which one of the parent slices is
--   repeated entirely (see <a>protoVoiceEvaluatorNoRepSplit</a>).</li>
--   <li>Enforces right-branching spreads (see
--   <a>rightBranchSpread</a>).</li>
--   </ul>
pvCountNoRepSplitRightBranch :: (Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n, Hashable n) => Eval (RightBranchSpread, Edges n) (t (Edge n)) ((), Notes n) (t2 n) Int

-- | An evaluator for protovoices that produces values in the counting
--   semiring.
--   
--   <ul>
--   <li>Prohibits split operations in which one of the parent slices is
--   repeated entirely (see <a>protoVoiceEvaluatorNoRepSplit</a>).</li>
--   <li>Enforces right-branching spreads (see
--   <a>rightBranchSpread</a>).</li>
--   <li>Normalizes the order of adjacent split and spread operations to
--   split-before-spread (see <a>splitFirst</a>).</li>
--   </ul>
pvCountNoRepSplitRightBranchSplitFirst :: (Foldable t, Foldable t2, Eq n, Ord n, IsNote n, Notation n, Hashable n) => Eval (Merged, (RightBranchSpread, Edges n)) (t (Edge n)) ((), ((), Notes n)) (t2 n) Int
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (PVGrammar.Parse.EdgeEither a b)
instance (Data.Hashable.Class.Hashable a, Data.Hashable.Class.Hashable b) => Data.Hashable.Class.Hashable (PVGrammar.Parse.EdgeEither a b)
instance GHC.Generics.Generic (PVGrammar.Parse.EdgeEither a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (PVGrammar.Parse.EdgeEither a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (PVGrammar.Parse.EdgeEither a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (PVGrammar.Parse.EdgeEither a b)
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b, Control.DeepSeq.NFData c, Control.DeepSeq.NFData d) => Control.DeepSeq.NFData (PVGrammar.Parse.Elaboration a b c d)
instance (Data.Hashable.Class.Hashable a, Data.Hashable.Class.Hashable b, Data.Hashable.Class.Hashable c, Data.Hashable.Class.Hashable d) => Data.Hashable.Class.Hashable (PVGrammar.Parse.Elaboration a b c d)
instance GHC.Generics.Generic (PVGrammar.Parse.Elaboration a b c d)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d) => GHC.Show.Show (PVGrammar.Parse.Elaboration a b c d)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d) => GHC.Classes.Ord (PVGrammar.Parse.Elaboration a b c d)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d) => GHC.Classes.Eq (PVGrammar.Parse.Elaboration a b c d)


-- | This module contains
module Harmony

-- | Provides a score measuring how much the slice matches the chord
--   annoation
evaluateSlice :: Notes SIC -> ChordType -> Double
rotateVector :: Int -> Vector a -> Maybe (Vector a)
mostLikelyLabelFromSliceWithProb :: Notes SPitch -> (ChordLabel, Double)
probsRegs :: Maybe ChordLabel -> Maybe ChordLabel -> DoubleOrnament -> Maybe (Vector Double)
probsPassings :: Maybe ChordLabel -> Maybe ChordLabel -> PassingOrnament -> Maybe (Vector Double)
probsFromLeft :: Maybe ChordLabel -> RightOrnament -> Maybe (Vector Double)
probsFromRight :: Maybe ChordLabel -> LeftOrnament -> Maybe (Vector Double)
probsParent :: Maybe ChordLabel -> Maybe (Vector Double)
mostLikelyLabelFromSlice :: Notes SPitch -> ChordLabel
labelLikelihoodGivenSlice :: ChordLabel -> Notes SPitch -> Double
allLabelLikelihoodsGivenSlice :: Notes SPitch -> Vector (Double, ChordLabel)
transposeSlice :: Pitch SIC -> Notes SPitch -> Notes SIC
notePos :: SPitch -> Maybe Int
notesVector :: Notes SPitch -> Vector Double
noteVector :: SPitch -> Maybe (Vector Double)
ornamentLogLikelihood :: ChordLabel -> SPitch -> Double
chordToneLogLikelihood :: ChordLabel -> SPitch -> Double
scoreSegment' :: Notes SPitch -> ChordLabel -> Double
scoreSegments :: [Notes SPitch] -> [ChordLabel] -> Double


-- | A parser for the protovoice model, representials partial reductions as
--   a search state that can be traversed by applying operations such as
--   <tt>Unspread</tt>, <tt>Unfreeze</tt> and <a>Unsplit</a>.
module HeuristicParser

-- | Slice datatype for parsing
newtype Slice ns
Slice :: ns -> Slice ns

-- | Content of the Slice
[sContent] :: Slice ns -> ns

-- | Data type for a slice "wrapped" with additional information. Contains
--   the content alongside the guess of the most likely chord label, and
--   our confidence in that label.
data SliceWrapped ns
SliceWrapped :: ns -> ChordLabel -> Double -> SliceWrapped ns
[sWContent] :: SliceWrapped ns -> ns
[sLbl] :: SliceWrapped ns -> ChordLabel
[sLblProb] :: SliceWrapped ns -> Double

-- | Type for functions that <tt>wrap</tt> slices with additional
--   information
newtype SliceWrapper ns
SliceWrapper :: (ns -> SliceWrapped ns) -> SliceWrapper ns

-- | Converts a slice into a wrapped slice, giving additional information
--   such as a guess of the chord it represents.
[wrapSlice] :: SliceWrapper ns -> ns -> SliceWrapped ns

-- | Returns a <a>SliceWrapper</a> that guesses the most likely chord for a
--   slice
sliceWrapper :: SliceWrapper (Notes SPitch)
idWrapper :: SliceWrapper ns

-- | Transition wrapper datatype. Wraps a transition with a flag indicating
--   whether or not the transition is the 2nd right parent of a spread, and
--   another flag marking whether or not this transition is at a boundary
--   between segments
data Trans es
Trans :: !es -> !Bool -> !Boundary -> Trans es

-- | The value inside the transition, i.e. protovoice edges
[tContent] :: Trans es -> !es

-- | Marks if this transition is the 2nd right parent of a spread
[t2nd] :: Trans es -> !Bool

-- | Marks whether or not this transition is at a boundary between two
--   segments
[tBoundary] :: Trans es -> !Boundary

-- | Boolean type synonym representing if a transition is a boundary
--   between two segments
type Boundary = Bool

-- | The state of the search between steps. Generally, the current
--   reduction consists of frozen transitions between the ⋊ and the current
--   location and open transitions between the current location and ⋉.
--   
--   <pre>
--   ⋊==[1]==[2]==[3]——[4]——[5]——⋉
--     └ frozen  ┘  | └   open  ┘
--               midSlice (current position)
--   
--   frozen:   ==[2]==[1]==
--   midSlice: [3]
--   open:     ——[4]——[5]——
--   </pre>
--   
--   This is the <a>SSSemiOpen</a> case: The slice at the current pointer
--   (<tt>[3]</tt>) is represented as an individual slice
--   (<tt>_ssMidSlice</tt>). The frozen part is represented by a
--   <a>Path</a> of frozen transitions (<tt>tr'</tt>) and slices
--   (<tt>slc</tt>). <b>in reverse direction</b>, i.e. from
--   <tt>midslice</tt> back to ⋊ (excluding ⋊). The open part is a
--   <a>Path</a> of open transitions (<tt>tr</tt>) and slices
--   (<tt>slc</tt>) in forward direction from <tt>midSlice</tt> up to ⋉.
--   
--   There are two special cases. All transitions can be frozen
--   (<a>SSFrozen</a>), in which case state only contains the backward
--   <a>Path</a> of frozen transitions (excluding ⋊ and ⋉):
--   
--   <pre>
--   ⋊==[1]==[2]==[3]==⋉
--                      └ current position
--   represented as: ==[3]==[2]==[1]==
--   </pre>
--   
--   Or all transitions can be open (<a>SSOpen</a>), in which case the
--   state is just the forward path of open transitions:
--   
--   <pre>
--   ⋊——[1]——[2]——[3]——⋉
--   └ current position
--   represented as: ——[1]——[2]——[3]——
--   </pre>
--   
--   The open and semiopen case additionally have a list of operations in
--   generative order.
--   
--   Types: es' : Unparsed/frozen transitions es : Unfrozen transitions ns
--   : Evaluated slice content o : Operation type
data SearchState es es' ns o
SSFrozen :: !Path (Maybe es', Bool) (SliceWrapped ns) -> SearchState es es' ns o
SSSemiOpen :: !Path (Maybe es', Bool) (SliceWrapped ns) -> !SliceWrapped ns -> !Path (Trans es) (SliceWrapped ns) -> ![o] -> SearchState es es' ns o

-- | frozen transitions and slices from current point leftward
[_ssFrozen] :: SearchState es es' ns o -> !Path (Maybe es', Bool) (SliceWrapped ns)

-- | the slice at the current posision between gsFrozen and gsOpen
[_ssMidSlice] :: SearchState es es' ns o -> !SliceWrapped ns

-- | non-frozen transitions and slices from current point rightward
[_ssOpen] :: SearchState es es' ns o -> !Path (Trans es) (SliceWrapped ns)

-- | derivation from current reduction to original surface
[_ssDeriv] :: SearchState es es' ns o -> ![o]
SSOpen :: !Path (Trans es) (SliceWrapped ns) -> ![o] -> SearchState es es' ns o
type SearchState' = SearchState (Edges SPitch) [Edge SPitch] (Notes SPitch) (Leftmost (Split SPitch) Freeze (Spread SPitch))

-- | A parsing action (reduction step) with a single parent transition.
--   Combines the parent elements with a single-transition derivation
--   operation.
data ActionSingle ns tr s f
ActionSingle :: (StartStop ns, Trans tr, StartStop ns) -> LeftmostSingle s f -> ActionSingle ns tr s f

-- | A parsing action (reduction step) with two parent transitions.
--   Combines the parent elements with a double-transition derivation
--   operation.
data ActionDouble ns tr s f h
ActionDouble :: (StartStop ns, Trans tr, ns, Trans tr, StartStop ns) -> LeftmostDouble s f h -> ActionDouble ns tr s f h

-- | Returns a list of possible next states given the current state. Works
--   by applying the inverse of the following operations, as returned by
--   the protovoiceEvaluator. &gt; &gt; freeze left: split left: split
--   right: spread: &gt; ...=[]——[]——[]—... ...=[]——[]——[]—...
--   ...=[]——[]——[]—... ...=[]——[]——[]—... &gt; ...=[]==[]——[]—... <i> </i>
--   <i> </i> &gt; [] [] []——[]
exploreStates :: forall es es' ns ns' s f h. (Show s, Show f, Show h, Show es, Show es', Show ns, Show ns') => SliceWrapper ns -> Eval es es' ns ns' (Leftmost s f h) -> SearchState es es' ns (Leftmost s f h) -> ExceptT String IO [SearchState es es' ns (Leftmost s f h)]
exploreStates' :: forall es es' ns ns' s f h. (Show s, Show f, Show h, Show es, Show es', Show ns, Show ns') => SliceWrapper ns -> EvalImpure es es' ns ns' (Leftmost s f h) -> SearchState es es' ns (Leftmost s f h) -> ExceptT String IO [SearchState es es' ns (Leftmost s f h)]

-- | Returns <a>True</a> if the parse is complete and has been reduced to
--   only one slice per segment
goalTest :: [ChordLabel] -> SearchState es es' ns o -> Bool

-- | Returns <a>True</a> if the parse is complete, and has been reduced to
--   only one slice
goalTestSBS :: SearchState es es' ns o -> Bool

-- | Goal test for a search: Only complete once there is a single slice per
--   segment
heursiticSearchGoalTest :: SearchState es es' ns o -> Bool
getPathFromState :: SearchState es es' ns o -> Maybe (Path es ns)
getPathLengthFromState :: SearchState es es' ns o -> Int
getPathFromState' :: SearchState es es' ns o -> Maybe (Path es (SliceWrapped ns))
getSlicesFromState :: SearchState es es' ns o -> Maybe [SliceWrapped ns]

-- | Returns the latest operation that has been applied, or Nothing if no
--   operations have been applied
getOpFromState :: SearchState es es' ns o -> Maybe o

-- | Returns a list of all operations that have been taken up to the state
--   given
getOpsFromState :: SearchState es es' ns o -> [o]

-- | Calculate a naive accuracy metric for two lists using equality
chordAccuracy :: (Eq a, Show a) => [a] -> [a] -> Double

-- | Returns the most likely chord labels for each input group of notes
guessChords :: [Notes SPitch] -> [ChordLabel]
showOp :: (Show s, Show f, Show h) => [Leftmost s f h] -> String
instance GHC.Classes.Eq ns => GHC.Classes.Eq (HeuristicParser.Slice ns)
instance GHC.Classes.Eq ns => GHC.Classes.Eq (HeuristicParser.SliceWrapped ns)
instance GHC.Classes.Eq es => GHC.Classes.Eq (HeuristicParser.Trans es)
instance (GHC.Show.Show ns, GHC.Show.Show tr, GHC.Show.Show s, GHC.Show.Show f) => GHC.Show.Show (HeuristicParser.ActionSingle ns tr s f)
instance (GHC.Show.Show ns, GHC.Show.Show tr, GHC.Show.Show s, GHC.Show.Show f, GHC.Show.Show h) => GHC.Show.Show (HeuristicParser.ActionDouble ns tr s f h)
instance (GHC.Show.Show ns, GHC.Show.Show o) => GHC.Show.Show (HeuristicParser.SearchState es es' ns o)
instance GHC.Show.Show es => GHC.Show.Show (HeuristicParser.Trans es)
instance GHC.Show.Show ns => GHC.Show.Show (HeuristicParser.SliceWrapped ns)
instance GHC.Show.Show ns => GHC.Show.Show (HeuristicParser.Slice ns)


-- | This module contains
module Heuristics
applyHeuristic :: ((State SPitch, State SPitch) -> ExceptT String IO Double) -> (State SPitch, State SPitch) -> ExceptT String IO Double

-- | Basic heuristic for protovoice operations: Consists of two factors:
--   P(n|p,l), the probability of each child note considering the parent
--   notes. P(p|l) the plausibility of the parent notes being chord tones
--   of the corresponding parent slices.
heuristicZero :: (State SPitch, State SPitch) -> ExceptT String IO Double
type State ns = SearchState (Edges ns) [Edge ns] (Notes ns) (PVLeftmost ns)

module Algorithm.RandomChoiceSearch

-- | Entry point to the search algorithm Picks random choice from a split
--   or spread operation Skewed towards splits.
randomChoiceSearch :: Show state => state -> (state -> ExceptT String IO [state]) -> (state -> Bool) -> (state -> String) -> ExceptT String IO state


-- | This module contains functionality for reading chord and slice data
--   from csv files, as output by 'preprocess.py'. This also contains
--   functionality for writing the results of the parses to json files, to
--   be read by 'results.py'
module FileHandling

-- | Slice type for reading from csv
type InputSlice ns = ([(ns, RightTied)], Bool)

-- | Create a <a>Path</a> given a list of slices
pathFromSlices :: forall ns o. Eval (Edges ns) [Edge ns] (Notes ns) [ns] o -> SliceWrapper (Notes ns) -> [InputSlice ns] -> Path (Maybe [Edge ns], Bool) (SliceWrapped (Notes ns))

-- | Concatenates all results for a given piece into an object, inlucuding
--   the piece and corpus in the JSON value.
concatResults :: String -> String -> String -> String -> [ChordLabel] -> [Value] -> Value

-- | Loads slices from filepath
slicesFromFile' :: FilePath -> IO [(Slice', Bool)]

-- | Loads chord annotations from filepath
chordsFromFile :: FilePath -> IO [ChordLabel]

-- | Write JSON value to the given file
writeJSONToFile :: ToJSON a => FilePath -> a -> IO ()

-- | Coverts the results of a parsing algorithm to a JSON value
writeResultsToJSON :: [Notes SPitch] -> [ChordLabel] -> Maybe (PVAnalysis SPitch) -> Accuracy -> LogLikelihood -> String -> Time -> Int -> Value

-- | Used when the algorithm fails. Contains NANs in all fields.
nullResultToJSON :: Show a => a -> Value
splitSlicesIntoSegments :: forall ns o. Eval (Edges ns) [Edge ns] (Notes ns) [ns] o -> SliceWrapper (Notes ns) -> [InputSlice ns] -> [[InputSlice ns]]
instance Data.Csv.Conversion.FromNamedRecord FileHandling.ChordLabel'
instance Data.Csv.Conversion.FromNamedRecord FileHandling.SalamiNote
instance Data.Csv.Conversion.FromField Musicology.Core.RightTied
instance Data.Csv.Conversion.FromField GHC.Types.Bool

module Algorithm.RandomSampleParser

-- | Generates a path of random notes for the given number of segments
randomSamplePath :: Int -> IO (Path (Edges SPitch) (Notes SPitch))
randomSamplePathSBS :: [[InputSlice SPitch]] -> IO [Notes SPitch]
poissonSample :: StatefulGen g IO => g -> Double -> IO Int

module Algorithm.HeuristicSearch
aab :: Int -> [a] -> IO [a]
stochasticSearch :: Int -> SearchState' -> (SearchState' -> ExceptT String IO [SearchState']) -> (SearchState' -> Bool) -> ((SearchState', SearchState') -> ExceptT String IO Double) -> ExceptT String IO SearchState'
stochasticBeamSearch :: Int -> Int -> SearchState' -> (SearchState' -> ExceptT String IO [SearchState']) -> (SearchState' -> Bool) -> ((SearchState', SearchState') -> ExceptT String IO Double) -> ExceptT String IO SearchState'
dualStochasticBeamSearch :: Int -> Int -> SearchState' -> (SearchState' -> ExceptT String IO [SearchState']) -> (SearchState' -> Bool) -> ((SearchState', SearchState') -> ExceptT String IO Double) -> ExceptT String IO SearchState'
stochasticBeamSearchLimited :: Int -> Int -> SearchState' -> (SearchState' -> ExceptT String IO [SearchState']) -> (SearchState' -> Bool) -> ((SearchState', SearchState') -> ExceptT String IO Double) -> ExceptT String IO SearchState'

-- | Entry point to the search algorithm
beamSearch :: Int -> SearchState' -> (SearchState' -> ExceptT String IO [SearchState']) -> (SearchState' -> Bool) -> ((SearchState', SearchState') -> ExceptT String IO Double) -> ExceptT String IO SearchState'
instance GHC.Classes.Eq Algorithm.HeuristicSearch.PvOp

module Core

module Algorithm
data AlgoInput
AlgoInputPure :: Eval (Edges SPitch) [Edge SPitch] (Notes SPitch) [SPitch] (PVLeftmost SPitch) -> [InputSlice SPitch] -> [ChordLabel] -> AlgoInput
AlgoInputImpure :: EvalImpure (Edges SPitch) [Edge SPitch] (Notes SPitch) [SPitch] (PVLeftmost SPitch) -> [InputSlice SPitch] -> [ChordLabel] -> AlgoInput
class (Show algo) => ParseAlgo algo
runParse :: ParseAlgo algo => algo -> AlgoInput -> IO (Maybe AlgoResult)
data AlgoResult
AlgoResult :: [Notes SPitch] -> Maybe (PVAnalysis SPitch) -> [ChordLabel] -> AlgoResult
[arTop] :: AlgoResult -> [Notes SPitch]
[arOps] :: AlgoResult -> Maybe (PVAnalysis SPitch)
[arLabels] :: AlgoResult -> [ChordLabel]
data AlgoType
RandomWalk :: AlgoType
RandomWalkPerSegment :: AlgoType
RandomSample :: AlgoType
RandomReduction :: AlgoType
BeamSearch :: BeamWidth -> AlgoType
StochasticBeamSearch :: BeamWidth -> ResevoirSize -> AlgoType
DualStochasticBeamSearch :: BeamWidth -> ResevoirSize -> AlgoType
StochasticBeamSearchLimited :: BeamWidth -> ResevoirSize -> MaxNotesPerSlice -> AlgoType
BeamSearchPerSegment :: BeamWidth -> AlgoType
DualBeamSearch :: UnspreadWidth -> UnsplitWidth -> AlgoType
StochasticSearch :: AlgoType
type UnsplitWidth = Int
type UnspreadWidth = Int
type BeamWidth = Int
instance GHC.Show.Show Algorithm.AlgoResult
instance GHC.Classes.Eq Algorithm.AlgoType
instance GHC.Read.Read Algorithm.AlgoType
instance GHC.Show.Show Algorithm.AlgoType
instance Algorithm.ParseAlgo Algorithm.AlgoType


-- | <i>This module is deprecated, use <a>Scoring.FunTyped</a> instead.</i>
--   
--   Semiring scores with "holes". Holes are used to express "partially
--   applied" scores that occur when the score of a verticalization
--   (unspread) is distributed to two parent edges. The full score of the
--   operation is restored when the two parent edges are eventually
--   combined again.
--   
--   This module implements partial scores using lists, which is slow and
--   not very elegant. The grammar combinators are partial and will fail if
--   used incorrectly, indicating parser bugs.
module Scoring.Deprecated.Flat

-- | A partially applied score of type <tt>s</tt>. Comes in four variants,
--   depending on whether the score is fully applied or needs to be
--   combined on either or both sides. Values that need to be combined are
--   lists that represent scores with holes. Each variant carries IDs of
--   type <tt>i</tt> that determine which objects fit on either of its
--   sides. Only score objects with matching IDs can be combined.
--   
--   As a shorthand notation, we use <tt>a-b</tt> to indicate a value that
--   depends on <tt>a</tt> on its left and on <tt>b</tt> on its right. If
--   the value does not depend on anything on either side, we use
--   <tt>()</tt>, i.e. <tt>()-a</tt> stands for <tt>SLeft _ a</tt> and
--   <tt>()-()</tt> stands for <tt>SVal _</tt>.
data Score s i

-- | Carries a fully applied value
SVal :: !s -> Score s i

-- | The right part of a combination, expects an argument to its left.
--   Implemented as a list of right elements
SRight :: !LeftId i -> ![Holes s] -> Score s i

-- | The left part of a combination, expects an argument to its right.
--   Implemented as a list of right elements
SLeft :: ![Holes s] -> !RightId i -> Score s i

-- | A combination of <a>SLeft</a> and <a>SRight</a> that expects arguments
--   on both sides. Implemented as a list of right elements on the left and
--   a list of left elements to the right
SBoth :: !LeftId i -> ![(Holes s, Holes s)] -> !RightId i -> Score s i

-- | A type alias for the holes in a <a>Score</a>.
type Holes s = [s]

-- | Creates a simple value score of type ()-().
val :: s -> Score s i

-- | Newtype for the left ID of a partial score.
newtype LeftId i
LeftId :: i -> LeftId i

-- | Newtype for the right ID of a partial score.
newtype RightId i
RightId :: i -> RightId i

-- | Returns the ID on the left side of an <a>Score</a>, or <a>Nothing</a>
--   for <a>SVal</a> and <a>SLeft</a>.
--   
--   <pre>
--   a-b -&gt; a
--   </pre>
leftSide :: Score s i -> Maybe (LeftId i)

-- | Returns the ID on the right side of an <a>Score</a>, or <a>Nothing</a>
--   for <a>SVal</a> and <a>SRight</a>.
--   
--   <pre>
--   a-b -&gt; b
--   </pre>
rightSide :: Score s i -> Maybe (RightId i)

-- | Returns a string representation of a <a>Score</a> (more compact than
--   it's <a>Show</a> instance).
showScore :: (Show s, Show i) => Score s i -> String

-- | Combines two partially applied <a>Score</a>s by applying them to each
--   other and/or multiplying the underlying semiring values. Shapes and
--   IDs at the adjacent sides must match, otherwise <a>Nothing</a> is
--   returned.
--   
--   <pre>
--   a-b × b-c -&gt; a-c
--   </pre>
times :: (Semiring s, Eq i, Show i) => Score s i -> Score s i -> Maybe (Score s i)

-- | Adds two partially applied <a>Score</a>s by adding their underlying
--   (or resulting) semiring values. This operation is only admitted if the
--   two scores are of the same shape and have matching IDs. Otherwise,
--   <a>Nothing</a> is returned.
--   
--   <pre>
--   a-b + a-b -&gt; a-b
--   </pre>
plus :: (Semiring s, Eq i) => Score s i -> Score s i -> Maybe (Score s i)

-- | Combines the <a>Score</a>s of two edges with a <tt>split</tt>
--   operation into the score of the parent edge. This is expected to be
--   called on compatible scores and will throw an error otherwise to
--   indicate parser bugs.
--   
--   <pre>
--   a-b   b-c
--   --------- unsplit
--      a-c
--   </pre>
unsplitScores :: (Semiring s, Eq i, Show i, Show s) => s -> Score s i -> Score s i -> Score s i

-- | Creates the <a>Score</a> of a left parent edge from a left child edge
--   of an <tt>unspread</tt>. Will throw an error if called on invalid
--   input to indicate parser bugs.
unspreadScoresLeft :: (Eq i, Show i, Semiring s, Show s) => i -> Score s i -> Score s i

-- | Creates the <a>Score</a> of a right parent edge from the middle and
--   right child edges of an <tt>unspread</tt> and a <tt>spread</tt>
--   operation.
unspreadScoresRight :: (Eq i, Semiring s, Show i, Show s) => i -> s -> Score s i -> Score s i -> Score s i

-- | Adds two <a>Score</a>s that are alternative derivations of the same
--   transition. This is expected to be called on compatible scores and
--   will throw an error otherwise to indicate parser bugs.
--   
--   <pre>
--   a-b   a-b
--   --------- add
--      a-b
--   </pre>
addScores :: (Semiring s, Eq i) => Score s i -> Score s i -> Score s i

-- | Extracts the value from a fully applied <a>Score</a>. This function is
--   intended to be used to extract the final score of the parser. If the
--   score is not fully applied, throws an exception to indicate parser
--   bugs.
getScoreVal :: Score s i -> s
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Scoring.Deprecated.Flat.LeftId i)
instance Data.Hashable.Class.Hashable i => Data.Hashable.Class.Hashable (Scoring.Deprecated.Flat.LeftId i)
instance GHC.Generics.Generic (Scoring.Deprecated.Flat.LeftId i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (Scoring.Deprecated.Flat.LeftId i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Scoring.Deprecated.Flat.LeftId i)
instance Data.Hashable.Class.Hashable i => Data.Hashable.Class.Hashable (Scoring.Deprecated.Flat.RightId i)
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Scoring.Deprecated.Flat.RightId i)
instance GHC.Generics.Generic (Scoring.Deprecated.Flat.RightId i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (Scoring.Deprecated.Flat.RightId i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Scoring.Deprecated.Flat.RightId i)
instance (Control.DeepSeq.NFData s, Control.DeepSeq.NFData i) => Control.DeepSeq.NFData (Scoring.Deprecated.Flat.Score s i)
instance GHC.Generics.Generic (Scoring.Deprecated.Flat.Score s i)
instance (GHC.Show.Show i, GHC.Show.Show s) => GHC.Show.Show (Scoring.Deprecated.Flat.Score s i)
instance GHC.Show.Show i => GHC.Show.Show (Scoring.Deprecated.Flat.RightId i)
instance GHC.Show.Show i => GHC.Show.Show (Scoring.Deprecated.Flat.LeftId i)


-- | Semiring scores with "holes". Holes are used to express "partially
--   applied" scores that occur when the score of a verticalization
--   (unspread) is distributed to the two parent edges. The full score of
--   the operation is restored when the two parent edges are eventually
--   combined again.
--   
--   This module implements partial scores as typesafe functions with
--   phantom types that indicate the number of holes on each side. The
--   grammatical combinators use an existential type <a>Score</a> that
--   reifies the phantom types as singletons, which allows different scores
--   to be easily stored together and is compatible with the <a>Score</a>
--   types from the other Scoring* modules. Thus, the grammatical
--   combinators are partial and fail when used with incompatible scores,
--   indicating a parser bug.
module Scoring.FunTyped

-- | A paritally applied score of type <tt>s</tt> with an unknown number of
--   holes (as used by the <a>ChartParser</a>). Wraps a <a>TypedScore</a>
--   together with witnesses for the number of holes on each side.
data Score s i :: Type
[MkScore] :: SNat nl -> SNat nr -> TypedScore nl nr s i -> Score s i

-- | A partially applied score of type <tt>s</tt>. Comes in four variants,
--   depending on whether the score is fully applied or needs to be
--   combined on either or both sides. Values that need to be combined are
--   lists that represent scores with holes. Each variant carries IDs of
--   type <tt>i</tt> that determine which objects fit on either of its
--   sides. Only score objects with matching IDs can be combined.
--   
--   As a shorthand notation, we use <tt>a-b</tt> to indicate a value that
--   depends on <tt>a</tt> on its left and on <tt>b</tt> on its right. If
--   the value does not depend on anything on either side, we use
--   <tt>()</tt>, i.e. <tt>()-a</tt> stands for <tt>SLeft _ a</tt> and
--   <tt>()-()</tt> stands for <tt>SVal _</tt>.
data TypedScore (nl :: Nat) (nr :: Nat) s i

-- | Carries a fully applied value
[SVal] :: !s -> TypedScore 'Z 'Z s i

-- | The right part of a combination, expects an argument to its left.
--   Implemented as a function that takes a left counterpart and returns a
--   score with fewer holes.
[SRight] :: !LeftId i -> !RightHoles nl s -> TypedScore ('S nl) 'Z s i

-- | The left part of a combination, expects an argument to its right.
--   Implemented as a function that takes a right hole and applies it.
[SLeft] :: !LeftHoles nr s -> !RightId i -> TypedScore 'Z ('S nr) s i

-- | A combination of <a>SLeft</a> and <a>SRight</a> that expects arguments
--   on both sides. Implemented as a function that expects both a right and
--   a left hole to be complete.
[SBoth] :: !LeftId i -> !BothHoles nl nr s -> !RightId i -> TypedScore ('S nl) ('S nr) s i

-- | Creates a simple value score of type ()-().
val :: s -> Score s i

-- | Returns a string representation of a <a>Score</a> (more compact than
--   it's <a>Show</a> instance).
showScore :: (Show s, Show i) => Score s i -> String

-- | Newtype for the left ID of a partial score.
newtype LeftId i
LeftId :: i -> LeftId i

-- | Newtype for the right ID of a partial score.
newtype RightId i
RightId :: i -> RightId i

-- | Returns the ID on the left side of an <a>Score</a>, or <a>Nothing</a>
--   for <a>SVal</a> and <a>SLeft</a>.
--   
--   <pre>
--   a-b -&gt; a
--   </pre>
leftSide :: Score s i -> Maybe (LeftId i)

-- | Returns the ID on the right side of an <a>Score</a>, or <a>Nothing</a>
--   for <a>SVal</a> and <a>SRight</a>.
--   
--   <pre>
--   a-b -&gt; b
--   </pre>
rightSide :: Score s i -> Maybe (RightId i)

-- | The type of a function representing <tt>n</tt> left holes.
type LeftHoles (n :: Nat) s = (RightHoles n s -> s)

-- | The type of a function representing <tt>n</tt> right holes.
type RightHoles (n :: Nat) s = s -> RightHole n s

-- | A single right hole (helper for <a>RightHoles</a>).
data RightHole (n :: Nat) s

-- | The type of a function containing <tt>nl</tt> left and <tt>nr</tt>
--   right holes.
type BothHoles (nl :: Nat) (nr :: Nat) s = (RightHoles nr s -> RightHoles nl s)

-- | Combines two partially applied <a>Score</a>s by applying them to each
--   other and/or multiplying the underlying semiring values. Shapes and
--   IDs at the adjacent sides must match, otherwise <a>Nothing</a> is
--   returned.
--   
--   <pre>
--   a-b × b-c -&gt; a-c
--   </pre>
times :: (Semiring s, Eq i, Show i) => TypedScore nl n s i -> TypedScore n nr s i -> Maybe (TypedScore nl nr s i)

-- | Adds two partially applied <a>TypedScore</a>s by adding their
--   underlying (or resulting) semiring values. This operation is only
--   admitted if the two scores are of the same shape and have matching
--   IDs. Otherwise, <a>Nothing</a> is returned.
--   
--   <pre>
--   a-b + a-b -&gt; a-b
--   </pre>
plus :: (Semiring s, Eq i) => TypedScore nl nr s i -> TypedScore nl nr s i -> Maybe (TypedScore nl nr s i)

-- | Combines the <a>Score</a>s of two edges with a <tt>split</tt>
--   operation into the score of the parent edge. This is expected to be
--   called on compatible scores and will throw an error otherwise to
--   indicate parser bugs.
--   
--   <pre>
--   a-b   b-c
--   --------- unsplit
--      a-c
--   </pre>
unsplitScores :: forall s i. (Semiring s, Eq i, Show i, Show s) => s -> Score s i -> Score s i -> Score s i

-- | Creates the <a>Score</a> of a left parent edge from a left child edge
--   of an <tt>unspread</tt>. Will throw an error if called on invalid
--   input to indicate parser bugs.
unspreadScoresLeft :: forall s i. (Eq i, Show i, Semiring s, Show s) => i -> Score s i -> Score s i

-- | Creates the <a>Score</a> of a right parent edge from the middle and
--   right child edges of an <tt>unspread</tt> and a <tt>spread</tt>
--   operation.
unspreadScoresRight :: forall i s. (Eq i, Semiring s, Show i, Show s) => i -> s -> Score s i -> Score s i -> Score s i

-- | Adds two <a>Score</a>s that are alternative derivations of the same
--   transition. This is expected to be called on compatible scores and
--   will throw an error otherwise to indicate parser bugs.
--   
--   <pre>
--   a-b   a-b
--   --------- add
--      a-b
--   </pre>
addScores :: (Semiring s, Eq i) => Score s i -> Score s i -> Score s i

-- | Extracts the value from a fully applied <a>Score</a>. This function is
--   intended to be used to extract the final score of the parser. If the
--   score is not fully applied, throws an exception to indicate parser
--   bugs.
getScoreVal :: Score s i -> s
instance Data.Hashable.Class.Hashable i => Data.Hashable.Class.Hashable (Scoring.FunTyped.LeftId i)
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Scoring.FunTyped.LeftId i)
instance GHC.Generics.Generic (Scoring.FunTyped.LeftId i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (Scoring.FunTyped.LeftId i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Scoring.FunTyped.LeftId i)
instance Data.Hashable.Class.Hashable i => Data.Hashable.Class.Hashable (Scoring.FunTyped.RightId i)
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Scoring.FunTyped.RightId i)
instance GHC.Generics.Generic (Scoring.FunTyped.RightId i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (Scoring.FunTyped.RightId i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Scoring.FunTyped.RightId i)
instance Scoring.FunTyped.AddHole 'Data.Nat.Z
instance Scoring.FunTyped.AddHole ('Data.Nat.S n)
instance (Control.DeepSeq.NFData s, Control.DeepSeq.NFData i) => Control.DeepSeq.NFData (Scoring.FunTyped.Score s i)
instance GHC.Show.Show i => GHC.Show.Show (Scoring.FunTyped.Score s i)
instance (Control.DeepSeq.NFData s, Control.DeepSeq.NFData i) => Control.DeepSeq.NFData (Scoring.FunTyped.TypedScore nl nr s i)
instance GHC.Show.Show i => GHC.Show.Show (Scoring.FunTyped.TypedScore nl nr s i)
instance Control.DeepSeq.NFData s => Control.DeepSeq.NFData (Scoring.FunTyped.RightHole n s)
instance GHC.Show.Show i => GHC.Show.Show (Scoring.FunTyped.RightId i)
instance GHC.Show.Show i => GHC.Show.Show (Scoring.FunTyped.LeftId i)


-- | A chart-based semiring parser for path grammars (e.g. the PV grammar).
--   Path grammars operate on "paths" consisting of nodes (slices) and
--   edges (transitions), both of which can contain arbitrary content.
--   Paths are elaborated through two operations, <tt>split</tt>ting
--   transitions and <tt>spread</tt>ing slices (plus <tt>freeze</tt>, which
--   terminates generation on a transition).
--   
--   The parser is polymorphic in the grammar as well as the contents of
--   slices (path nodes) and transitions (path edges). The grammar to parse
--   is definend in an "evaluator" (<a>Eval</a>) which provides completions
--   for parsing the splits, spreads and freezes.
module ChartParser

-- | The main entrypoint to the parser. Expects an evaluator for the
--   specific grammar and an input path. Returns the combined semiring
--   value of all full derivations.
parse :: Parsable tr slc v => (TChart tr slc v -> Either (VChart tr slc v) [Slice slc] -> Int -> IO ()) -> Eval tr tr' slc slc' v -> Path slc' tr' -> IO v

-- | Parse a piece using the <a>logSize</a> logging function.
parseSize :: Parsable tr slc v => Eval tr tr' slc slc' v -> Path slc' tr' -> IO v

-- | Parse a piece without logging.
parseSilent :: Parsable tr slc v => Eval tr tr' slc slc' v -> Path slc' tr' -> IO v

-- | A logging function that logs the sice of the charts at each level.
logSize :: TChart tr1 slc1 v1 -> Either (VChart tr2 slc2 v2) [Slice slc2] -> Int -> IO ()

-- | A logging function that emits the state of the chart in TikZ code at
--   every level.
logTikz :: (Foldable t, Show slc, Show slc, Hashable tr, Eq slc) => TChart tr slc v -> Either (VChart tr slc v) (t (Slice slc)) -> Int -> IO ()

-- | A slice during chart parsing. Besides the slice content (e.g., notes),
--   it maintains indices to the first and last surface slice covered, as
--   well as an ID that is used for matching compatible parents of a
--   spread.
data Slice slc

-- | A transition during chart parsing. Has pointers to the two slices it
--   connects, a content (e.g., protovoice connections), and a flag
--   indicating whether it is the second (right) parent of a spread.
data Transition tr slc

-- | Returns the "length" of the transition in terms of surface slices
--   covered.
transLen :: Transition e a -> Int

-- | A parsing item. Combines an intermediate value (e.g. a transition)
--   with a semiring score.
data Item i v

-- | A transition item.
type TItem tr slc v = Item (Transition tr slc) v

-- | The contents of a transition chart (under a particular index). A
--   mapping from transitions (with score ID constraints left and right) to
--   (partial) semiring scores. This mapping usually contains all
--   transition items that satisfy a certain criterion, irrespective of
--   their position in the chart (which is encoded in the transitions
--   themselves).
--   
--   When new transition items are added, if the transition already exists
--   in the chart (as the result of a different partial parse), the scores
--   of the new and existing items are "added" (this also requires the
--   score IDs to match).
type TContents tr slc v = HashMap (Transition tr slc, Maybe (LeftId Int), Maybe (RightId Int)) (Score v Int)

-- | A transition chart. Stores intermediate transition items redundantly
--   under several indices:
--   
--   <ul>
--   <li>by surface length</li>
--   <li>by left slice</li>
--   <li>by right slice</li>
--   </ul>
data TChart tr slc v

-- | Returns all transition items with the same length.
tcGetByLength :: TChart tr slc v -> Int -> [TItem tr slc v]

-- | Represents the middle part of an incomplete unspread
--   ("verticalization"). Expresses how the middle transition and the two
--   child slices (<tt>vMiddle</tt>) are derived from the parent slice
--   (<tt>vTop</tt>) using a spread operation (<tt>vOp</tt>).
--   
--   <a>Vert</a> objects are stored in the <a>VChart</a> to record the
--   intermediate steps of an unspread, which is found by first parsing the
--   middle transition into the parent slice (generating a <a>Vert</a>) and
--   then combining the <a>Vert</a> with the left and right child
--   transitions to generate the left and right parent transitions,
--   respectively.
data Vert tr slc v

-- | A verticalization chart. Stores <a>Vert</a> objects at certain chart
--   positions. To support efficient lookup of <a>Vert</a> objects from
--   different indices, each <a>Vert</a> is redundantly stored in several
--   hash maps, one for each index:
--   
--   <ul>
--   <li>by surface length</li>
--   <li>by surface length (only left border of a <a>Vert</a>)</li>
--   <li>by left child slice ID and mid transition length</li>
--   <li>by right child ID</li>
--   </ul>
--   
--   In addition, the <a>VChart</a> maintains IDs of new slices. (Every new
--   slice is the parent of an unspread.)
data VChart tr slc v

-- | Returns all <a>Vert</a> objects in the <a>VChart</a> with the same
--   length.
vcGetByLength :: VChart tr slc v -> Int -> [Vert tr slc v]

-- | A summary constraint for transitions, slices, and semiring values
type Parsable tr slc v = (Normal tr, Normal slc, Normal' v)

-- | An alias for common constraints on slices and transitions
type Normal x = (Eq x, Ord x, Show x, Hashable x, NFData x)

-- | An alias for common constraints on semiring values
type Normal' x = (Eq x, Show x, NFData x, Semiring x)
instance Control.DeepSeq.NFData slc => Control.DeepSeq.NFData (ChartParser.Slice slc)
instance GHC.Generics.Generic (ChartParser.Slice slc)
instance GHC.Classes.Ord slc => GHC.Classes.Ord (ChartParser.Slice slc)
instance GHC.Classes.Eq slc => GHC.Classes.Eq (ChartParser.Slice slc)
instance (GHC.Classes.Eq slc, Data.Hashable.Class.Hashable tr) => Data.Hashable.Class.Hashable (ChartParser.Transition tr slc)
instance (Control.DeepSeq.NFData slc, Control.DeepSeq.NFData tr) => Control.DeepSeq.NFData (ChartParser.Transition tr slc)
instance GHC.Generics.Generic (ChartParser.Transition tr slc)
instance (GHC.Classes.Ord slc, GHC.Classes.Ord tr) => GHC.Classes.Ord (ChartParser.Transition tr slc)
instance (GHC.Classes.Eq slc, GHC.Classes.Eq tr) => GHC.Classes.Eq (ChartParser.Transition tr slc)
instance (Control.DeepSeq.NFData i, Control.DeepSeq.NFData v) => Control.DeepSeq.NFData (ChartParser.Item i v)
instance GHC.Generics.Generic (ChartParser.Item i v)
instance (Control.DeepSeq.NFData slc, Control.DeepSeq.NFData v, Control.DeepSeq.NFData tr) => Control.DeepSeq.NFData (ChartParser.Vert tr slc v)
instance GHC.Generics.Generic (ChartParser.Vert tr slc v)
instance (Control.DeepSeq.NFData slc, Control.DeepSeq.NFData v, Control.DeepSeq.NFData tr) => Control.DeepSeq.NFData (ChartParser.VChart tr slc v)
instance GHC.Generics.Generic (ChartParser.VChart tr slc v)
instance (Control.DeepSeq.NFData slc, Control.DeepSeq.NFData tr, Control.DeepSeq.NFData v) => Control.DeepSeq.NFData (ChartParser.TChart tr slc v)
instance GHC.Generics.Generic (ChartParser.TChart tr slc v)
instance (GHC.Show.Show slc, GHC.Show.Show tr) => GHC.Show.Show (ChartParser.TChart tr slc v)
instance (GHC.Show.Show e, GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (ChartParser.VChart e a v)
instance (GHC.Show.Show e, GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (ChartParser.Vert e a v)
instance (GHC.Show.Show i, GHC.Show.Show v) => GHC.Show.Show (ChartParser.Item i v)
instance (GHC.Show.Show a, GHC.Show.Show e) => GHC.Show.Show (ChartParser.Transition e a)
instance GHC.Classes.Eq slc => Data.Hashable.Class.Hashable (ChartParser.Slice slc)
instance GHC.Show.Show slc => GHC.Show.Show (ChartParser.Slice slc)
