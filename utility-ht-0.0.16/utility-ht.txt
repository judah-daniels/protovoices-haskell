-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Various small helper functions for Lists, Maybes, Tuples, Functions
--   
--   Various small helper functions for Lists, Maybes, Tuples, Functions.
--   Some of these functions are improved implementations of standard
--   functions. They have the same name as their standard counterparts.
--   Others are equivalent to functions from the <tt>base</tt> package, but
--   if you import them from this utility package then you can write code
--   that runs on older GHC versions or other compilers like Hugs and JHC.
--   
--   All modules are plain Haskell 98. The package depends exclusively on
--   the <tt>base</tt> package and only that portions of <tt>base</tt> that
--   are simple to port. Thus you do not risk a dependency avalanche by
--   importing it. However, further splitting the base package might
--   invalidate this statement.
--   
--   Alternative packages: <tt>Useful</tt>, <tt>MissingH</tt>
@package utility-ht
@version 0.0.16

module Control.Monad.HT

-- | Also present in newer versions of the <tt>base</tt> package.
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Monadic <a>repeat</a>.
repeat :: Monad m => m a -> m [a]
nest :: Monad m => Int -> (a -> m a) -> a -> m a

-- | repeat action until result fulfills condition
until :: Monad m => (a -> Bool) -> m a -> m a

-- | repeat action until result fulfills condition

-- | <i>Deprecated: use M.until</i>
untilM :: Monad m => (a -> Bool) -> m a -> m a

-- | parameter order equal to that of <a>nest</a>
iterateLimit :: Monad m => Int -> (a -> m a) -> a -> m [a]

-- | parameter order equal to that of <a>nest</a>

-- | <i>Deprecated: use M.iterateLimit</i>
iterateLimitM :: Monad m => Int -> (a -> m a) -> a -> m [a]

-- | I think this makes only sense in a lazy monad like
--   <tt>Trans.State.Lazy</tt> or <tt>IO.Lazy</tt>.
iterate :: Monad m => (a -> m a) -> a -> m [a]

-- | Lazy monadic conjunction. That is, when the first action returns
--   <tt>False</tt>, then <tt>False</tt> is immediately returned, without
--   running the second action.
andLazy :: Monad m => m Bool -> m Bool -> m Bool

-- | Lazy monadic disjunction. That is, when the first action returns
--   <tt>True</tt>, then <tt>True</tt> is immediately returned, without
--   running the second action.
orLazy :: Monad m => m Bool -> m Bool -> m Bool
void :: Monad m => m a -> m ()
for :: Monad m => [a] -> (a -> m b) -> m [b]
map :: Monad m => (a -> m b) -> [a] -> m [b]
zipWith :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
chain :: Monad m => [a -> m a] -> a -> m a
filter :: Monad m => (a -> m Bool) -> [a] -> m [a]
replicate :: Monad m => Int -> m a -> m [a]
lift :: Monad m => (a -> r) -> m a -> m r
lift2 :: Monad m => (a -> b -> r) -> m a -> m b -> m r
lift3 :: Monad m => (a -> b -> c -> r) -> m a -> m b -> m c -> m r
lift4 :: Monad m => (a -> b -> c -> d -> r) -> m a -> m b -> m c -> m d -> m r
lift5 :: Monad m => (a -> b -> c -> d -> e -> r) -> m a -> m b -> m c -> m d -> m e -> m r
liftJoin2 :: Monad m => (a -> b -> m c) -> m a -> m b -> m c
liftJoin3 :: Monad m => (a -> b -> c -> m d) -> m a -> m b -> m c -> m d
liftJoin4 :: Monad m => (a -> b -> c -> d -> m e) -> m a -> m b -> m c -> m d -> m e
liftJoin5 :: Monad m => (a -> b -> c -> d -> e -> m f) -> m a -> m b -> m c -> m d -> m e -> m f

module Data.Bits.HT

-- | Infix variant of <a>shiftL</a>. Precedence is chosen like
--   multiplication since <tt>a .&lt;&lt;. k == a * 2^k</tt>.
(.<<.) :: Bits a => a -> Int -> a
infixl 7 .<<.

-- | Infix variant of <a>shiftR</a>. Precedence is chosen like division
--   since <tt>a .&gt;&gt;. k == a / 2^k</tt>.
(.>>.) :: Bits a => a -> Int -> a
infixl 7 .>>.

module Data.Bool.HT

-- | <tt>if-then-else</tt> as function.
--   
--   Example:
--   
--   <pre>
--   if' (even n) "even" $
--   if' (isPrime n) "prime" $
--   "boring"
--   </pre>
if' :: Bool -> a -> a -> a

-- | The same as <a>if'</a>, but the name is chosen such that it can be
--   used for GHC-7.0's rebindable if-then-else syntax.
ifThenElse :: Bool -> a -> a -> a

-- | From a list of expressions choose the one, whose condition is true.
--   
--   Example:
--   
--   <pre>
--   select "boring" $
--     (even n, "even") :
--     (isPrime n, "prime") :
--     []
--   </pre>
select :: a -> [(Bool, a)] -> a

-- | Like the <tt>?</tt> operator of the C progamming language.
--   
--   <pre>
--   &gt;&gt;&gt; True ?: ("yes", "no")
--   "yes"
--   
--   &gt;&gt;&gt; False ?: ("yes", "no")
--   "no"
--   </pre>
(?:) :: Bool -> (a, a) -> a
infixr 1 ?:

-- | Logical operator for implication.
--   
--   Funnily because of the ordering of <a>Bool</a> it holds:
--   
--   <pre>
--   \a b -&gt; implies a b == (a&lt;=b)
--   </pre>
implies :: Bool -> Bool -> Bool
infixr 1 `implies`

module Data.Either.HT
mapLeft :: (a -> b) -> Either a c -> Either b c
mapRight :: (b -> c) -> Either a b -> Either a c
mapBoth :: (a -> c) -> (b -> d) -> Either a b -> Either c d
maybeLeft :: Either a b -> Maybe a
maybeRight :: Either a b -> Maybe b
swap :: Either a b -> Either b a


-- | Implementations of <tt>Ix</tt> methods in terms of <a>Enum</a>
--   methods.
--   
--   For a type <tt>T</tt> of class <a>Enum</a> you can easily define an
--   <tt>Ix</tt> instance by copying the following code into your module:
--   
--   <pre>
--   import qualified Data.Ix.Enum as IxEnum
--   
--   instance Ix T where
--      range           = IxEnum.range
--      index           = IxEnum.index
--      inRange         = IxEnum.inRange
--      rangeSize       = IxEnum.rangeSize
--      unsafeIndex     = IxEnum.unsafeIndex
--      unsafeRangeSize = IxEnum.unsafeRangeSize
--   </pre>
module Data.Ix.Enum
range :: Enum a => (a, a) -> [a]
index :: Enum a => (a, a) -> a -> Int
unsafeIndex :: Enum a => (a, a) -> a -> Int
inRange :: Enum a => (a, a) -> a -> Bool
rangeSize :: Enum a => (a, a) -> Int
unsafeRangeSize :: Enum a => (a, a) -> Int

module Data.Maybe.HT

-- | Returns <a>Just</a> if the precondition is fulfilled. prop&gt; b x
--   -&gt; (guard b &gt;&gt; x) == (toMaybe b =&lt;&lt; (x::Maybe Char))
toMaybe :: Bool -> a -> Maybe a

-- | This is an infix version of <a>fmap</a> for writing <a>select</a>
--   style expressions using test functions, that produce <a>Maybe</a>s.
--   
--   The precedence is chosen to be higher than <tt>(:)</tt>, in order to
--   allow:
--   
--   <pre>
--   alternatives default $
--      checkForA ?-&gt; (\a -&gt; f a) :
--      checkForB ?-&gt; (\b -&gt; g b) :
--      []
--   </pre>
--   
--   The operation is left associative in order to allow to write
--   
--   <pre>
--   checkForA ?-&gt; f ?-&gt; g
--   </pre>
--   
--   which is equivalent to
--   
--   <pre>
--   checkForA ?-&gt; g . f
--   </pre>
--   
--   due to the functor law.
(?->) :: Maybe a -> (a -> b) -> Maybe b
infixl 6 ?->
alternatives :: a -> [Maybe a] -> a

module Data.Monoid.HT

-- | Generalization of <a>cycle</a> to any monoid.
cycle :: Monoid m => m -> m

-- | Infix synonym for <a>mappend</a>.
(<>) :: Monoid m => m -> m -> m
infixr 6 <>

-- | <pre>
--   \b m -&gt; when b m == mfilter (const b) (m::Maybe Ordering)
--   </pre>
--   
--   <pre>
--   \b m -&gt; when b m == mfilter (const b) (m::String)
--   </pre>
when :: Monoid m => Bool -> m -> m

-- | <pre>
--   QC.forAll (QC.choose (0,20)) $ \k xs -&gt; power (fromIntegral k) xs == mconcat (replicate k (xs::String))
--   </pre>
--   
--   In contrast to <tt>powerAssociative</tt> the <a>power</a> function
--   uses <a>mempty</a> only for the zeroth power.
--   
--   <pre>
--   QC.forAll (QC.choose (0,20)) $ \k xs -&gt; power k xs == powerAssociative mappend mempty (xs::String) k
--   </pre>
power :: Monoid m => Integer -> m -> m

module Data.Strictness.HT
arguments1 :: (a -> x) -> a -> x
arguments2 :: (a -> b -> x) -> a -> b -> x
arguments3 :: (a -> b -> c -> x) -> a -> b -> c -> x
arguments4 :: (a -> b -> c -> d -> x) -> a -> b -> c -> d -> x
arguments5 :: (a -> b -> c -> d -> e -> x) -> a -> b -> c -> d -> e -> x

module Data.Tuple.Lazy

-- | Cf. <a>(***)</a>.
--   
--   Apply two functions on corresponding values in a pair, where the
--   pattern match on the pair constructor is lazy. This is crucial in
--   recursions such as the one of <tt>partition</tt>. One the other hand
--   there are applications where strict application is crucial, e.g.
--   <tt>mapSnd f ab</tt> where the left pair member is a large lazy list.
--   With the lazy <tt>mapSnd</tt> we make the application of <tt>f</tt>
--   depend on the whole pair <tt>ab</tt>. See <a>Data.Tuple.Example</a>
--   for two examples where one variant is definitely better than the other
--   one.
mapPair :: (a -> c, b -> d) -> (a, b) -> (c, d)

-- | <a>first</a>
mapFst :: (a -> c) -> (a, b) -> (c, b)

-- | <a>second</a>
mapSnd :: (b -> c) -> (a, b) -> (a, c)
zipPair :: (a, b) -> (c, d) -> ((a, c), (b, d))
zipWithPair :: (a -> c -> e, b -> d -> f) -> (a, b) -> (c, d) -> (e, f)
swap :: (a, b) -> (b, a)
forcePair :: (a, b) -> (a, b)
mapTriple :: (a -> d, b -> e, c -> f) -> (a, b, c) -> (d, e, f)
mapFst3 :: (a -> d) -> (a, b, c) -> (d, b, c)
mapSnd3 :: (b -> d) -> (a, b, c) -> (a, d, c)
mapThd3 :: (c -> d) -> (a, b, c) -> (a, b, d)
zipWithTriple :: (a -> d -> g, b -> e -> h, c -> f -> i) -> (a, b, c) -> (d, e, f) -> (g, h, i)
uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d

module Data.Tuple.HT

-- | Cf. <a>(***)</a>.
--   
--   Apply two functions on corresponding values in a pair, where the
--   pattern match on the pair constructor is lazy. This is crucial in
--   recursions such as the one of <tt>partition</tt>. One the other hand
--   there are applications where strict application is crucial, e.g.
--   <tt>mapSnd f ab</tt> where the left pair member is a large lazy list.
--   With the lazy <tt>mapSnd</tt> we make the application of <tt>f</tt>
--   depend on the whole pair <tt>ab</tt>. See <a>Data.Tuple.Example</a>
--   for two examples where one variant is definitely better than the other
--   one.
mapPair :: (a -> c, b -> d) -> (a, b) -> (c, d)

-- | <a>first</a>
mapFst :: (a -> c) -> (a, b) -> (c, b)

-- | <a>second</a>
mapSnd :: (b -> c) -> (a, b) -> (a, c)
swap :: (a, b) -> (b, a)

-- | This is convenient for quick hacks but I suggest that you better
--   define a type for an ordered pair for your application at hand. This
--   way, you can clearly see from the type that a pair is ordered.
sortPair :: Ord a => (a, a) -> (a, a)
forcePair :: (a, b) -> (a, b)

-- | Known as <tt>dup</tt> in the <tt>Arrow</tt> literature.
double :: a -> (a, a)
fst3 :: (a, b, c) -> a
snd3 :: (a, b, c) -> b
thd3 :: (a, b, c) -> c
mapTriple :: (a -> d, b -> e, c -> f) -> (a, b, c) -> (d, e, f)
mapFst3 :: (a -> d) -> (a, b, c) -> (d, b, c)
mapSnd3 :: (b -> d) -> (a, b, c) -> (a, d, c)
mapThd3 :: (c -> d) -> (a, b, c) -> (a, b, d)
curry3 :: ((a, b, c) -> d) -> a -> b -> c -> d
uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d
triple :: a -> (a, a, a)


-- | The functions in this module process the list from the end. They do
--   not access elements at the beginning if not necessary. You can apply
--   the function only to finite lists. Use these functions if the list is
--   short and the test is expensive.
module Data.List.Reverse.StrictSpine

-- | <pre>
--   forAllPredicates $ \p xs -&gt; Rev.dropWhile p xs == reverse (List.dropWhile p (reverse xs))
--   </pre>
--   
--   <pre>
--   \x xs pad -&gt; defined $ length $ Rev.dropWhile ((x::Char)/=) $ Match.replicate (pad::[()]) undefined ++ x:xs
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | <pre>
--   forAllPredicates $ \p xs -&gt; Rev.takeWhile p xs == reverse (List.takeWhile p (reverse xs))
--   </pre>
--   
--   <pre>
--   \x xs pad -&gt; defined $ Rev.takeWhile ((x::Char)/=) $ Match.replicate (pad::[()]) undefined ++ x:xs
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <pre>
--   forAllPredicates $ \p xs -&gt; Rev.span p xs == swap (mapPair (reverse, reverse) (List.span p (reverse xs)))
--   </pre>
--   
--   <pre>
--   forAllPredicates $ \p xs -&gt; Rev.span p xs == (Rev.dropWhile p xs, Rev.takeWhile p xs)
--   </pre>
--   
--   <pre>
--   \x xs pad -&gt; defined $ mapFst length $ Rev.span ((x::Char)/=) $ Match.replicate (pad::[()]) undefined ++ x:xs
--   </pre>
span :: (a -> Bool) -> [a] -> ([a], [a])

module Data.String.HT

-- | Remove leading and trailing spaces.
--   
--   We use spine strict <a>dropWhile</a> instead of the element strict
--   version. This is more efficient for finite <a>String</a>s because
--   <a>isSpace</a> is expensive. The downside is that <a>trim</a> does not
--   work for infinite <a>String</a>s.
trim :: String -> String


-- | The functions in this module process the list formally from the end.
--   Actually they traverse the list from the start and check every
--   element. This way they are strict in the elements and lazy in the list
--   spline. Thus you can apply them to infinite lists. Use these functions
--   if the list is long or the test is cheap.
module Data.List.Reverse.StrictElement

-- | Remove the longest suffix of elements satisfying p. In contrast to
--   <tt>reverse . dropWhile p . reverse</tt> this works for infinite
--   lists, too.
--   
--   <pre>
--   forAllPredicates $ \p xs -&gt; Rev.dropWhile p xs == reverse (List.dropWhile p (reverse xs))
--   </pre>
--   
--   <pre>
--   \x xs pad -&gt; defined $ Match.take (pad::[()]) $ Rev.dropWhile ((x::Char)/=) $ cycle $ x:xs
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | Alternative version of <tt>reverse . takeWhile p . reverse</tt>.
--   
--   <pre>
--   forAllPredicates $ \p xs -&gt; Rev.takeWhile p xs == reverse (List.takeWhile p (reverse xs))
--   </pre>
takeWhile :: (a -> Bool) -> [a] -> [a]

-- | <pre>
--   forAllPredicates $ \p xs -&gt; Rev.span p xs == swap (mapPair (reverse, reverse) (List.span p (reverse xs)))
--   </pre>
--   
--   <pre>
--   forAllPredicates $ \p xs -&gt; Rev.span p xs == (Rev.dropWhile p xs, Rev.takeWhile p xs)
--   </pre>
--   
--   <pre>
--   \x xs pad -&gt; defined $ Match.take (pad::[()]) $ fst $ Rev.span ((x::Char)/=) $ cycle $ x:xs
--   </pre>
span :: (a -> Bool) -> [a] -> ([a], [a])

module Data.Function.HT

-- | Useful for adding type annotations like in
--   
--   <pre>
--   f . (id :: Id Char) . g
--   </pre>
type Id a = a -> a

-- | Compositional power of a function, i.e. apply the function <tt>n</tt>
--   times to a value. It is rather the same as <tt>iter</tt> in Simon
--   Thompson: "The Craft of Functional Programming", page 172
nest :: Int -> (a -> a) -> a -> a

-- | <tt>powerAssociative</tt> is an auxiliary function that, for an
--   associative operation <tt>op</tt>, computes the same value as
--   
--   <pre>
--   powerAssociative op a0 a n = foldr op a0 (genericReplicate n a)
--   </pre>
--   
--   but applies "op" O(log n) times and works for large n.
powerAssociative :: (a -> a -> a) -> a -> a -> Integer -> a

-- | Known as <tt>on</tt> in newer versions of the <tt>base</tt> package.
compose2 :: (b -> b -> c) -> (a -> b) -> a -> a -> c

module Data.Ord.HT
comparing :: Ord b => (a -> b) -> a -> a -> Ordering

-- | <tt>limit (lower,upper) x</tt> restricts <tt>x</tt> to the range from
--   <tt>lower</tt> to <tt>upper</tt>. Don't expect a sensible result for
--   <tt>lower&gt;upper</tt>.
limit :: Ord a => (a, a) -> a -> a

-- | <tt>limit (lower,upper) x</tt> checks whether <tt>x</tt> is in the
--   range from <tt>lower</tt> to <tt>upper</tt>. Don't expect a sensible
--   result for <tt>lower&gt;upper</tt>.
inRange :: Ord a => (a, a) -> a -> Bool


-- | Variant of <a>Data.List</a> functions like <a>group</a>, <a>sort</a>
--   where the comparison is performed on a key computed from the list
--   elements. In principle these functions could be replaced by e.g.
--   <tt>sortBy (compare <tt>on</tt> f)</tt>, but <tt>f</tt> will be
--   re-computed for every comparison. If the evaluation of <tt>f</tt> is
--   expensive, our functions are better, since they buffer the results of
--   <tt>f</tt>.
module Data.List.Key
nub :: Eq b => (a -> b) -> [a] -> [a]
sort :: Ord b => (a -> b) -> [a] -> [a]

-- | argmin
minimum :: Ord b => (a -> b) -> [a] -> a

-- | argmax
maximum :: Ord b => (a -> b) -> [a] -> a

-- | Divides a list into sublists such that the members in a sublist share
--   the same key. It uses semantics of <a>groupBy</a>, not that of
--   <a>groupBy</a>.
group :: Eq b => (a -> b) -> [a] -> [[a]]
merge :: Ord b => (a -> b) -> [a] -> [a] -> [a]

module Data.Eq.HT
equating :: Eq b => (a -> b) -> a -> a -> Bool

module Control.Functor.HT
void :: Functor f => f a -> f ()
map :: Functor f => (a -> b) -> f a -> f b
for :: Functor f => f a -> (a -> b) -> f b

-- | Caution: Every pair member has a reference to the argument of
--   <a>unzip</a>. Depending on the consumption pattern this may cause a
--   memory leak. For lists, I think, you should generally prefer
--   <a>unzip</a>.
unzip :: Functor f => f (a, b) -> (f a, f b)

-- | Caution: See <a>unzip</a>.
unzip3 :: Functor f => f (a, b, c) -> (f a, f b, f c)

-- | Caution: See <a>unzip</a>.
uncurry :: Functor f => (f a -> f b -> g) -> f (a, b) -> g

-- | Caution: See <a>unzip</a>.
uncurry3 :: Functor f => (f a -> f b -> f c -> g) -> f (a, b, c) -> g
mapFst :: Functor f => (a -> f c) -> (a, b) -> f (c, b)
mapSnd :: Functor f => (b -> f c) -> (a, b) -> f (a, c)
mapFst3 :: Functor f => (a -> f d) -> (a, b, c) -> f (d, b, c)
mapSnd3 :: Functor f => (b -> f d) -> (a, b, c) -> f (a, d, c)
mapThd3 :: Functor f => (c -> f d) -> (a, b, c) -> f (a, b, d)

-- | Generalization of <a>outerProduct</a>.
outerProduct :: (Functor f, Functor g) => (a -> b -> c) -> f a -> g b -> f (g c)

module Data.List.Match

-- | Make a list as long as another one
--   
--   <pre>
--   \(Shape xs) (List ys) -&gt; Match.take xs ys == List.take (length xs) ys
--   </pre>
take :: [b] -> [a] -> [a]

-- | Drop as many elements as the first list is long
--   
--   <pre>
--   \(Shape xs) (List ys) -&gt; Match.drop xs ys == List.drop (length xs) ys
--   </pre>
--   
--   <pre>
--   \(Shape xs) (List ys) -&gt; Match.take xs ys ++ Match.drop xs ys == ys
--   </pre>
drop :: [b] -> [a] -> [a]

-- | <pre>
--   \(Shape xs) (List ys) -&gt; Match.splitAt xs ys == (Match.take xs ys, Match.drop xs ys)
--   </pre>
--   
--   <pre>
--   \(Shape xs) (List ys) -&gt; Match.splitAt xs ys == List.splitAt (length xs) ys
--   </pre>
splitAt :: [b] -> [a] -> ([a], [a])

-- | <pre>
--   \(Shape xs) (List ys) -&gt; Match.takeRev xs ys == reverse (Match.take xs (reverse ys))
--   </pre>
takeRev :: [b] -> [a] -> [a]

-- | <pre>
--   \(Shape xs) (List ys) -&gt; Match.dropRev xs ys == reverse (Match.drop xs (reverse ys))
--   </pre>
dropRev :: [b] -> [a] -> [a]

-- | Specialisation of <a>$&gt;</a>.
replicate :: [a] -> b -> [b]

-- | Check whether two lists with different element types have equal
--   length. It holds
--   
--   <pre>
--   \(Shape xs) (List ys) -&gt; equalLength xs ys == (length xs == length ys)
--   </pre>
--   
--   but <a>equalLength</a> is more efficient.
equalLength :: [a] -> [b] -> Bool

-- | Compare the length of two lists over different types. It holds
--   
--   <pre>
--   \(Shape xs) (List ys) -&gt; compareLength xs ys == compare (length xs) (length ys)
--   </pre>
--   
--   but <a>compareLength</a> is more efficient.
compareLength :: [a] -> [b] -> Ordering

-- | <tt>lessOrEqualLength x y</tt> is almost the same as <tt>compareLength
--   x y &lt;= EQ</tt>, but
--   
--   <pre>
--   &gt;&gt;&gt; lessOrEqualLength "" undefined
--   True
--   </pre>
--   
--   whereas <tt>compareLength [] undefined &lt;= EQ = undefined</tt>.
lessOrEqualLength :: [a] -> [b] -> Bool

-- | Returns the shorter one of two lists. It works also for infinite lists
--   as much as possible. E.g.
--   
--   <pre>
--   &gt;&gt;&gt; shorterList (shorterList (repeat 'a') (repeat 'b')) "abc"
--   "abc"
--   </pre>
--   
--   The trick is, that the skeleton of the resulting list is constructed
--   using <a>zipWith</a> without touching the elements. The contents is
--   then computed (only) if requested.
shorterList :: [a] -> [a] -> [a]

module Data.List.HT

-- | This function is lazier than the one suggested in the Haskell 98
--   report. It is <tt>inits undefined = [] : undefined</tt>, in contrast
--   to <tt>Data.List.inits undefined = undefined</tt>.
inits :: [a] -> [[a]]

-- | This function is lazier than the one suggested in the Haskell 98
--   report. It is <tt>tails undefined = ([] : undefined) : undefined</tt>,
--   in contrast to <tt>Data.List.tails undefined = undefined</tt>.
tails :: [a] -> [[a]]

-- | This function compares adjacent elements of a list. If two adjacent
--   elements satisfy a relation then they are put into the same sublist.
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; groupBy (&lt;) "abcdebcdef"
--   ["abcde","bcdef"]
--   </pre>
--   
--   In contrast to that <a>groupBy</a> compares the head of each sublist
--   with each candidate for this sublist. This yields
--   
--   <pre>
--   &gt;&gt;&gt; List.groupBy (&lt;) "abcdebcdef"
--   ["abcdebcdef"]
--   </pre>
--   
--   The second <tt><tt>b</tt></tt> is compared with the leading
--   <tt><tt>a</tt></tt>. Thus it is put into the same sublist as
--   <tt><tt>a</tt></tt>.
--   
--   The sublists are never empty. Thus the more precise result type would
--   be <tt>[(a,[a])]</tt>.
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
group :: Eq a => [a] -> [[a]]

-- | Like standard <a>unzip</a> but more lazy. It is <tt>Data.List.unzip
--   undefined == undefined</tt>, but <tt>unzip undefined == (undefined,
--   undefined)</tt>.
unzip :: [(a, b)] -> ([a], [b])

-- | <a>partition</a> of GHC 6.2.1 fails on infinite lists. But this one
--   does not.
partition :: (a -> Bool) -> [a] -> ([a], [a])

-- | It is <tt>Data.List.span f undefined = undefined</tt>, whereas
--   <tt>span f undefined = (undefined, undefined)</tt>.
span :: (a -> Bool) -> [a] -> ([a], [a])

-- | It is <tt>Data.List.span f undefined = undefined</tt>, whereas
--   <tt>span f undefined = (undefined, undefined)</tt>.
break :: (a -> Bool) -> [a] -> ([a], [a])

-- | Split the list at the occurrences of a separator into sub-lists.
--   Remove the separators. This is somehow a generalization of
--   <a>lines</a> and <a>words</a>. But note the differences:
--   
--   <pre>
--   &gt;&gt;&gt; words "a  a"
--   ["a","a"]
--   
--   &gt;&gt;&gt; chop (' '==) "a  a"
--   ["a","","a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "a\n\na"
--   ["a","","a"]
--   
--   &gt;&gt;&gt; chop ('\n'==) "a\n\na"
--   ["a","","a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lines "a\n"
--   ["a"]
--   
--   &gt;&gt;&gt; chop ('\n'==) "a\n"
--   ["a",""]
--   </pre>
chop :: (a -> Bool) -> [a] -> [[a]]

-- | Like <a>break</a>, but splits after the matching element.
--   
--   <pre>
--   forAllPredicates $ \p xs -&gt; uncurry (++) (breakAfter p xs) == xs
--   </pre>
breakAfter :: (a -> Bool) -> [a] -> ([a], [a])

-- | Take all elements until one matches. The matching element is returned,
--   too. This is the key difference to <tt>takeWhile (not . p)</tt>. It
--   holds:
--   
--   <pre>
--   forAllPredicates $ \p xs -&gt; takeUntil p xs == fst (breakAfter p xs)
--   </pre>
takeUntil :: (a -> Bool) -> [a] -> [a]

-- | Split the list after each occurence of a terminator. Keep the
--   terminator. There is always a list for the part after the last
--   terminator. It may be empty. See package <tt>non-empty</tt> for more
--   precise result type.
--   
--   <pre>
--   forAllPredicates $ \p xs -&gt; concat (segmentAfter p xs) == xs
--   </pre>
--   
--   <pre>
--   forAllPredicates $ \p xs -&gt; length (filter p xs) == length (tail (segmentAfter p xs))
--   </pre>
--   
--   <pre>
--   forAllPredicates $ \p -&gt; all (p . last) . init . segmentAfter p
--   </pre>
--   
--   <pre>
--   forAllPredicates $ \p -&gt; all (all (not . p) . init) . init . segmentAfter p
--   </pre>
--   
--   This test captures both infinitely many groups and infinitely big
--   groups:
--   
--   <pre>
--   forAllPredicates $ \p x -&gt; flip seq True . (!!100) . concat . segmentAfter p . cycle . (x:)
--   </pre>
segmentAfter :: (a -> Bool) -> [a] -> [[a]]

-- | Split the list before each occurence of a leading character. Keep
--   these characters. There is always a list for the part before the first
--   leading character. It may be empty. See package <tt>non-empty</tt> for
--   more precise result type.
--   
--   <pre>
--   forAllPredicates $ \p xs -&gt; concat (segmentBefore p xs) == xs
--   </pre>
--   
--   <pre>
--   forAllPredicates $ \p xs -&gt; length (filter p xs) == length (tail (segmentBefore p xs))
--   </pre>
--   
--   <pre>
--   forAllPredicates $ \p -&gt; all (p . head) . tail . segmentBefore p
--   </pre>
--   
--   <pre>
--   forAllPredicates $ \p -&gt; all (all (not . p) . tail) . tail . segmentBefore p
--   </pre>
--   
--   <pre>
--   forAllPredicates $ \p x -&gt; flip seq True . (!!100) . concat . segmentBefore p . cycle . (x:)
--   </pre>
segmentBefore :: (a -> Bool) -> [a] -> [[a]]

-- | <pre>
--   &gt;&gt;&gt; segmentAfterJust (\c -&gt; toMaybe (isLetter c) (toUpper c)) "123a5345b---"
--   ([("123",'A'),("5345",'B')],"---")
--   </pre>
segmentAfterJust :: (a -> Maybe b) -> [a] -> ([([a], b)], [a])

-- | <i>Deprecated: use segmentAfterJust instead</i>
segmentAfterMaybe :: (a -> Maybe b) -> [a] -> ([([a], b)], [a])

-- | <pre>
--   &gt;&gt;&gt; segmentBeforeJust (\c -&gt; toMaybe (isLetter c) (toUpper c)) "123a5345b---"
--   ("123",[('A',"5345"),('B',"---")])
--   </pre>
segmentBeforeJust :: (a -> Maybe b) -> [a] -> ([a], [(b, [a])])

-- | <i>Deprecated: use segmentBeforeJust instead</i>
segmentBeforeMaybe :: (a -> Maybe b) -> [a] -> ([a], [(b, [a])])

-- | <pre>
--   &gt;&gt;&gt; segmentAfterRight [Left 'a', Right LT, Right GT, Left 'b']
--   ([("a",LT),("",GT)],"b")
--   </pre>
--   
--   <pre>
--   forAllMaybeFn $ \f xs -&gt; segmentAfterJust f xs == segmentAfterRight (map (\x -&gt; maybe (Left x) Right (f x)) xs)
--   </pre>
segmentAfterRight :: [Either a b] -> ([([a], b)], [a])

-- | <pre>
--   &gt;&gt;&gt; segmentBeforeRight [Left 'a', Right LT, Right GT, Left 'b']
--   ("a",[(LT,""),(GT,"b")])
--   </pre>
--   
--   <pre>
--   forAllMaybeFn $ \f xs -&gt; segmentBeforeJust f xs == segmentBeforeRight (map (\x -&gt; maybe (Left x) Right (f x)) xs)
--   </pre>
segmentBeforeRight :: [Either a b] -> ([a], [(b, [a])])

-- | <tt>removeEach xs</tt> represents a list of sublists of <tt>xs</tt>,
--   where each element of <tt>xs</tt> is removed and the removed element
--   is separated. It seems to be much simpler to achieve with <tt>zip xs
--   (map (flip List.delete xs) xs)</tt>, but the implementation of
--   <a>removeEach</a> does not need the <a>Eq</a> instance and thus can
--   also be used for lists of functions.
--   
--   See also the proposal
--   <a>http://www.haskell.org/pipermail/libraries/2008-February/009270.html</a>
--   
--   <pre>
--   &gt;&gt;&gt; removeEach "abc"
--   [('a',"bc"),('b',"ac"),('c',"ab")]
--   
--   &gt;&gt;&gt; removeEach "a"
--   [('a',"")]
--   
--   &gt;&gt;&gt; removeEach ""
--   []
--   </pre>
removeEach :: [a] -> [(a, [a])]

-- | <pre>
--   &gt;&gt;&gt; splitEverywhere "abc"
--   [("",'a',"bc"),("a",'b',"c"),("ab",'c',"")]
--   
--   &gt;&gt;&gt; splitEverywhere "a"
--   [("",'a',"")]
--   
--   &gt;&gt;&gt; splitEverywhere ""
--   []
--   </pre>
splitEverywhere :: [a] -> [([a], a, [a])]

-- | It holds <tt>splitLast xs == (init xs, last xs)</tt>, but
--   <a>splitLast</a> is more efficient if the last element is accessed
--   after the initial ones, because it avoids memoizing list.
--   
--   <pre>
--   \(NonEmpty xs) -&gt; splitLast (xs::String)  ==  (init xs, last xs)
--   </pre>

-- | <i>Deprecated: use viewR instead</i>
splitLast :: [a] -> ([a], a)

-- | Should be prefered to <a>head</a> and <a>tail</a>.
viewL :: [a] -> Maybe (a, [a])

-- | Should be prefered to <a>init</a> and <a>last</a>.
--   
--   <pre>
--   \xs -&gt; maybe True ((init xs, last xs) == ) (viewR (xs::String))
--   </pre>
viewR :: [a] -> Maybe ([a], a)

-- | Should be prefered to <a>head</a> and <a>tail</a>.
switchL :: b -> (a -> [a] -> b) -> [a] -> b

-- | Should be prefered to <a>init</a> and <a>last</a>.
--   
--   <pre>
--   \xs -&gt; switchR True (\ixs lxs -&gt; ixs == init xs &amp;&amp; lxs == last xs) (xs::String)
--   </pre>
switchR :: b -> ([a] -> a -> b) -> [a] -> b

-- | <tt>dropRev n</tt> is like <tt>reverse . drop n . reverse</tt> but it
--   is lazy enough to work for infinite lists, too.
--   
--   <pre>
--   \n xs -&gt; dropRev n (xs::String) == reverse (drop n (reverse xs))
--   </pre>
dropRev :: Int -> [a] -> [a]

-- | <tt>takeRev n</tt> is like <tt>reverse . take n . reverse</tt> but it
--   is lazy enough to work for infinite lists, too.
--   
--   <pre>
--   \n xs -&gt; takeRev n (xs::String) == reverse (take n (reverse xs))
--   </pre>
takeRev :: Int -> [a] -> [a]

-- | <tt>splitAtRev n xs == (dropRev n xs, takeRev n xs)</tt>.
--   
--   <pre>
--   \n xs -&gt; splitAtRev n (xs::String) == (dropRev n xs, takeRev n xs)
--   </pre>
--   
--   <pre>
--   \n xs -&gt; (xs::String) == uncurry (++) (splitAtRev n xs)
--   </pre>
splitAtRev :: Int -> [a] -> ([a], [a])

-- | <i>Deprecated: Use dropWhile from Data.List.Reverse.StrictElement or
--   Data.List.Reverse.StrictSpine instead</i>
dropWhileRev :: (a -> Bool) -> [a] -> [a]

-- | <i>Deprecated: Use takeWhile from Data.List.Reverse.StrictElement or
--   Data.List.Reverse.StrictSpine instead</i>
takeWhileRev :: (a -> Bool) -> [a] -> [a]

-- | <tt>maybePrefixOf xs ys</tt> is <tt>Just zs</tt> if <tt>xs</tt> is a
--   prefix of <tt>ys</tt>, where <tt>zs</tt> is <tt>ys</tt> without the
--   prefix <tt>xs</tt>. Otherwise it is <tt>Nothing</tt>. It is the same
--   as <a>stripPrefix</a>.
--   
--   <pre>
--   &gt;&gt;&gt; maybePrefixOf "abc" "abcdef"
--   Just "def"
--   
--   &gt;&gt;&gt; maybePrefixOf "def" "abcdef"
--   Nothing
--   </pre>
maybePrefixOf :: Eq a => [a] -> [a] -> Maybe [a]

-- | <pre>
--   &gt;&gt;&gt; maybeSuffixOf "abc" "abcdef"
--   Nothing
--   
--   &gt;&gt;&gt; maybeSuffixOf "def" "abcdef"
--   Just "abc"
--   </pre>
maybeSuffixOf :: Eq a => [a] -> [a] -> Maybe [a]

-- | Partition a list into elements which evaluate to <tt>Just</tt> or
--   <tt>Nothing</tt> by <tt>f</tt>.
--   
--   <pre>
--   forAllMaybeFn $ \f xs -&gt; partitionMaybe f xs == (mapMaybe f xs, filter (isNothing . f) xs)
--   </pre>
--   
--   <pre>
--   forAllPredicates $ \p xs -&gt; partition p xs == partitionMaybe (\x -&gt; toMaybe (p x) x) xs
--   </pre>
partitionMaybe :: (a -> Maybe b) -> [a] -> ([b], [a])

-- | This is the cousin of <a>takeWhile</a> analogously to <a>catMaybes</a>
--   being the cousin of <a>filter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; takeWhileJust [Just 'a', Just 'b', Nothing, Just 'c']
--   "ab"
--   </pre>
--   
--   Example: Keep the heads of sublists until an empty list occurs.
--   
--   <pre>
--   &gt;&gt;&gt; takeWhileJust $ map (fmap fst . viewL) ["abc","def","","xyz"]
--   "ad"
--   </pre>
--   
--   For consistency with <a>takeWhile</a>, <a>partitionMaybe</a> and
--   <a>dropWhileNothing</a> it should have been:
--   
--   <pre>
--   takeWhileJust_ :: (a -&gt; Maybe b) -&gt; a -&gt; [b]
--   </pre>
--   
--   However, both variants are interchangeable:
--   
--   <pre>
--   takeWhileJust_ f == takeWhileJust . map f
--   takeWhileJust == takeWhileJust_ id
--   </pre>
takeWhileJust :: [Maybe a] -> [a]
dropWhileNothing :: (a -> Maybe b) -> [a] -> Maybe (b, [a])

-- | <pre>
--   forAllMaybeFn $ \f xs -&gt; snd (breakJust f xs) == dropWhileNothing f xs
--   </pre>
breakJust :: (a -> Maybe b) -> [a] -> ([a], Maybe (b, [a]))
spanJust :: (a -> Maybe b) -> [a] -> ([b], [a])
unzipEithers :: [Either a b] -> ([a], [b])

-- | keep every k-th value from the list
--   
--   <pre>
--   &gt;&gt;&gt; sieve 6 ['a'..'z']
--   "agmsy"
--   </pre>
sieve :: Int -> [a] -> [a]

-- | <pre>
--   &gt;&gt;&gt; sliceHorizontal 6 ['a'..'z']
--   ["agmsy","bhntz","ciou","djpv","ekqw","flrx"]
--   </pre>
--   
--   <pre>
--   \(NonEmpty xs) -&gt; QC.forAll (QC.choose (1, length xs)) $ \n -&gt; sliceHorizontal n xs == transpose (sliceVertical n (xs::String))
--   </pre>
--   
--   <pre>
--   \(NonEmpty xs) -&gt; QC.forAll (QC.choose (1, length xs)) $ \n -&gt; sliceVertical  n xs == transpose (sliceHorizontal n (xs::String))
--   </pre>
--   
--   The properties do not hold for empty lists because of:
--   
--   <pre>
--   &gt;&gt;&gt; sliceHorizontal 4 ([]::[Int])
--   [[],[],[],[]]
--   </pre>
sliceHorizontal :: Int -> [a] -> [[a]]

-- | <pre>
--   &gt;&gt;&gt; sliceVertical 6 ['a'..'z']
--   ["abcdef","ghijkl","mnopqr","stuvwx","yz"]
--   </pre>
sliceVertical :: Int -> [a] -> [[a]]
search :: Eq a => [a] -> [a] -> [Int]

-- | <pre>
--   \(NonEmpty xs) ys -&gt; replace xs xs ys == (ys::String)
--   </pre>
--   
--   <pre>
--   \(NonEmpty xs) (NonEmpty ys) -&gt; equating (take 1000) (replace xs ys (cycle xs)) (cycle (ys::String))
--   </pre>
replace :: Eq a => [a] -> [a] -> [a] -> [a]

-- | prop src dst xs -&gt; replace src dst xs == multiReplace
--   <a>(src,dst)</a>
multiReplace :: Eq a => [([a], [a])] -> [a] -> [a]

-- | Transform
--   
--   <pre>
--   [[00,01,02,...],          [[00],
--    [10,11,12,...],   --&gt;     [10,01],
--    [20,21,22,...],           [20,11,02],
--    ...]                      ...]
--   </pre>
--   
--   With <tt>concat . shear</tt> you can perform a Cantor diagonalization,
--   that is an enumeration of all elements of the sub-lists where each
--   element is reachable within a finite number of steps. It is also
--   useful for polynomial multiplication (convolution).
shear :: [[a]] -> [[a]]

-- | Transform
--   
--   <pre>
--   [[00,01,02,...],          [[00],
--    [10,11,12,...],   --&gt;     [01,10],
--    [20,21,22,...],           [02,11,20],
--    ...]                      ...]
--   </pre>
--   
--   It's like <a>shear</a> but the order of elements in the sub list is
--   reversed. Its implementation seems to be more efficient than that of
--   <a>shear</a>. If the order does not matter, better choose
--   <a>shearTranspose</a>.
--   
--   <pre>
--   \xs -&gt; shearTranspose xs  ==  map reverse (shear (xs::[String]))
--   </pre>
shearTranspose :: [[a]] -> [[a]]

-- | Operate on each combination of elements of the first and the second
--   list. In contrast to the list instance of <a>liftM2</a> it holds the
--   results in a list of lists.
--   
--   <pre>
--   \xs ys -&gt; let f x y = (x::Char,y::Int) in concat (outerProduct f xs ys)  ==  liftM2 f xs ys
--   </pre>
outerProduct :: (a -> b -> c) -> [a] -> [b] -> [[c]]

-- | Take while first predicate holds, then continue taking while second
--   predicate holds, and so on.
takeWhileMulti :: [a -> Bool] -> [a] -> [a]

-- | rotate left
rotate :: Int -> [a] -> [a]

-- | Given two lists that are ordered (i.e. <tt>p x y</tt> holds for
--   subsequent <tt>x</tt> and <tt>y</tt>) <a>mergeBy</a> them into a list
--   that is ordered, again.
--   
--   <pre>
--   &gt;&gt;&gt; mergeBy (&lt;=) "agh" "begz"
--   "abegghz"
--   </pre>
mergeBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]

-- | <pre>
--   &gt;&gt;&gt; allEqual "aab"
--   False
--   
--   &gt;&gt;&gt; allEqual "aaa"
--   True
--   
--   &gt;&gt;&gt; allEqual "aa"
--   True
--   
--   &gt;&gt;&gt; allEqual "a"
--   True
--   
--   &gt;&gt;&gt; allEqual ""
--   True
--   </pre>
allEqual :: Eq a => [a] -> Bool

-- | <pre>
--   &gt;&gt;&gt; isAscending "abc"
--   True
--   
--   &gt;&gt;&gt; isAscending "abb"
--   True
--   
--   &gt;&gt;&gt; isAscending "aba"
--   False
--   
--   &gt;&gt;&gt; isAscending "cba"
--   False
--   
--   &gt;&gt;&gt; isAscending "a"
--   True
--   
--   &gt;&gt;&gt; isAscending ""
--   True
--   </pre>
isAscending :: Ord a => [a] -> Bool
isAscendingLazy :: Ord a => [a] -> [Bool]

-- | This function combines every pair of neighbour elements in a list with
--   a certain function.
--   
--   <pre>
--   &gt;&gt;&gt; mapAdjacent (&lt;=) ""
--   []
--   
--   &gt;&gt;&gt; mapAdjacent (&lt;=) "a"
--   []
--   
--   &gt;&gt;&gt; mapAdjacent (&lt;=) "aba"
--   [True,False]
--   
--   &gt;&gt;&gt; mapAdjacent (,) "abc"
--   [('a','b'),('b','c')]
--   </pre>
--   
--   <pre>
--   \x xs -&gt; mapAdjacent subtract (scanl (+) x xs) == (xs::[Integer])
--   </pre>
mapAdjacent :: (a -> a -> b) -> [a] -> [b]

-- | <pre>
--   &gt;&gt;&gt; let f x y z = [x,y]++show(z::Int) in mapAdjacent1 f 'a' [('b',1), ('c',2), ('d',3)]
--   ["ab1","bc2","cd3"]
--   </pre>
mapAdjacent1 :: (a -> a -> b -> c) -> a -> [(a, b)] -> [c]

-- | Enumerate without Enum context. For Enum equivalent to enumFrom.
--   
--   <pre>
--   &gt;&gt;&gt; range 0 :: [Integer]
--   []
--   
--   &gt;&gt;&gt; range 1 :: [Integer]
--   [0]
--   
--   &gt;&gt;&gt; range 8 :: [Integer]
--   [0,1,2,3,4,5,6,7]
--   </pre>
--   
--   <pre>
--   \(NonNegative n) -&gt; length (range n :: [Integer]) == n
--   </pre>
range :: Num a => Int -> [a]
padLeft :: a -> Int -> [a] -> [a]
padRight :: a -> Int -> [a] -> [a]

-- | For an associative operation <tt>op</tt> this computes
--   <tt>iterateAssociative op a = iterate (op a) a</tt> but it is even
--   faster than <tt>map (powerAssociative op a a) [0..]</tt> since it
--   shares temporary results.
--   
--   The idea is: From the list <tt>map (powerAssociative op a a)
--   [0,(2*n)..]</tt> we compute the list <tt>map (powerAssociative op a a)
--   [0,n..]</tt>, and iterate that until <tt>n==1</tt>.
--   
--   <pre>
--   \x -&gt; equating (take 1000) (List.iterate (x+) x) (iterateAssociative (+) (x::Integer))
--   </pre>
iterateAssociative :: (a -> a -> a) -> a -> [a]

-- | This is equal to <a>iterateAssociative</a>. The idea is the following:
--   The list we search is the fixpoint of the function: "Square all
--   elements of the list, then spread it and fill the holes with
--   successive numbers of their left neighbour." This also preserves log n
--   applications per value. However it has a space leak, because for the
--   value with index <tt>n</tt> all elements starting at <tt>div n 2</tt>
--   must be kept.
--   
--   <pre>
--   \x -&gt; equating (take 1000) (List.iterate (x+) x) (iterateLeaky (+) (x::Integer))
--   </pre>
iterateLeaky :: (a -> a -> a) -> a -> [a]

-- | <pre>
--   &gt;&gt;&gt; lengthAtLeast 0 ""
--   True
--   
--   &gt;&gt;&gt; lengthAtLeast 3 "ab"
--   False
--   
--   &gt;&gt;&gt; lengthAtLeast 3 "abc"
--   True
--   
--   &gt;&gt;&gt; lengthAtLeast 3 $ repeat 'a'
--   True
--   
--   &gt;&gt;&gt; lengthAtLeast 3 $ "abc" ++ undefined
--   True
--   </pre>
--   
--   <pre>
--   \n xs -&gt; lengthAtLeast n (xs::String)  ==  (length xs &gt;= n)
--   </pre>
lengthAtLeast :: Int -> [a] -> Bool

-- | <pre>
--   &gt;&gt;&gt; lengthAtMost 0 ""
--   True
--   
--   &gt;&gt;&gt; lengthAtMost 3 "ab"
--   True
--   
--   &gt;&gt;&gt; lengthAtMost 3 "abc"
--   True
--   
--   &gt;&gt;&gt; lengthAtMost 3 "abcd"
--   False
--   
--   &gt;&gt;&gt; lengthAtMost 3 $ repeat 'a'
--   False
--   
--   &gt;&gt;&gt; lengthAtMost 3 $ "abcd" ++ undefined
--   False
--   </pre>
--   
--   <pre>
--   \n xs -&gt; lengthAtMost n (xs::String)  ==  (length xs &lt;= n)
--   </pre>
lengthAtMost :: Int -> [a] -> Bool

module Data.Record.HT

-- | Lexicographically compare a list of attributes of two records.
--   
--   Example:
--   
--   <pre>
--   compare [comparing fst, comparing snd]
--   </pre>
compare :: [a -> a -> Ordering] -> a -> a -> Ordering

-- | Check whether a selected set of fields of two records is equal.
--   
--   Example:
--   
--   <pre>
--   equal [equating fst, equating snd]
--   </pre>
equal :: [a -> a -> Bool] -> a -> a -> Bool

module Control.Applicative.HT
mapPair :: Applicative f => (a -> f c, b -> f d) -> (a, b) -> f (c, d)
mapTriple :: Applicative m => (a -> m d, b -> m e, c -> m f) -> (a, b, c) -> m (d, e, f)
curry :: Applicative f => (f (a, b) -> g) -> f a -> f b -> g
curry3 :: Applicative f => (f (a, b, c) -> g) -> f a -> f b -> f c -> g
lift :: Applicative m => (a -> r) -> m a -> m r
lift2 :: Applicative m => (a -> b -> r) -> m a -> m b -> m r
lift3 :: Applicative m => (a -> b -> c -> r) -> m a -> m b -> m c -> m r
lift4 :: Applicative m => (a -> b -> c -> d -> r) -> m a -> m b -> m c -> m d -> m r
lift5 :: Applicative m => (a -> b -> c -> d -> e -> r) -> m a -> m b -> m c -> m d -> m e -> m r
lift6 :: Applicative m => (a -> b -> c -> d -> e -> f -> r) -> m a -> m b -> m c -> m d -> m e -> m f -> m r

-- | <i>Deprecated: use App.lift4</i>
liftA4 :: Applicative f => (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e

-- | <i>Deprecated: use App.lift5</i>
liftA5 :: Applicative f => (a -> b -> c -> d -> e -> g) -> f a -> f b -> f c -> f d -> f e -> f g

-- | <i>Deprecated: use App.lift6</i>
liftA6 :: Applicative f => (a -> b -> c -> d -> e -> g -> h) -> f a -> f b -> f c -> f d -> f e -> f g -> f h

module Data.Tuple.Strict
mapPair :: (a -> c, b -> d) -> (a, b) -> (c, d)
mapFst :: (a -> c) -> (a, b) -> (c, b)
mapSnd :: (b -> c) -> (a, b) -> (a, c)
zipPair :: (a, b) -> (c, d) -> ((a, c), (b, d))
zipWithPair :: (a -> c -> e, b -> d -> f) -> (a, b) -> (c, d) -> (e, f)
swap :: (a, b) -> (b, a)
mapTriple :: (a -> d, b -> e, c -> f) -> (a, b, c) -> (d, e, f)
mapFst3 :: (a -> d) -> (a, b, c) -> (d, b, c)
mapSnd3 :: (b -> d) -> (a, b, c) -> (a, d, c)
mapThd3 :: (c -> d) -> (a, b, c) -> (a, b, d)
zipWithTriple :: (a -> d -> g, b -> e -> h, c -> f -> i) -> (a, b, c) -> (d, e, f) -> (g, h, i)
uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d

module Text.Read.HT

-- | Parse a string containing an infix operator.
readsInfixPrec :: (Read a, Read b) => String -> Int -> Int -> (a -> b -> c) -> ReadS c

-- | Compose two parsers sequentially.
(.>) :: ReadS (b -> c) -> ReadS b -> ReadS c
infixl 9 .>
readMany :: Read a => String -> [a]
maybeRead :: Read a => String -> Maybe a

module Text.Show.HT

-- | Show a value using an infix operator.
showsInfixPrec :: (Show a, Show b) => String -> Int -> Int -> a -> b -> ShowS
concatS :: [ShowS] -> ShowS
