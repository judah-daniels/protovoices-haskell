<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Data.List.Reverse.StrictElement</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">utility-ht-0.0.16: Various small helper functions for Lists, Maybes, Tuples, Functions</span><ul class="links" id="page-menu"><li><a href="src/Data.List.Reverse.StrictElement.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Data.List.Reverse.StrictElement</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The functions in this module process the list formally from the end.
Actually they traverse the list from the start and check every element.
This way they are strict in the elements and lazy in the list spline.
Thus you can apply them to infinite lists.
Use these functions if the list is long or the test is cheap.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:dropWhile">dropWhile</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:takeWhile">takeWhile</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:span">span</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a])</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Test.Utility (forAllPredicates, defined)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import qualified Data.List.Reverse.StrictElement as Rev
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import qualified Data.List.Match as Match
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import qualified Data.List as List
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Data.Tuple.HT (mapPair, swap)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>_suppressUnusedImportWarning :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>_suppressUnusedImportWarning = Data.List.Reverse.StrictElement.dropWhile
</code></strong></pre></div><div class="top"><p class="src"><a id="v:dropWhile" class="def">dropWhile</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] <a href="src/Data.List.Reverse.StrictElement.html#dropWhile" class="link">Source</a> <a href="#v:dropWhile" class="selflink">#</a></p><div class="doc"><p>Remove the longest suffix of elements satisfying p.
In contrast to <code>reverse . dropWhile p . reverse</code>
this works for infinite lists, too.</p><pre>forAllPredicates $ \p xs -&gt; Rev.dropWhile p xs == reverse (List.dropWhile p (reverse xs))</pre><pre>\x xs pad -&gt; defined $ Match.take (pad::[()]) $ Rev.dropWhile ((x::Char)/=) $ cycle $ x:xs</pre></div></div><div class="top"><p class="src"><a id="v:takeWhile" class="def">takeWhile</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] <a href="src/Data.List.Reverse.StrictElement.html#takeWhile" class="link">Source</a> <a href="#v:takeWhile" class="selflink">#</a></p><div class="doc"><p>Alternative version of <code>reverse . takeWhile p . reverse</code>.</p><pre>forAllPredicates $ \p xs -&gt; Rev.takeWhile p xs == reverse (List.takeWhile p (reverse xs))</pre></div></div><div class="top"><p class="src"><a id="v:span" class="def">span</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a]) <a href="src/Data.List.Reverse.StrictElement.html#span" class="link">Source</a> <a href="#v:span" class="selflink">#</a></p><div class="doc"><pre>forAllPredicates $ \p xs -&gt; Rev.span p xs == swap (mapPair (reverse, reverse) (List.span p (reverse xs)))</pre><pre>forAllPredicates $ \p xs -&gt; Rev.span p xs == (Rev.dropWhile p xs, Rev.takeWhile p xs)</pre><pre>\x xs pad -&gt; defined $ Match.take (pad::[()]) $ fst $ Rev.span ((x::Char)/=) $ cycle $ x:xs</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.26.0</p></div></body></html>