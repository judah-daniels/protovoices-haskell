<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Data.List.HT</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">utility-ht-0.0.16: Various small helper functions for Lists, Maybes, Tuples, Functions</span><ul class="links" id="page-menu"><li><a href="src/Data.List.HT.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Data.List.HT</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Improved standard functions</a></li><li><a href="#g:2">Split</a></li><li><a href="#g:3">List processing starting at the end</a></li><li><a href="#g:4">List processing with Maybe and Either</a></li><li><a href="#g:5">Sieve and slice</a></li><li><a href="#g:6">Search&amp;replace</a></li><li><a href="#g:7">Lists of lists</a></li><li><a href="#g:8">Miscellaneous</a></li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:inits">inits</a> :: [a] -&gt; [[a]]</li><li class="src short"><a href="#v:tails">tails</a> :: [a] -&gt; [[a]]</li><li class="src short"><a href="#v:groupBy">groupBy</a> :: (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:group">group</a> :: <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:unzip">unzip</a> :: [(a, b)] -&gt; ([a], [b])</li><li class="src short"><a href="#v:partition">partition</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a])</li><li class="src short"><a href="#v:span">span</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a])</li><li class="src short"><a href="#v:break">break</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a])</li><li class="src short"><a href="#v:chop">chop</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:breakAfter">breakAfter</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a])</li><li class="src short"><a href="#v:takeUntil">takeUntil</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:segmentAfter">segmentAfter</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:segmentBefore">segmentBefore</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:segmentAfterJust">segmentAfterJust</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; ([([a], b)], [a])</li><li class="src short"><a href="#v:segmentAfterMaybe">segmentAfterMaybe</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; ([([a], b)], [a])</li><li class="src short"><a href="#v:segmentBeforeJust">segmentBeforeJust</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; ([a], [(b, [a])])</li><li class="src short"><a href="#v:segmentBeforeMaybe">segmentBeforeMaybe</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; ([a], [(b, [a])])</li><li class="src short"><a href="#v:segmentAfterRight">segmentAfterRight</a> :: [<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b] -&gt; ([([a], b)], [a])</li><li class="src short"><a href="#v:segmentBeforeRight">segmentBeforeRight</a> :: [<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b] -&gt; ([a], [(b, [a])])</li><li class="src short"><a href="#v:removeEach">removeEach</a> :: [a] -&gt; [(a, [a])]</li><li class="src short"><a href="#v:splitEverywhere">splitEverywhere</a> :: [a] -&gt; [([a], a, [a])]</li><li class="src short"><a href="#v:splitLast">splitLast</a> :: [a] -&gt; ([a], a)</li><li class="src short"><a href="#v:viewL">viewL</a> :: [a] -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, [a])</li><li class="src short"><a href="#v:viewR">viewR</a> :: [a] -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> ([a], a)</li><li class="src short"><a href="#v:switchL">switchL</a> :: b -&gt; (a -&gt; [a] -&gt; b) -&gt; [a] -&gt; b</li><li class="src short"><a href="#v:switchR">switchR</a> :: b -&gt; ([a] -&gt; a -&gt; b) -&gt; [a] -&gt; b</li><li class="src short"><a href="#v:dropRev">dropRev</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:takeRev">takeRev</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:splitAtRev">splitAtRev</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; ([a], [a])</li><li class="src short"><a href="#v:dropWhileRev">dropWhileRev</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:takeWhileRev">takeWhileRev</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:maybePrefixOf">maybePrefixOf</a> :: <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> [a]</li><li class="src short"><a href="#v:maybeSuffixOf">maybeSuffixOf</a> :: <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> [a]</li><li class="src short"><a href="#v:partitionMaybe">partitionMaybe</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; ([b], [a])</li><li class="src short"><a href="#v:takeWhileJust">takeWhileJust</a> :: [<a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a] -&gt; [a]</li><li class="src short"><a href="#v:dropWhileNothing">dropWhileNothing</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (b, [a])</li><li class="src short"><a href="#v:breakJust">breakJust</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; ([a], <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (b, [a]))</li><li class="src short"><a href="#v:spanJust">spanJust</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; ([b], [a])</li><li class="src short"><a href="#v:unzipEithers">unzipEithers</a> :: [<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b] -&gt; ([a], [b])</li><li class="src short"><a href="#v:sieve">sieve</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:sliceHorizontal">sliceHorizontal</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:sliceVertical">sliceVertical</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:search">search</a> :: <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; [<a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>]</li><li class="src short"><a href="#v:replace">replace</a> :: <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:multiReplace">multiReplace</a> :: <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [([a], [a])] -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:shear">shear</a> :: [[a]] -&gt; [[a]]</li><li class="src short"><a href="#v:shearTranspose">shearTranspose</a> :: [[a]] -&gt; [[a]]</li><li class="src short"><a href="#v:outerProduct">outerProduct</a> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [[c]]</li><li class="src short"><a href="#v:takeWhileMulti">takeWhileMulti</a> :: [a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>] -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:rotate">rotate</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:mergeBy">mergeBy</a> :: (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:allEqual">allEqual</a> :: <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:isAscending">isAscending</a> :: <a href="../base-4.16.4.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; [a] -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:isAscendingLazy">isAscendingLazy</a> :: <a href="../base-4.16.4.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; [a] -&gt; [<a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>]</li><li class="src short"><a href="#v:mapAdjacent">mapAdjacent</a> :: (a -&gt; a -&gt; b) -&gt; [a] -&gt; [b]</li><li class="src short"><a href="#v:mapAdjacent1">mapAdjacent1</a> :: (a -&gt; a -&gt; b -&gt; c) -&gt; a -&gt; [(a, b)] -&gt; [c]</li><li class="src short"><a href="#v:range">range</a> :: <a href="../base-4.16.4.0/Prelude.html#t:Num" title="Prelude">Num</a> a =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a]</li><li class="src short"><a href="#v:padLeft">padLeft</a> :: a -&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:padRight">padRight</a> :: a -&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:iterateAssociative">iterateAssociative</a> :: (a -&gt; a -&gt; a) -&gt; a -&gt; [a]</li><li class="src short"><a href="#v:iterateLeaky">iterateLeaky</a> :: (a -&gt; a -&gt; a) -&gt; a -&gt; [a]</li><li class="src short"><a href="#v:lengthAtLeast">lengthAtLeast</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:lengthAtMost">lengthAtMost</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Improved standard functions</h1></a><div class="top"><p class="src"><a id="v:inits" class="def">inits</a> :: [a] -&gt; [[a]] <a href="src/Data.List.HT.Private.html#inits" class="link">Source</a> <a href="#v:inits" class="selflink">#</a></p><div class="doc"><p>This function is lazier than the one suggested in the Haskell 98 report.
It is <code>inits undefined = [] : undefined</code>,
in contrast to <code>Data.List.inits undefined = undefined</code>.</p></div></div><div class="top"><p class="src"><a id="v:tails" class="def">tails</a> :: [a] -&gt; [[a]] <a href="src/Data.List.HT.Private.html#tails" class="link">Source</a> <a href="#v:tails" class="selflink">#</a></p><div class="doc"><p>This function is lazier than the one suggested in the Haskell 98 report.
It is <code>tails undefined = ([] : undefined) : undefined</code>,
in contrast to <code>Data.List.tails undefined = undefined</code>.</p></div></div><div class="top"><p class="src"><a id="v:groupBy" class="def">groupBy</a> :: (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [[a]] <a href="src/Data.List.HT.Private.html#groupBy" class="link">Source</a> <a href="#v:groupBy" class="selflink">#</a></p><div class="doc"><p>This function compares adjacent elements of a list.
If two adjacent elements satisfy a relation then they are put into the same sublist.
Example:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>groupBy (&lt;) &quot;abcdebcdef&quot;
</code></strong>[&quot;abcde&quot;,&quot;bcdef&quot;]
</pre><p>In contrast to that <code><a href="../base-4.16.4.0/Data-List.html#v:groupBy" title="Data.List">groupBy</a></code> compares
the head of each sublist with each candidate for this sublist.
This yields</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>List.groupBy (&lt;) &quot;abcdebcdef&quot;
</code></strong>[&quot;abcdebcdef&quot;]
</pre><p>The second <code><code>b</code></code> is compared with the leading <code><code>a</code></code>.
Thus it is put into the same sublist as <code><code>a</code></code>.</p><p>The sublists are never empty.
Thus the more precise result type would be <code>[(a,[a])]</code>.</p></div></div><div class="top"><p class="src"><a id="v:group" class="def">group</a> :: <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [[a]] <a href="src/Data.List.HT.Private.html#group" class="link">Source</a> <a href="#v:group" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:unzip" class="def">unzip</a> :: [(a, b)] -&gt; ([a], [b]) <a href="src/Data.List.HT.Private.html#unzip" class="link">Source</a> <a href="#v:unzip" class="selflink">#</a></p><div class="doc"><p>Like standard <code><a href="Data-List-HT.html#v:unzip" title="Data.List.HT">unzip</a></code> but more lazy.
It is <code>Data.List.unzip undefined == undefined</code>,
but <code>unzip undefined == (undefined, undefined)</code>.</p></div></div><div class="top"><p class="src"><a id="v:partition" class="def">partition</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a]) <a href="src/Data.List.HT.Private.html#partition" class="link">Source</a> <a href="#v:partition" class="selflink">#</a></p><div class="doc"><p><code><a href="../base-4.16.4.0/Data-List.html#v:partition" title="Data.List">partition</a></code> of GHC 6.2.1 fails on infinite lists.
But this one does not.</p></div></div><div class="top"><p class="src"><a id="v:span" class="def">span</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a]) <a href="src/Data.List.HT.Private.html#span" class="link">Source</a> <a href="#v:span" class="selflink">#</a></p><div class="doc"><p>It is <code>Data.List.span f undefined = undefined</code>,
whereas <code>span f undefined = (undefined, undefined)</code>.</p></div></div><div class="top"><p class="src"><a id="v:break" class="def">break</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a]) <a href="src/Data.List.HT.Private.html#break" class="link">Source</a> <a href="#v:break" class="selflink">#</a></p><div class="doc"><p>It is <code>Data.List.span f undefined = undefined</code>,
whereas <code>span f undefined = (undefined, undefined)</code>.</p></div></div><a href="#g:2" id="g:2"><h1>Split</h1></a><div class="top"><p class="src"><a id="v:chop" class="def">chop</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [[a]] <a href="src/Data.List.HT.Private.html#chop" class="link">Source</a> <a href="#v:chop" class="selflink">#</a></p><div class="doc"><p>Split the list at the occurrences of a separator into sub-lists.
Remove the separators.
This is somehow a generalization of <code><a href="../base-4.16.4.0/Data-String.html#v:lines" title="Data.String">lines</a></code> and <code><a href="../base-4.16.4.0/Data-String.html#v:words" title="Data.String">words</a></code>.
But note the differences:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>words &quot;a  a&quot;
</code></strong>[&quot;a&quot;,&quot;a&quot;]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>chop (' '==) &quot;a  a&quot;
</code></strong>[&quot;a&quot;,&quot;&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>lines &quot;a\n\na&quot;
</code></strong>[&quot;a&quot;,&quot;&quot;,&quot;a&quot;]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>chop ('\n'==) &quot;a\n\na&quot;
</code></strong>[&quot;a&quot;,&quot;&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>lines &quot;a\n&quot;
</code></strong>[&quot;a&quot;]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>chop ('\n'==) &quot;a\n&quot;
</code></strong>[&quot;a&quot;,&quot;&quot;]
</pre></div></div><div class="top"><p class="src"><a id="v:breakAfter" class="def">breakAfter</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a]) <a href="src/Data.List.HT.Private.html#breakAfter" class="link">Source</a> <a href="#v:breakAfter" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Data-List-HT.html#v:break" title="Data.List.HT">break</a></code>, but splits after the matching element.</p><pre>forAllPredicates $ \p xs -&gt; uncurry (++) (breakAfter p xs) == xs</pre></div></div><div class="top"><p class="src"><a id="v:takeUntil" class="def">takeUntil</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] <a href="src/Data.List.HT.Private.html#takeUntil" class="link">Source</a> <a href="#v:takeUntil" class="selflink">#</a></p><div class="doc"><p>Take all elements until one matches.
The matching element is returned, too.
This is the key difference to <code>takeWhile (not . p)</code>.
It holds:</p><pre>forAllPredicates $ \p xs -&gt; takeUntil p xs == fst (breakAfter p xs)</pre></div></div><div class="top"><p class="src"><a id="v:segmentAfter" class="def">segmentAfter</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [[a]] <a href="src/Data.List.HT.Private.html#segmentAfter" class="link">Source</a> <a href="#v:segmentAfter" class="selflink">#</a></p><div class="doc"><p>Split the list after each occurence of a terminator.
Keep the terminator.
There is always a list for the part after the last terminator.
It may be empty.
See package <code>non-empty</code> for more precise result type.</p><pre>forAllPredicates $ \p xs -&gt; concat (segmentAfter p xs) == xs</pre><pre>forAllPredicates $ \p xs -&gt; length (filter p xs) == length (tail (segmentAfter p xs))</pre><pre>forAllPredicates $ \p -&gt; all (p . last) . init . segmentAfter p</pre><pre>forAllPredicates $ \p -&gt; all (all (not . p) . init) . init . segmentAfter p</pre><p>This test captures both infinitely many groups and infinitely big groups:</p><pre>forAllPredicates $ \p x -&gt; flip seq True . (!!100) . concat . segmentAfter p . cycle . (x:)</pre></div></div><div class="top"><p class="src"><a id="v:segmentBefore" class="def">segmentBefore</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [[a]] <a href="src/Data.List.HT.Private.html#segmentBefore" class="link">Source</a> <a href="#v:segmentBefore" class="selflink">#</a></p><div class="doc"><p>Split the list before each occurence of a leading character.
Keep these characters.
There is always a list for the part before the first leading character.
It may be empty.
See package <code>non-empty</code> for more precise result type.</p><pre>forAllPredicates $ \p xs -&gt; concat (segmentBefore p xs) == xs</pre><pre>forAllPredicates $ \p xs -&gt; length (filter p xs) == length (tail (segmentBefore p xs))</pre><pre>forAllPredicates $ \p -&gt; all (p . head) . tail . segmentBefore p</pre><pre>forAllPredicates $ \p -&gt; all (all (not . p) . tail) . tail . segmentBefore p</pre><pre>forAllPredicates $ \p x -&gt; flip seq True . (!!100) . concat . segmentBefore p . cycle . (x:)</pre></div></div><div class="top"><p class="src"><a id="v:segmentAfterJust" class="def">segmentAfterJust</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; ([([a], b)], [a]) <a href="src/Data.List.HT.Private.html#segmentAfterJust" class="link">Source</a> <a href="#v:segmentAfterJust" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>segmentAfterJust (\c -&gt; toMaybe (isLetter c) (toUpper c)) &quot;123a5345b---&quot;
</code></strong>([(&quot;123&quot;,'A'),(&quot;5345&quot;,'B')],&quot;---&quot;)
</pre></div></div><div class="top"><p class="src"><a id="v:segmentAfterMaybe" class="def">segmentAfterMaybe</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; ([([a], b)], [a]) <a href="src/Data.List.HT.html#segmentAfterMaybe" class="link">Source</a> <a href="#v:segmentAfterMaybe" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: use segmentAfterJust instead</p></div></div></div><div class="top"><p class="src"><a id="v:segmentBeforeJust" class="def">segmentBeforeJust</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; ([a], [(b, [a])]) <a href="src/Data.List.HT.Private.html#segmentBeforeJust" class="link">Source</a> <a href="#v:segmentBeforeJust" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>segmentBeforeJust (\c -&gt; toMaybe (isLetter c) (toUpper c)) &quot;123a5345b---&quot;
</code></strong>(&quot;123&quot;,[('A',&quot;5345&quot;),('B',&quot;---&quot;)])
</pre></div></div><div class="top"><p class="src"><a id="v:segmentBeforeMaybe" class="def">segmentBeforeMaybe</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; ([a], [(b, [a])]) <a href="src/Data.List.HT.html#segmentBeforeMaybe" class="link">Source</a> <a href="#v:segmentBeforeMaybe" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: use segmentBeforeJust instead</p></div></div></div><div class="top"><p class="src"><a id="v:segmentAfterRight" class="def">segmentAfterRight</a> :: [<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b] -&gt; ([([a], b)], [a]) <a href="src/Data.List.HT.Private.html#segmentAfterRight" class="link">Source</a> <a href="#v:segmentAfterRight" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>segmentAfterRight [Left 'a', Right LT, Right GT, Left 'b']
</code></strong>([(&quot;a&quot;,LT),(&quot;&quot;,GT)],&quot;b&quot;)
</pre><pre>forAllMaybeFn $ \f xs -&gt; segmentAfterJust f xs == segmentAfterRight (map (\x -&gt; maybe (Left x) Right (f x)) xs)</pre></div></div><div class="top"><p class="src"><a id="v:segmentBeforeRight" class="def">segmentBeforeRight</a> :: [<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b] -&gt; ([a], [(b, [a])]) <a href="src/Data.List.HT.Private.html#segmentBeforeRight" class="link">Source</a> <a href="#v:segmentBeforeRight" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>segmentBeforeRight [Left 'a', Right LT, Right GT, Left 'b']
</code></strong>(&quot;a&quot;,[(LT,&quot;&quot;),(GT,&quot;b&quot;)])
</pre><pre>forAllMaybeFn $ \f xs -&gt; segmentBeforeJust f xs == segmentBeforeRight (map (\x -&gt; maybe (Left x) Right (f x)) xs)</pre></div></div><div class="top"><p class="src"><a id="v:removeEach" class="def">removeEach</a> :: [a] -&gt; [(a, [a])] <a href="src/Data.List.HT.Private.html#removeEach" class="link">Source</a> <a href="#v:removeEach" class="selflink">#</a></p><div class="doc"><p><code>removeEach xs</code> represents a list of sublists of <code>xs</code>,
where each element of <code>xs</code> is removed and
the removed element is separated.
It seems to be much simpler to achieve with
<code>zip xs (map (flip List.delete xs) xs)</code>,
but the implementation of <code><a href="Data-List-HT.html#v:removeEach" title="Data.List.HT">removeEach</a></code> does not need the <code><a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a></code> instance
and thus can also be used for lists of functions.</p><p>See also the proposal
 <a href="http://www.haskell.org/pipermail/libraries/2008-February/009270.html">http://www.haskell.org/pipermail/libraries/2008-February/009270.html</a></p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>removeEach &quot;abc&quot;
</code></strong>[('a',&quot;bc&quot;),('b',&quot;ac&quot;),('c',&quot;ab&quot;)]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>removeEach &quot;a&quot;
</code></strong>[('a',&quot;&quot;)]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>removeEach &quot;&quot;
</code></strong>[]
</pre></div></div><div class="top"><p class="src"><a id="v:splitEverywhere" class="def">splitEverywhere</a> :: [a] -&gt; [([a], a, [a])] <a href="src/Data.List.HT.Private.html#splitEverywhere" class="link">Source</a> <a href="#v:splitEverywhere" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitEverywhere &quot;abc&quot;
</code></strong>[(&quot;&quot;,'a',&quot;bc&quot;),(&quot;a&quot;,'b',&quot;c&quot;),(&quot;ab&quot;,'c',&quot;&quot;)]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitEverywhere &quot;a&quot;
</code></strong>[(&quot;&quot;,'a',&quot;&quot;)]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitEverywhere &quot;&quot;
</code></strong>[]
</pre></div></div><div class="top"><p class="src"><a id="v:splitLast" class="def">splitLast</a> :: [a] -&gt; ([a], a) <a href="src/Data.List.HT.Private.html#splitLast" class="link">Source</a> <a href="#v:splitLast" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: use viewR instead</p></div><p>It holds <code>splitLast xs == (init xs, last xs)</code>,
but <code><a href="Data-List-HT.html#v:splitLast" title="Data.List.HT">splitLast</a></code> is more efficient
if the last element is accessed after the initial ones,
because it avoids memoizing list.</p><pre>\(NonEmpty xs) -&gt; splitLast (xs::String)  ==  (init xs, last xs)</pre></div></div><div class="top"><p class="src"><a id="v:viewL" class="def">viewL</a> :: [a] -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, [a]) <a href="src/Data.List.HT.Private.html#viewL" class="link">Source</a> <a href="#v:viewL" class="selflink">#</a></p><div class="doc"><p>Should be prefered to <code><a href="../base-4.16.4.0/GHC-List.html#v:head" title="GHC.List">head</a></code> and <code><a href="../base-4.16.4.0/GHC-List.html#v:tail" title="GHC.List">tail</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:viewR" class="def">viewR</a> :: [a] -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> ([a], a) <a href="src/Data.List.HT.Private.html#viewR" class="link">Source</a> <a href="#v:viewR" class="selflink">#</a></p><div class="doc"><p>Should be prefered to <code><a href="../base-4.16.4.0/GHC-List.html#v:init" title="GHC.List">init</a></code> and <code><a href="../base-4.16.4.0/GHC-List.html#v:last" title="GHC.List">last</a></code>.</p><pre>\xs -&gt; maybe True ((init xs, last xs) == ) (viewR (xs::String))</pre></div></div><div class="top"><p class="src"><a id="v:switchL" class="def">switchL</a> :: b -&gt; (a -&gt; [a] -&gt; b) -&gt; [a] -&gt; b <a href="src/Data.List.HT.Private.html#switchL" class="link">Source</a> <a href="#v:switchL" class="selflink">#</a></p><div class="doc"><p>Should be prefered to <code><a href="../base-4.16.4.0/GHC-List.html#v:head" title="GHC.List">head</a></code> and <code><a href="../base-4.16.4.0/GHC-List.html#v:tail" title="GHC.List">tail</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:switchR" class="def">switchR</a> :: b -&gt; ([a] -&gt; a -&gt; b) -&gt; [a] -&gt; b <a href="src/Data.List.HT.Private.html#switchR" class="link">Source</a> <a href="#v:switchR" class="selflink">#</a></p><div class="doc"><p>Should be prefered to <code><a href="../base-4.16.4.0/GHC-List.html#v:init" title="GHC.List">init</a></code> and <code><a href="../base-4.16.4.0/GHC-List.html#v:last" title="GHC.List">last</a></code>.</p><pre>\xs -&gt; switchR True (\ixs lxs -&gt; ixs == init xs &amp;&amp; lxs == last xs) (xs::String)</pre></div></div><a href="#g:3" id="g:3"><h1>List processing starting at the end</h1></a><div class="top"><p class="src"><a id="v:dropRev" class="def">dropRev</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [a] <a href="src/Data.List.HT.Private.html#dropRev" class="link">Source</a> <a href="#v:dropRev" class="selflink">#</a></p><div class="doc"><p><code>dropRev n</code> is like <code>reverse . drop n . reverse</code>
but it is lazy enough to work for infinite lists, too.</p><pre>\n xs -&gt; dropRev n (xs::String) == reverse (drop n (reverse xs))</pre></div></div><div class="top"><p class="src"><a id="v:takeRev" class="def">takeRev</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [a] <a href="src/Data.List.HT.Private.html#takeRev" class="link">Source</a> <a href="#v:takeRev" class="selflink">#</a></p><div class="doc"><p><code>takeRev n</code> is like <code>reverse . take n . reverse</code>
but it is lazy enough to work for infinite lists, too.</p><pre>\n xs -&gt; takeRev n (xs::String) == reverse (take n (reverse xs))</pre></div></div><div class="top"><p class="src"><a id="v:splitAtRev" class="def">splitAtRev</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; ([a], [a]) <a href="src/Data.List.HT.Private.html#splitAtRev" class="link">Source</a> <a href="#v:splitAtRev" class="selflink">#</a></p><div class="doc"><p><code>splitAtRev n xs == (dropRev n xs, takeRev n xs)</code>.</p><pre>\n xs -&gt; splitAtRev n (xs::String) == (dropRev n xs, takeRev n xs)</pre><pre>\n xs -&gt; (xs::String) == uncurry (++) (splitAtRev n xs)</pre></div></div><div class="top"><p class="src"><a id="v:dropWhileRev" class="def">dropWhileRev</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] <a href="src/Data.List.HT.html#dropWhileRev" class="link">Source</a> <a href="#v:dropWhileRev" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Use dropWhile from Data.List.Reverse.StrictElement or Data.List.Reverse.StrictSpine instead</p></div></div></div><div class="top"><p class="src"><a id="v:takeWhileRev" class="def">takeWhileRev</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] <a href="src/Data.List.HT.html#takeWhileRev" class="link">Source</a> <a href="#v:takeWhileRev" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Use takeWhile from Data.List.Reverse.StrictElement or Data.List.Reverse.StrictSpine instead</p></div></div></div><a href="#g:4" id="g:4"><h1>List processing with Maybe and Either</h1></a><div class="top"><p class="src"><a id="v:maybePrefixOf" class="def">maybePrefixOf</a> :: <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> [a] <a href="src/Data.List.HT.Private.html#maybePrefixOf" class="link">Source</a> <a href="#v:maybePrefixOf" class="selflink">#</a></p><div class="doc"><p><code>maybePrefixOf xs ys</code> is <code>Just zs</code> if <code>xs</code> is a prefix of <code>ys</code>,
where <code>zs</code> is <code>ys</code> without the prefix <code>xs</code>.
Otherwise it is <code>Nothing</code>.
It is the same as <code><a href="../base-4.16.4.0/Data-List.html#v:stripPrefix" title="Data.List">stripPrefix</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>maybePrefixOf &quot;abc&quot; &quot;abcdef&quot;
</code></strong>Just &quot;def&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>maybePrefixOf &quot;def&quot; &quot;abcdef&quot;
</code></strong>Nothing
</pre></div></div><div class="top"><p class="src"><a id="v:maybeSuffixOf" class="def">maybeSuffixOf</a> :: <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> [a] <a href="src/Data.List.HT.Private.html#maybeSuffixOf" class="link">Source</a> <a href="#v:maybeSuffixOf" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>maybeSuffixOf &quot;abc&quot; &quot;abcdef&quot;
</code></strong>Nothing
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>maybeSuffixOf &quot;def&quot; &quot;abcdef&quot;
</code></strong>Just &quot;abc&quot;
</pre></div></div><div class="top"><p class="src"><a id="v:partitionMaybe" class="def">partitionMaybe</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; ([b], [a]) <a href="src/Data.List.HT.Private.html#partitionMaybe" class="link">Source</a> <a href="#v:partitionMaybe" class="selflink">#</a></p><div class="doc"><p>Partition a list into elements which evaluate to <code>Just</code> or <code>Nothing</code> by <code>f</code>.</p><pre>forAllMaybeFn $ \f xs -&gt; partitionMaybe f xs == (mapMaybe f xs, filter (isNothing . f) xs)</pre><pre>forAllPredicates $ \p xs -&gt; partition p xs == partitionMaybe (\x -&gt; toMaybe (p x) x) xs</pre></div></div><div class="top"><p class="src"><a id="v:takeWhileJust" class="def">takeWhileJust</a> :: [<a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a] -&gt; [a] <a href="src/Data.List.HT.Private.html#takeWhileJust" class="link">Source</a> <a href="#v:takeWhileJust" class="selflink">#</a></p><div class="doc"><p>This is the cousin of <code><a href="../base-4.16.4.0/GHC-List.html#v:takeWhile" title="GHC.List">takeWhile</a></code>
analogously to <code><a href="../base-4.16.4.0/Data-Maybe.html#v:catMaybes" title="Data.Maybe">catMaybes</a></code> being the cousin of <code><a href="../base-4.16.4.0/GHC-List.html#v:filter" title="GHC.List">filter</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>takeWhileJust [Just 'a', Just 'b', Nothing, Just 'c']
</code></strong>&quot;ab&quot;
</pre><p>Example: Keep the heads of sublists until an empty list occurs.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>takeWhileJust $ map (fmap fst . viewL) [&quot;abc&quot;,&quot;def&quot;,&quot;&quot;,&quot;xyz&quot;]
</code></strong>&quot;ad&quot;
</pre><p>For consistency with <code><a href="../base-4.16.4.0/GHC-List.html#v:takeWhile" title="GHC.List">takeWhile</a></code>,
<code><a href="Data-List-HT.html#v:partitionMaybe" title="Data.List.HT">partitionMaybe</a></code> and <code><a href="Data-List-HT.html#v:dropWhileNothing" title="Data.List.HT">dropWhileNothing</a></code> it should have been:</p><pre>takeWhileJust_ :: (a -&gt; Maybe b) -&gt; a -&gt; [b]</pre><p>However, both variants are interchangeable:</p><pre>takeWhileJust_ f == takeWhileJust . map f
takeWhileJust == takeWhileJust_ id</pre></div></div><div class="top"><p class="src"><a id="v:dropWhileNothing" class="def">dropWhileNothing</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (b, [a]) <a href="src/Data.List.HT.Private.html#dropWhileNothing" class="link">Source</a> <a href="#v:dropWhileNothing" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:breakJust" class="def">breakJust</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; ([a], <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (b, [a])) <a href="src/Data.List.HT.Private.html#breakJust" class="link">Source</a> <a href="#v:breakJust" class="selflink">#</a></p><div class="doc"><pre>forAllMaybeFn $ \f xs -&gt; snd (breakJust f xs) == dropWhileNothing f xs</pre></div></div><div class="top"><p class="src"><a id="v:spanJust" class="def">spanJust</a> :: (a -&gt; <a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; [a] -&gt; ([b], [a]) <a href="src/Data.List.HT.Private.html#spanJust" class="link">Source</a> <a href="#v:spanJust" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:unzipEithers" class="def">unzipEithers</a> :: [<a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> a b] -&gt; ([a], [b]) <a href="src/Data.List.HT.Private.html#unzipEithers" class="link">Source</a> <a href="#v:unzipEithers" class="selflink">#</a></p></div><a href="#g:5" id="g:5"><h1>Sieve and slice</h1></a><div class="top"><p class="src"><a id="v:sieve" class="def">sieve</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [a] <a href="src/Data.List.HT.Private.html#sieve" class="link">Source</a> <a href="#v:sieve" class="selflink">#</a></p><div class="doc"><p>keep every k-th value from the list</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sieve 6 ['a'..'z']
</code></strong>&quot;agmsy&quot;
</pre></div></div><div class="top"><p class="src"><a id="v:sliceHorizontal" class="def">sliceHorizontal</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [[a]] <a href="src/Data.List.HT.Private.html#sliceHorizontal" class="link">Source</a> <a href="#v:sliceHorizontal" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sliceHorizontal 6 ['a'..'z']
</code></strong>[&quot;agmsy&quot;,&quot;bhntz&quot;,&quot;ciou&quot;,&quot;djpv&quot;,&quot;ekqw&quot;,&quot;flrx&quot;]
</pre><pre>\(NonEmpty xs) -&gt; QC.forAll (QC.choose (1, length xs)) $ \n -&gt; sliceHorizontal n xs == transpose (sliceVertical n (xs::String))</pre><pre>\(NonEmpty xs) -&gt; QC.forAll (QC.choose (1, length xs)) $ \n -&gt; sliceVertical  n xs == transpose (sliceHorizontal n (xs::String))</pre><p>The properties do not hold for empty lists because of:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sliceHorizontal 4 ([]::[Int])
</code></strong>[[],[],[],[]]
</pre></div></div><div class="top"><p class="src"><a id="v:sliceVertical" class="def">sliceVertical</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [[a]] <a href="src/Data.List.HT.Private.html#sliceVertical" class="link">Source</a> <a href="#v:sliceVertical" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sliceVertical 6 ['a'..'z']
</code></strong>[&quot;abcdef&quot;,&quot;ghijkl&quot;,&quot;mnopqr&quot;,&quot;stuvwx&quot;,&quot;yz&quot;]
</pre></div></div><a href="#g:6" id="g:6"><h1>Search&amp;replace</h1></a><div class="top"><p class="src"><a id="v:search" class="def">search</a> :: <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; [<a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] <a href="src/Data.List.HT.Private.html#search" class="link">Source</a> <a href="#v:search" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:replace" class="def">replace</a> :: <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; [a] -&gt; [a] -&gt; [a] <a href="src/Data.List.HT.Private.html#replace" class="link">Source</a> <a href="#v:replace" class="selflink">#</a></p><div class="doc"><pre>\(NonEmpty xs) ys -&gt; replace xs xs ys == (ys::String)</pre><pre>\(NonEmpty xs) (NonEmpty ys) -&gt; equating (take 1000) (replace xs ys (cycle xs)) (cycle (ys::String))</pre></div></div><div class="top"><p class="src"><a id="v:multiReplace" class="def">multiReplace</a> :: <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [([a], [a])] -&gt; [a] -&gt; [a] <a href="src/Data.List.HT.Private.html#multiReplace" class="link">Source</a> <a href="#v:multiReplace" class="selflink">#</a></p><div class="doc"><p>prop src dst xs -&gt; replace src dst xs == multiReplace <a href="xs::String">(src,dst)</a></p></div></div><a href="#g:7" id="g:7"><h1>Lists of lists</h1></a><div class="top"><p class="src"><a id="v:shear" class="def">shear</a> :: [[a]] -&gt; [[a]] <a href="src/Data.List.HT.Private.html#shear" class="link">Source</a> <a href="#v:shear" class="selflink">#</a></p><div class="doc"><p>Transform</p><pre>[[00,01,02,...],          [[00],
 [10,11,12,...],   --&gt;     [10,01],
 [20,21,22,...],           [20,11,02],
 ...]                      ...]</pre><p>With <code>concat . shear</code> you can perform a Cantor diagonalization,
that is an enumeration of all elements of the sub-lists
where each element is reachable within a finite number of steps.
It is also useful for polynomial multiplication (convolution).</p></div></div><div class="top"><p class="src"><a id="v:shearTranspose" class="def">shearTranspose</a> :: [[a]] -&gt; [[a]] <a href="src/Data.List.HT.Private.html#shearTranspose" class="link">Source</a> <a href="#v:shearTranspose" class="selflink">#</a></p><div class="doc"><p>Transform</p><pre>[[00,01,02,...],          [[00],
 [10,11,12,...],   --&gt;     [01,10],
 [20,21,22,...],           [02,11,20],
 ...]                      ...]</pre><p>It's like <code><a href="Data-List-HT.html#v:shear" title="Data.List.HT">shear</a></code> but the order of elements in the sub list is reversed.
Its implementation seems to be more efficient than that of <code><a href="Data-List-HT.html#v:shear" title="Data.List.HT">shear</a></code>.
If the order does not matter, better choose <code><a href="Data-List-HT.html#v:shearTranspose" title="Data.List.HT">shearTranspose</a></code>.</p><pre>\xs -&gt; shearTranspose xs  ==  map reverse (shear (xs::[String]))</pre></div></div><div class="top"><p class="src"><a id="v:outerProduct" class="def">outerProduct</a> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [[c]] <a href="src/Data.List.HT.Private.html#outerProduct" class="link">Source</a> <a href="#v:outerProduct" class="selflink">#</a></p><div class="doc"><p>Operate on each combination of elements of the first and the second list.
In contrast to the list instance of <code><a href="Monad.html#v:liftM2" title="Monad">liftM2</a></code>
it holds the results in a list of lists.</p><pre>\xs ys -&gt; let f x y = (x::Char,y::Int) in concat (outerProduct f xs ys)  ==  liftM2 f xs ys</pre></div></div><a href="#g:8" id="g:8"><h1>Miscellaneous</h1></a><div class="top"><p class="src"><a id="v:takeWhileMulti" class="def">takeWhileMulti</a> :: [a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>] -&gt; [a] -&gt; [a] <a href="src/Data.List.HT.Private.html#takeWhileMulti" class="link">Source</a> <a href="#v:takeWhileMulti" class="selflink">#</a></p><div class="doc"><p>Take while first predicate holds,
then continue taking while second predicate holds,
and so on.</p></div></div><div class="top"><p class="src"><a id="v:rotate" class="def">rotate</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [a] <a href="src/Data.List.HT.Private.html#rotate" class="link">Source</a> <a href="#v:rotate" class="selflink">#</a></p><div class="doc"><p>rotate left </p></div></div><div class="top"><p class="src"><a id="v:mergeBy" class="def">mergeBy</a> :: (a -&gt; a -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] -&gt; [a] <a href="src/Data.List.HT.Private.html#mergeBy" class="link">Source</a> <a href="#v:mergeBy" class="selflink">#</a></p><div class="doc"><p>Given two lists that are ordered
(i.e. <code>p x y</code> holds for subsequent <code>x</code> and <code>y</code>)
<code><a href="Data-List-HT.html#v:mergeBy" title="Data.List.HT">mergeBy</a></code> them into a list that is ordered, again.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>mergeBy (&lt;=) &quot;agh&quot; &quot;begz&quot;
</code></strong>&quot;abegghz&quot;
</pre></div></div><div class="top"><p class="src"><a id="v:allEqual" class="def">allEqual</a> :: <a href="../base-4.16.4.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; [a] -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Data.List.HT.Private.html#allEqual" class="link">Source</a> <a href="#v:allEqual" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>allEqual &quot;aab&quot;
</code></strong>False
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>allEqual &quot;aaa&quot;
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>allEqual &quot;aa&quot;
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>allEqual &quot;a&quot;
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>allEqual &quot;&quot;
</code></strong>True
</pre></div></div><div class="top"><p class="src"><a id="v:isAscending" class="def">isAscending</a> :: <a href="../base-4.16.4.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; [a] -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Data.List.HT.Private.html#isAscending" class="link">Source</a> <a href="#v:isAscending" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>isAscending &quot;abc&quot;
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>isAscending &quot;abb&quot;
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>isAscending &quot;aba&quot;
</code></strong>False
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>isAscending &quot;cba&quot;
</code></strong>False
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>isAscending &quot;a&quot;
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>isAscending &quot;&quot;
</code></strong>True
</pre></div></div><div class="top"><p class="src"><a id="v:isAscendingLazy" class="def">isAscendingLazy</a> :: <a href="../base-4.16.4.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; [a] -&gt; [<a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>] <a href="src/Data.List.HT.Private.html#isAscendingLazy" class="link">Source</a> <a href="#v:isAscendingLazy" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:mapAdjacent" class="def">mapAdjacent</a> :: (a -&gt; a -&gt; b) -&gt; [a] -&gt; [b] <a href="src/Data.List.HT.Private.html#mapAdjacent" class="link">Source</a> <a href="#v:mapAdjacent" class="selflink">#</a></p><div class="doc"><p>This function combines every pair of neighbour elements
in a list with a certain function.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>mapAdjacent (&lt;=) &quot;&quot;
</code></strong>[]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>mapAdjacent (&lt;=) &quot;a&quot;
</code></strong>[]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>mapAdjacent (&lt;=) &quot;aba&quot;
</code></strong>[True,False]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>mapAdjacent (,) &quot;abc&quot;
</code></strong>[('a','b'),('b','c')]
</pre><pre>\x xs -&gt; mapAdjacent subtract (scanl (+) x xs) == (xs::[Integer])</pre></div></div><div class="top"><p class="src"><a id="v:mapAdjacent1" class="def">mapAdjacent1</a> :: (a -&gt; a -&gt; b -&gt; c) -&gt; a -&gt; [(a, b)] -&gt; [c] <a href="src/Data.List.HT.Private.html#mapAdjacent1" class="link">Source</a> <a href="#v:mapAdjacent1" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let f x y z = [x,y]++show(z::Int) in mapAdjacent1 f 'a' [('b',1), ('c',2), ('d',3)]
</code></strong>[&quot;ab1&quot;,&quot;bc2&quot;,&quot;cd3&quot;]
</pre></div></div><div class="top"><p class="src"><a id="v:range" class="def">range</a> :: <a href="../base-4.16.4.0/Prelude.html#t:Num" title="Prelude">Num</a> a =&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] <a href="src/Data.List.HT.Private.html#range" class="link">Source</a> <a href="#v:range" class="selflink">#</a></p><div class="doc"><p>Enumerate without Enum context.
For Enum equivalent to enumFrom.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>range 0 :: [Integer]
</code></strong>[]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>range 1 :: [Integer]
</code></strong>[0]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>range 8 :: [Integer]
</code></strong>[0,1,2,3,4,5,6,7]
</pre><pre>\(NonNegative n) -&gt; length (range n :: [Integer]) == n</pre></div></div><div class="top"><p class="src"><a id="v:padLeft" class="def">padLeft</a> :: a -&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [a] <a href="src/Data.List.HT.Private.html#padLeft" class="link">Source</a> <a href="#v:padLeft" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:padRight" class="def">padRight</a> :: a -&gt; <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [a] <a href="src/Data.List.HT.Private.html#padRight" class="link">Source</a> <a href="#v:padRight" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:iterateAssociative" class="def">iterateAssociative</a> :: (a -&gt; a -&gt; a) -&gt; a -&gt; [a] <a href="src/Data.List.HT.Private.html#iterateAssociative" class="link">Source</a> <a href="#v:iterateAssociative" class="selflink">#</a></p><div class="doc"><p>For an associative operation <code>op</code> this computes
   <code>iterateAssociative op a = iterate (op a) a</code>
but it is even faster than <code>map (powerAssociative op a a) [0..]</code>
since it shares temporary results.</p><p>The idea is:
From the list <code>map (powerAssociative op a a) [0,(2*n)..]</code>
we compute the list <code>map (powerAssociative op a a) [0,n..]</code>,
and iterate that until <code>n==1</code>.</p><pre>\x -&gt; equating (take 1000) (List.iterate (x+) x) (iterateAssociative (+) (x::Integer))</pre></div></div><div class="top"><p class="src"><a id="v:iterateLeaky" class="def">iterateLeaky</a> :: (a -&gt; a -&gt; a) -&gt; a -&gt; [a] <a href="src/Data.List.HT.Private.html#iterateLeaky" class="link">Source</a> <a href="#v:iterateLeaky" class="selflink">#</a></p><div class="doc"><p>This is equal to <code><a href="Data-List-HT.html#v:iterateAssociative" title="Data.List.HT">iterateAssociative</a></code>.
The idea is the following:
The list we search is the fixpoint of the function:
&quot;Square all elements of the list,
then spread it and fill the holes with successive numbers
of their left neighbour.&quot;
This also preserves log n applications per value.
However it has a space leak,
because for the value with index <code>n</code>
all elements starting at <code>div n 2</code> must be kept.</p><pre>\x -&gt; equating (take 1000) (List.iterate (x+) x) (iterateLeaky (+) (x::Integer))</pre></div></div><div class="top"><p class="src"><a id="v:lengthAtLeast" class="def">lengthAtLeast</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Data.List.HT.Private.html#lengthAtLeast" class="link">Source</a> <a href="#v:lengthAtLeast" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>lengthAtLeast 0 &quot;&quot;
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>lengthAtLeast 3 &quot;ab&quot;
</code></strong>False
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>lengthAtLeast 3 &quot;abc&quot;
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>lengthAtLeast 3 $ repeat 'a'
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>lengthAtLeast 3 $ &quot;abc&quot; ++ undefined
</code></strong>True
</pre><pre>\n xs -&gt; lengthAtLeast n (xs::String)  ==  (length xs &gt;= n)</pre></div></div><div class="top"><p class="src"><a id="v:lengthAtMost" class="def">lengthAtMost</a> :: <a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; <a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Data.List.HT.Private.html#lengthAtMost" class="link">Source</a> <a href="#v:lengthAtMost" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>lengthAtMost 0 &quot;&quot;
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>lengthAtMost 3 &quot;ab&quot;
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>lengthAtMost 3 &quot;abc&quot;
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>lengthAtMost 3 &quot;abcd&quot;
</code></strong>False
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>lengthAtMost 3 $ repeat 'a'
</code></strong>False
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>lengthAtMost 3 $ &quot;abcd&quot; ++ undefined
</code></strong>False
</pre><pre>\n xs -&gt; lengthAtMost n (xs::String)  ==  (length xs &lt;= n)</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.26.0</p></div></body></html>