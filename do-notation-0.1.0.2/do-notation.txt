-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generalize do-notation to work on monads and indexed monads simultaneously.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/isovector/do-notation#readme</a>
@package do-notation
@version 0.1.0.2

module Control.Monad.Trans.Ix

-- | The free indexed monad generated from a monad <tt>m</tt>. Users are
--   not expected to use <a>Ix</a> directly, but to newtype over it,
--   specializing the kinds of <tt>i</tt> and <tt>j</tt> as necessary.
--   
--   GeneralizedNewtypeDeriving can be used to get the instances of
--   <a>IxFunctor</a>, <a>IxPointed</a>, <a>IxApplicative</a>,
--   <a>IxMonad</a>, <a>IxMonadZero</a> and <a>IxMonadPlus</a> for free.
newtype Ix (m :: Type -> Type) i j a
Ix :: m a -> Ix (m :: Type -> Type) i j a
[runIx] :: Ix (m :: Type -> Type) i j a -> m a

-- | Lift an <tt>m</tt> action into 'Ix m', maintaining the current index.
liftIx :: m a -> Ix m i i a

-- | Lift an <tt>m</tt> action into 'Ix m', changing the current index.
--   <a>unsafeLiftIx</a> is obviously unsafe due to the fact that it can
--   arbitrarily change the index.
unsafeLiftIx :: m a -> Ix m i j a
instance forall (m :: * -> *) k1 (i :: k1) k2 (j :: k2). GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.Ix.Ix m i j)
instance forall (m :: * -> *) k1 (i :: k1) k2 (j :: k2). GHC.Base.Applicative m => GHC.Base.Applicative (Control.Monad.Trans.Ix.Ix m i j)
instance forall (m :: * -> *) k1 (i :: k1) k2 (j :: k2). GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Ix.Ix m i j)
instance GHC.Base.Functor m => Data.Functor.Indexed.IxFunctor (Control.Monad.Trans.Ix.Ix m)
instance GHC.Base.Applicative m => Data.Functor.Indexed.IxPointed (Control.Monad.Trans.Ix.Ix m)
instance GHC.Base.Applicative m => Data.Functor.Indexed.IxApplicative (Control.Monad.Trans.Ix.Ix m)
instance GHC.Base.Monad m => Control.Monad.Indexed.IxMonad (Control.Monad.Trans.Ix.Ix m)
instance GHC.Base.MonadPlus m => Control.Monad.Indexed.IxMonadZero (Control.Monad.Trans.Ix.Ix m)
instance GHC.Base.MonadPlus m => Control.Monad.Indexed.IxMonadPlus (Control.Monad.Trans.Ix.Ix m)


-- | This module provides new implementations for <a>(&gt;&gt;=)</a>,
--   <a>(&gt;&gt;)</a>, <a>pure</a> and <a>return</a> so that they will
--   work simultaneously with both regular and indexed monads.
--   
--   Intended usage:
--   
--   @@ {-# LANGUAGE RebindableSyntax #-}
--   
--   import Language.Haskell.DoNotation import Prelude hiding (Monad (..),
--   pure) @@
module Language.Haskell.DoNotation

-- | Typeclass that provides <a>(&gt;&gt;=)</a> and <a>(&gt;&gt;)</a>.
class BindSyntax (x :: Type -> Type) (y :: Type -> Type) (z :: Type -> Type) | x y -> z, x z -> y, y z -> x
(>>=) :: BindSyntax x y z => x a -> (a -> y b) -> z b
(>>) :: BindSyntax x y z => x a -> y b -> z b

-- | Typeclass that provides <a>pure</a> and <a>return</a>.
class PureSyntax (x :: Type -> Type)
pure :: PureSyntax x => a -> x a
return :: PureSyntax x => a -> x a

-- | The <a>Monad</a> class defines the basic operations over a
--   <i>monad</i>, a concept from a branch of mathematics known as
--   <i>category theory</i>. From the perspective of a Haskell programmer,
--   however, it is best to think of a monad as an <i>abstract datatype</i>
--   of actions. Haskell's <tt>do</tt> expressions provide a convenient
--   syntax for writing monadic expressions.
--   
--   Instances of <a>Monad</a> should satisfy the following:
--   
--   <ul>
--   <li><i>Left identity</i> <tt><a>return</a> a <a>&gt;&gt;=</a> k = k
--   a</tt></li>
--   <li><i>Right identity</i> <tt>m <a>&gt;&gt;=</a> <a>return</a> =
--   m</tt></li>
--   <li><i>Associativity</i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) = (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   </ul>
--   
--   Furthermore, the <a>Monad</a> and <a>Applicative</a> operations should
--   relate as follows:
--   
--   <ul>
--   <li><pre><a>pure</a> = <a>return</a></pre></li>
--   <li><pre>m1 <a>&lt;*&gt;</a> m2 = m1 <a>&gt;&gt;=</a> (x1 -&gt; m2
--   <a>&gt;&gt;=</a> (x2 -&gt; <a>return</a> (x1 x2)))</pre></li>
--   </ul>
--   
--   The above laws imply:
--   
--   <ul>
--   <li><pre><a>fmap</a> f xs = xs <a>&gt;&gt;=</a> <a>return</a> .
--   f</pre></li>
--   <li><pre>(<a>&gt;&gt;</a>) = (<a>*&gt;</a>)</pre></li>
--   </ul>
--   
--   and that <a>pure</a> and (<a>&lt;*&gt;</a>) satisfy the applicative
--   functor laws.
--   
--   The instances of <a>Monad</a> for lists, <a>Maybe</a> and <a>IO</a>
--   defined in the <a>Prelude</a> satisfy these laws.
class Applicative m => Monad (m :: Type -> Type)
class IxApplicative m => IxMonad (m :: k -> k -> Type -> Type)
instance (GHC.Base.Monad m, x GHC.Types.~ m) => Language.Haskell.DoNotation.BindSyntax m x m
instance forall k1 (m :: k1 -> k1 -> * -> *) (x :: * -> *) (i :: k1) (j :: k1) (y :: * -> *) (k2 :: k1) (z :: * -> *). (Control.Monad.Indexed.IxMonad m, x GHC.Types.~ m i j, y GHC.Types.~ m j k2, z GHC.Types.~ m i k2) => Language.Haskell.DoNotation.BindSyntax x y z
instance GHC.Base.Applicative m => Language.Haskell.DoNotation.PureSyntax m
instance forall k (m :: k -> k -> * -> *) (j :: k) (i :: k). (Control.Monad.Indexed.IxMonad m, j GHC.Types.~ i) => Language.Haskell.DoNotation.PureSyntax (m i j)
