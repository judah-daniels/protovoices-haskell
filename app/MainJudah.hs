{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE RebindableSyntax #-}

module Main where

import Common
import Data.Maybe (catMaybes)
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.IO as TL
import Display
-- better do syntax
import Language.Haskell.DoNotation
import Musicology.Core
import Musicology.Core.Slicing
import Musicology.MusicXML
import Musicology.Pitch.Spelled as MT
import PVGrammar hiding
  ( slicesFromFile,
    slicesToPath,
  )
import PVGrammar.Generate
import PVGrammar.Parse
import Parser
import Prelude hiding
  ( Monad (..),
    pure,
  )

import Data.ByteString.Lazy
import Data.Char
import Data.Csv
import Data.Text.Encoding
import Data.Vector
-- | The main function that produces the results used in the paper and demonstrates the parser:
-- * a diagram of the (manually specified) derivation of the suspension example
--   (similar to what is shown in Figure 4)
--   rendered to 321sus.{tex,pdf}
-- * the number of derivations of the suspension example (Figure 4)
-- * the number of derivations of the beginning of the Bach example (Figure 1)
-- * an abritrary derivation of the suspension examle generated by the parser
--   rendered to 321sus-parsed.{tex,pdf}
main :: IO ()
main = test

test :: Either String (Vector (String, String, String, String, String))
test = decodeWith
    defaultDecodeOptions {decDelimiter = fromIntegral $ ord '\t' }
    NoHeader
    (fromStrict $ encodeUtf8 "a\t-\t-\t-\t\"RT USE \"\" Kenny\"\" â€¢ Hahahahahahahahaha. #Emmen #Brandstapel\"") 

-- do
-- plotDeriv "321sus.tex" deriv321sus
--
-- putStrLn "counting 321sus..."
-- count321sus <- parseSilent pvCount path321sus
--
-- putStrLn "parsing 321sus"
-- parses321sus <- parseSilent pvDeriv path321sus
-- let Just parse321 = firstDerivation parses321sus
-- plotDeriv "321sus-parsed.tex" parse321
--
-- putStrLn "counting Bach..."
-- bachSlices <- slicesFromFile "testdata/allemande.musicxml"
-- bachCount  <- parseSize pvCount $ slicesToPath $ take 9 bachSlices
--
-- putStrLn "Results:"
-- putStrLn $ "number of derivations (321sus): " <> show count321sus
-- putStrLn $ "number of derivations (bach): " <> show bachCount
-- putStrLn "derivation of 321sus:"
-- mapM_ print parse321

mainJD :: IO ()
mainJD = do
  putStrLn "parsing 321sus"
  parses321sus <- parseSilent pvDeriv path321sus
  let Just parse321 = firstDerivation parses321sus
  plotDeriv "321sus-parsed.tex" parse321

-- | The main entrypoint to the parser.
-- Expects an evaluator for the specific grammar
-- and an input path.
-- Returns the combined semiring value of all full derivations.
readTSV
  :: Parsable e a v
  => (TChart e a v -> VChart e a v -> Int -> IO ())
  -> Eval e e' a a' v
  -> Path a' e'
  -> IO v
parse logCharts eval path = do
  (tfinal, _) <- foldM (flip $ parseStep logCharts eval)
                       (tinit, vcEmpty len)
                       [2 .. len - 1]
  let goals = tcGetByLength tfinal len
  return $ R.sum $ S.getScoreVal . iValue <$> goals
 where
  wrapPath (Path a e rst) = Path (Inner a) (Just e) $ wrapPath rst
  wrapPath (PathEnd a   ) = Path (Inner a) Nothing $ PathEnd Stop
  path'     = Path Start Nothing $ wrapPath path
  len       = pathLen path'
  slicePath = mapNodesWithIndex
    0
    (\i notes -> Slice i (evalSlice eval <$> notes) i i)
    path'
  mkTrans l esurf r = mk
    <$> evalThaw eval (sContent l) esurf (sContent r) (isStop $ sContent r)
    where mk (e, v) = Transition l e r False := S.val v
  trans0 = mapEdges mkTrans slicePath
  tinit  = tcMerge tcEmpty $ concat trans0


-- helper functions
-- ----------------

plotDeriv fn deriv = do
  case replayDerivation derivationPlayerPV deriv of
    (Left err) -> putStrLn err
    (Right g) -> viewGraph fn g

slicesFromFile :: FilePath -> IO [[(SPitch, RightTied)]]
slicesFromFile file = do
  txt <- TL.readFile file
  case parseWithoutIds txt of
    Nothing -> pure []
    Just doc -> do
      let (xmlNotes, _) = parseScore doc
          notes = asNoteHeard <$> xmlNotes
          slices = slicePiece tiedSlicer notes
      pure $ mkSlice <$> filter (not . null) slices
  where
    mkSlice notes = mkNote <$> notes
    mkNote (note, tie) = (pitch note, rightTie tie)

slicesToPath ::
  (Interval i, Ord (ICOf i), Eq i) =>
  [[(Pitch i, RightTied)]] ->
  Path [Pitch (ICOf i)] [Edge (Pitch (ICOf i))]
slicesToPath = go
  where
    mkSlice = fmap (pc . fst)
    mkEdges notes = catMaybes $ mkEdge <$> notes
      where
        mkEdge (p, Ends) = Nothing
        mkEdge (p, Holds) = let p' = pc p in Just (Inner p', Inner p')
    go [] = error "cannot construct path from empty list"
    go [notes] = PathEnd (mkSlice notes)
    go (notes : rest) = Path (mkSlice notes) (mkEdges notes) $ go rest
